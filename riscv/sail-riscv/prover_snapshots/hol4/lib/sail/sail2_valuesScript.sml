(*Generated by Lem from ../../src/gen_lib/sail2_values.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_pervasives_extraTheory lem_machine_wordTheory;

val _ = numLib.prefer_num();



val _ = new_theory "sail2_values"

(*open import Pervasives_extra*)
(*open import Machine_word*)
(*open import Sail_impl_base*)


val _ = type_abbrev( "ii" , ``: int``);
val _ = type_abbrev( "nn" , ``: num``);

(*val nat_of_int : integer -> nat*)
val _ = Define `
 ((nat_of_int:int -> num) i=  (if i <( 0 : int) then( 0 : num) else Num (ABS (I i))))`;


(*val pow : integer -> integer -> integer*)
val _ = Define `
 ((pow0:int -> int -> int) m n=  (m ** (nat_of_int n)))`;


val _ = Define `
 ((pow2:int -> int) n=  (pow0(( 2 : int)) n))`;


(*val eq : forall 'a. Eq 'a => 'a -> 'a -> bool*)

(*val neq : forall 'a. Eq 'a => 'a -> 'a -> bool*)

(*let add_int l r = integerAdd l r
let add_signed l r = integerAdd l r
let sub_int l r = integerMinus l r
let mult_int l r = integerMult l r
let div_int l r = integerDiv l r
let div_nat l r = natDiv l r
let power_int_nat l r = integerPow l r
let power_int_int l r = integerPow l (nat_of_int r)
let negate_int i = integerNegate i
let min_int l r = integerMin l r
let max_int l r = integerMax l r

let add_real l r = realAdd l r
let sub_real l r = realMinus l r
let mult_real l r = realMult l r
let div_real l r = realDiv l r
let negate_real r = realNegate r
let abs_real r = realAbs r
let power_real b e = realPowInteger b e*)

(*val print_endline : string -> unit*)
val _ = Define `
 ((print_endline:string -> unit) _=  () )`;


(*val print : string -> unit*)
val _ = Define `
 ((print:string -> unit) _=  () )`;


(*val prerr_endline : string -> unit*)
val _ = Define `
 ((prerr_endline:string -> unit) _=  () )`;


val _ = Define `
 ((prerr:string -> unit) x=  (prerr_endline x))`;


(*val print_int : string -> integer -> unit*)
val _ = Define `
 ((print_int:string -> int -> unit) msg i=  (print_endline ( STRCAT msg (stringFromInteger i))))`;


(*val prerr_int : string -> integer -> unit*)
val _ = Define `
 ((prerr_int:string -> int -> unit) msg i=  (prerr_endline ( STRCAT msg (stringFromInteger i))))`;


(*val putchar : integer -> unit*)
val _ = Define `
 ((putchar:int -> unit) _=  () )`;


(*val shr_int : ii -> ii -> ii*)
 val shr_int_defn = Hol_defn "shr_int" `
 ((shr_int:int -> int -> int) x s=  (if s >( 0 : int) then shr_int (x /( 2 : int)) (s -( 1 : int)) else x))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn shr_int_defn;

(*val shl_int : integer -> integer -> integer*)
 val shl_int_defn = Hol_defn "shl_int" `
 ((shl_int:int -> int -> int) i shift=  (if shift >( 0 : int) then( 2 : int) * shl_int i (shift -( 1 : int)) else i))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn shl_int_defn;
val _ = Define `
 ((take_list:int -> 'a list -> 'a list) n xs=  (TAKE (nat_of_int n) xs))`;

val _ = Define `
 ((drop_list:int -> 'a list -> 'a list) n xs=  (DROP (nat_of_int n) xs))`;


(*val repeat : forall 'a. list 'a -> integer -> list 'a*)
 val repeat_defn = Hol_defn "repeat" `
 ((repeat:'a list -> int -> 'a list) xs n=
   (if n <=( 0 : int) then []
  else xs ++ repeat xs (n -( 1 : int))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn repeat_defn;

val _ = Define `
 ((duplicate_to_list:'a -> int -> 'a list) bit length=  (repeat [bit] length))`;


 val _ = Define `
 ((replace:'a list -> int -> 'a -> 'a list) bs (n : int) b'=  ((case bs of
    [] => []
  | b :: bs =>
     if n =( 0 : int) then b' :: bs
              else b :: replace bs (n -( 1 : int)) b'
  )))`;


val _ = Define `
 ((upper:'a -> 'a) n=  n)`;


(* Modulus operation corresponding to quot below -- result
   has sign of dividend. *)
val _ = Define `
 ((tmod_int:int -> int -> int) (a: int) (b:int) : int=
   (let m = ((ABS a) % (ABS b)) in
  if a <( 0 : int) then ~ m else m))`;


val _ = Define `
 ((hardware_mod:int -> int -> int)=  tmod_int)`;


(* There are different possible answers for integer divide regarding
rounding behaviour on negative operands. Positive operands always
round down so derive the one we want (trucation towards zero) from
that *)
val _ = Define `
 ((tdiv_int:int -> int -> int) (a:int) (b:int) : int=
   (let q = ((ABS a) / (ABS b)) in
  if ((a<( 0 : int)) <=> (b<( 0 : int))) then
    q  (* same sign -- result positive *)
  else
    ~ q))`;
 (* different sign -- result negative *)

val _ = Define `
 ((hardware_quot:int -> int -> int)=  tdiv_int)`;


val _ = Define `
 ((max_64u:int)=  (((( 2 : int))**(( 64 : num))) -( 1 : int)))`;

val _ = Define `
 ((max_64:int)=   (((( 2 : int))**(( 63 : num))) -( 1 : int)))`;

val _ = Define `
 ((min_64:int)=  (( 0 : int) - ((( 2 : int))**(( 63 : num)))))`;

val _ = Define `
 ((max_32u:int)=  ((( 4294967295 : int) : int)))`;

val _ = Define `
 ((max_32:int)=   ((( 2147483647 : int) : int)))`;

val _ = Define `
 ((min_32:int)=   ((( 0 : int) -( 2147483648 : int) : int)))`;

val _ = Define `
 ((max_8:int)=    ((( 127 : int) : int)))`;

val _ = Define `
 ((min_8:int)=    ((( 0 : int) -( 128 : int) : int)))`;

val _ = Define `
 ((max_5:int)=    ((( 31 : int) : int)))`;

val _ = Define `
 ((min_5:int)=    ((( 0 : int) -( 32 : int) : int)))`;


(* just_list takes a list of maybes and returns Just xs if all elements have
   a value, and Nothing if one of the elements is Nothing. *)
(*val just_list : forall 'a. list (maybe 'a) -> maybe (list 'a)*)
 val _ = Define `
 ((just_list:('a option)list ->('a list)option) l=  ((case l of
    [] => SOME []
  | (x :: xs) =>
    (case (x, just_list xs) of
        (SOME x, SOME xs) => SOME (x :: xs)
      | (_, _) => NONE
    )
  )))`;


(*val maybe_failwith : forall 'a. maybe 'a -> 'a*)
val _ = Define `
 ((maybe_failwith:'a option -> 'a)= 
  (\x .  (case x of   SOME a => a | NONE => failwith "maybe_failwith" )))`;


(*** Bits *)
val _ = Hol_datatype `
 bitU = B0 | B1 | BU`;


val _ = Define `
 ((showBitU:bitU -> string)= 
  (\x .  (case x of   B0 => "O" | B1 => "I" | BU => "U" )))`;


val _ = Define `
 ((bitU_char:bitU -> char)= 
  (\x .  (case x of   B0 => #"0" | B1 => #"1" | BU => #"?" )))`;


val _ = Define `
((instance_Show_Show_Sail2_values_bitU_dict:(bitU)Show_class)= (<|

  show_method := showBitU|>))`;


(*val compare_bitU : bitU -> bitU -> ordering*)
val _ = Define `
 ((compare_bitU:bitU -> bitU -> ordering) l r=  ((case (l, r) of
    (BU, BU) => EQUAL
  | (B0, B0) => EQUAL
  | (B1, B1) => EQUAL
  | (BU, _)  => LESS
  | (_, BU)  => GREATER
  | (B0, _)  => LESS
  | (_, _)   => GREATER
)))`;


val _ = Define `
((instance_Basic_classes_Ord_Sail2_values_bitU_dict:(bitU)Ord_class)= (<|

  compare_method := compare_bitU;

  isLess_method := (\  l r. (compare_bitU l r) = LESS);

  isLessEqual_method := (\ l r. (compare_bitU l r) <> GREATER);

  isGreater_method := (\  l r. (compare_bitU l r) = GREATER);

  isGreaterEqual_method := (\ l r. (compare_bitU l r) <> LESS)|>))`;


val _ = Hol_datatype `
(*  'a *) BitU_class= <|
  to_bitU_method : 'a -> bitU;
  of_bitU_method : bitU -> 'a
|>`;


val _ = Define `
((instance_Sail2_values_BitU_Sail2_values_bitU_dict:(bitU)BitU_class)= (<|

  to_bitU_method := (\ b. b);

  of_bitU_method := (\ b. b)|>))`;


val _ = Define `
 ((bool_of_bitU:bitU ->(bool)option)= 
  (\x .  (case x of   B0 => SOME F | B1 => SOME T | BU => NONE )))`;


val _ = Define `
 ((bitU_of_bool:bool -> bitU) b=  (if b then B1 else B0))`;


(*instance (BitU bool)
  let to_bitU = bitU_of_bool
  let of_bitU = bool_of_bitU
end*)

val _ = Define `
 ((cast_bit_bool:bitU ->(bool)option)=  bool_of_bitU)`;


val _ = Define `
 ((not_bit:bitU -> bitU)= 
  (\x .  (case x of   B1 => B0 | B0 => B1 | BU => BU )))`;


(*val is_one : integer -> bitU*)
val _ = Define `
 ((is_one:int -> bitU) i=
   (if i =( 1 : int) then B1 else B0))`;


(*val and_bit : bitU -> bitU -> bitU*)
val _ = Define `
 ((and_bit:bitU -> bitU -> bitU) x y=
   ((case (x, y) of
      (B0, _) => B0
    | (_, B0) => B0
    | (B1, B1) => B1
    | (_, _) => BU
  )))`;


(*val or_bit : bitU -> bitU -> bitU*)
val _ = Define `
 ((or_bit:bitU -> bitU -> bitU) x y=
   ((case (x, y) of
      (B1, _) => B1
    | (_, B1) => B1
    | (B0, B0) => B0
    | (_, _) => BU
  )))`;


(*val xor_bit : bitU -> bitU -> bitU*)
val _ = Define `
 ((xor_bit:bitU -> bitU -> bitU) x y=
  ((case (x, y) of
      (B0, B0) => B0
    | (B0, B1) => B1
    | (B1, B0) => B1
    | (B1, B1) => B0
    | (_, _) => BU
  )))`;


(*val &. : bitU -> bitU -> bitU*)

(*val |. : bitU -> bitU -> bitU*)

(*val +. : bitU -> bitU -> bitU*)


(*** Bool lists ***)

(*val bools_of_nat_aux : integer -> natural -> list bool -> list bool*)
 val bools_of_nat_aux_defn = Hol_defn "bools_of_nat_aux" `
 ((bools_of_nat_aux:int -> num ->(bool)list ->(bool)list) len x acc=
   (if len <=( 0 : int) then acc
  else bools_of_nat_aux (len -( 1 : int)) (x DIV( 2:num)) ((if (x MOD( 2:num)) =( 1:num) then T else F) :: acc)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn bools_of_nat_aux_defn;
val _ = Define `
 ((bools_of_nat:int -> num ->(bool)list) len n=  (bools_of_nat_aux len n []))`;
 (*List.reverse (bools_of_nat_aux n)*)

(*val nat_of_bools_aux : natural -> list bool -> natural*)
 val _ = Define `
 ((nat_of_bools_aux:num ->(bool)list -> num) acc bs=  ((case bs of
    [] => acc
  | T :: bs => nat_of_bools_aux ((( 2:num) * acc) +( 1:num)) bs
  | F :: bs => nat_of_bools_aux (( 2:num) * acc) bs
)))`;

val _ = Define `
 ((nat_of_bools:(bool)list -> num) bs=  (nat_of_bools_aux(( 0:num)) bs))`;


(*val unsigned_of_bools : list bool -> integer*)
val _ = Define `
 ((unsigned_of_bools:(bool)list -> int) bs=  (int_of_num (nat_of_bools bs)))`;


(*val signed_of_bools : list bool -> integer*)
val _ = Define `
 ((signed_of_bools:(bool)list -> int) bs=
   ((case bs of
      T :: _  =>( 0 : int) - (( 1 : int) + (unsigned_of_bools (MAP (\ x. ~ x) bs)))
    | F :: _ => unsigned_of_bools bs
    | [] =>( 0 : int) (* Treat empty list as all zeros *)
  )))`;


(*val int_of_bools : bool -> list bool -> integer*)
val _ = Define `
 ((int_of_bools:bool ->(bool)list -> int) sign bs=  (if sign then signed_of_bools bs else unsigned_of_bools bs))`;


(*val pad_list : forall 'a. 'a -> list 'a -> integer -> list 'a*)
 val pad_list_defn = Hol_defn "pad_list" `
 ((pad_list:'a -> 'a list -> int -> 'a list) x xs n=
   (if n <=( 0 : int) then xs else pad_list x (x :: xs) (n -( 1 : int))))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn pad_list_defn;

val _ = Define `
 ((ext_list:'a -> int -> 'a list -> 'a list) pad len xs=
   (let longer = (len - (int_of_num (LENGTH xs))) in
  if longer <( 0 : int) then DROP (nat_of_int (ABS (longer))) xs
  else pad_list pad xs longer))`;


val _ = Define `
 ((extz_bools:int ->(bool)list ->(bool)list) len bs=  (ext_list F len bs))`;

val _ = Define `
 ((exts_bools:int ->(bool)list ->(bool)list) len bs=
   ((case bs of
      T :: _ => ext_list T len bs
    | _ => ext_list F len bs
  )))`;


 val _ = Define `
 ((add_one_bool_ignore_overflow_aux:(bool)list ->(bool)list) bits=  ((case bits of
    [] => []
  | F :: bits => T :: bits
  | T :: bits => F :: add_one_bool_ignore_overflow_aux bits
)))`;


val _ = Define `
 ((add_one_bool_ignore_overflow:(bool)list ->(bool)list) bits=
   (REVERSE (add_one_bool_ignore_overflow_aux (REVERSE bits))))`;


(*let bool_list_of_int n =
  let bs_abs = false :: bools_of_nat (naturalFromInteger (abs n)) in
  if n >= (0 : integer) then bs_abs
  else add_one_bool_ignore_overflow (List.map not bs_abs)
let bools_of_int len n = exts_bools len (bool_list_of_int n)*)
val _ = Define `
 ((bools_of_int:int -> int ->(bool)list) len n=
   (let bs_abs = (bools_of_nat len (Num (ABS (ABS n)))) in
  if n >= (( 0 : int) : int) then bs_abs
  else add_one_bool_ignore_overflow (MAP (\ x. ~ x) bs_abs)))`;


(*** Bit lists ***)

(*val has_undefined_bits : list bitU -> bool*)
val _ = Define `
 ((has_undefined_bits:(bitU)list -> bool) bs=  (EXISTS (\x .  
  (case x of BU => T | _ => F )) bs))`;


val _ = Define `
 ((bits_of_nat:int -> num ->(bitU)list) len n=  (MAP bitU_of_bool (bools_of_nat len n)))`;


val _ = Define `
 ((nat_of_bits:(bitU)list ->(num)option) bits=
   ((case (just_list (MAP bool_of_bitU bits)) of
      SOME bs => SOME (nat_of_bools bs)
    | NONE => NONE
  )))`;


val _ = Define `
 ((not_bits:(bitU)list ->(bitU)list)=  (MAP not_bit))`;


(*val binop_list : forall 'a. ('a -> 'a -> 'a) -> list 'a -> list 'a -> list 'a*)
val _ = Define `
 ((binop_list:('a -> 'a -> 'a) -> 'a list -> 'a list -> 'a list) op xs ys=
   (FOLDR (\ (x, y) acc .  op x y :: acc) [] (list_combine xs ys)))`;


val _ = Define `
 ((unsigned_of_bits:(bitU)list ->(int)option) bits=
   ((case (just_list (MAP bool_of_bitU bits)) of
      SOME bs => SOME (unsigned_of_bools bs)
    | NONE => NONE
  )))`;


val _ = Define `
 ((signed_of_bits:(bitU)list ->(int)option) bits=
   ((case (just_list (MAP bool_of_bitU bits)) of
      SOME bs => SOME (signed_of_bools bs)
    | NONE => NONE
  )))`;


(*val int_of_bits : bool -> list bitU -> maybe integer*)
val _ = Define `
 ((int_of_bits:bool ->(bitU)list ->(int)option) sign bs=  (if sign then signed_of_bits bs else unsigned_of_bits bs))`;


val _ = Define `
 ((extz_bits:int ->(bitU)list ->(bitU)list) len bits=  (ext_list B0 len bits))`;

val _ = Define `
 ((exts_bits:int ->(bitU)list ->(bitU)list) len bits=
   ((case bits of
    BU :: _ => ext_list BU len bits
  | B1 :: _ => ext_list B1 len bits
  | _ => ext_list B0 len bits
  )))`;


 val _ = Define `
 ((add_one_bit_ignore_overflow_aux:(bitU)list ->(bitU)list) bits=  ((case bits of
    [] => []
  | B0 :: bits => B1 :: bits
  | B1 :: bits => B0 :: add_one_bit_ignore_overflow_aux bits
  | BU :: bits => BU :: MAP (\b .  
  (case (b ) of ( _ ) => BU )) bits
)))`;


val _ = Define `
 ((add_one_bit_ignore_overflow:(bitU)list ->(bitU)list) bits=
   (REVERSE (add_one_bit_ignore_overflow_aux (REVERSE bits))))`;


(*let bit_list_of_int n = List.map bitU_of_bool (bool_list_of_int n)
let bits_of_int len n = exts_bits len (bit_list_of_int n)*)
val _ = Define `
 ((bits_of_int:int -> int ->(bitU)list) len n=  (MAP bitU_of_bool (bools_of_int len n)))`;


(*val arith_op_bits :
  (integer -> integer -> integer) -> bool -> list bitU -> list bitU -> list bitU*)
val _ = Define `
 ((arith_op_bits:(int -> int -> int) -> bool ->(bitU)list ->(bitU)list ->(bitU)list) op sign l r=
   ((case (int_of_bits sign l, int_of_bits sign r) of
      (SOME li, SOME ri) => bits_of_int (int_of_num (LENGTH l)) (op li ri)
    | (_, _) => repeat [BU] (int_of_num (LENGTH l))
  )))`;


val _ = Define `
 ((char_of_nibble:bitU#bitU#bitU#bitU ->(char)option)= 
  (\x .  (case x of
               (B0, B0, B0, B0) => SOME #"0"
           | (B0, B0, B0, B1) => SOME #"1"
           | (B0, B0, B1, B0) => SOME #"2"
           | (B0, B0, B1, B1) => SOME #"3"
           | (B0, B1, B0, B0) => SOME #"4"
           | (B0, B1, B0, B1) => SOME #"5"
           | (B0, B1, B1, B0) => SOME #"6"
           | (B0, B1, B1, B1) => SOME #"7"
           | (B1, B0, B0, B0) => SOME #"8"
           | (B1, B0, B0, B1) => SOME #"9"
           | (B1, B0, B1, B0) => SOME #"A"
           | (B1, B0, B1, B1) => SOME #"B"
           | (B1, B1, B0, B0) => SOME #"C"
           | (B1, B1, B0, B1) => SOME #"D"
           | (B1, B1, B1, B0) => SOME #"E"
           | (B1, B1, B1, B1) => SOME #"F"
           | _ => NONE
         )))`;


 val _ = Define `
 ((hexstring_of_bits:(bitU)list ->((char)list)option) bs=  ((case bs of
    b1 :: b2 :: b3 :: b4 :: bs =>
     let n = (char_of_nibble (b1, b2, b3, b4)) in
     let s = (hexstring_of_bits bs) in
     (case (n, s) of
       (SOME n, SOME s) => SOME (n :: s)
     | _ => NONE
     )
  | [] => SOME []
  | _ => NONE
  )))`;


val _ = Define `
 ((show_bitlist:(bitU)list -> string) bs=
   ((case hexstring_of_bits bs of
    SOME s => IMPLODE (#"0" :: (#"x" :: s))
  | NONE => IMPLODE (#"0" :: (#"b" :: MAP bitU_char bs))
  )))`;


(*val subrange_list_inc : forall 'a. list 'a -> integer -> integer -> list 'a*)
val _ = Define `
 ((subrange_list_inc:'a list -> int -> int -> 'a list) xs i j=
   (let (toJ,suffix0) = (TAKE (nat_of_int (j +( 1 : int))) xs, DROP (nat_of_int (j +( 1 : int))) xs) in
  let (prefix0,fromItoJ) = (TAKE (nat_of_int i) toJ, DROP (nat_of_int i) toJ) in
  fromItoJ))`;


(*val subrange_list_dec : forall 'a. list 'a -> integer -> integer -> list 'a*)
val _ = Define `
 ((subrange_list_dec:'a list -> int -> int -> 'a list) xs i j=
   (let top = ((int_of_num (LENGTH xs)) -( 1 : int)) in
  subrange_list_inc xs (top - i) (top - j)))`;


(*val subrange_list : forall 'a. bool -> list 'a -> integer -> integer -> list 'a*)
val _ = Define `
 ((subrange_list:bool -> 'a list -> int -> int -> 'a list) is_inc xs i j=  (if is_inc then subrange_list_inc xs i j else subrange_list_dec xs i j))`;


(*val update_subrange_list_inc : forall 'a. list 'a -> integer -> integer -> list 'a -> list 'a*)
val _ = Define `
 ((update_subrange_list_inc:'a list -> int -> int -> 'a list -> 'a list) xs i j xs'=
   (let (toJ,suffix) = (TAKE (nat_of_int (j +( 1 : int))) xs, DROP (nat_of_int (j +( 1 : int))) xs) in
  let (prefix,fromItoJ0) = (TAKE (nat_of_int i) toJ, DROP (nat_of_int i) toJ) in
  (prefix ++ xs') ++ suffix))`;


(*val update_subrange_list_dec : forall 'a. list 'a -> integer -> integer -> list 'a -> list 'a*)
val _ = Define `
 ((update_subrange_list_dec:'a list -> int -> int -> 'a list -> 'a list) xs i j xs'=
   (let top = ((int_of_num (LENGTH xs)) -( 1 : int)) in
  update_subrange_list_inc xs (top - i) (top - j) xs'))`;


(*val update_subrange_list : forall 'a. bool -> list 'a -> integer -> integer -> list 'a -> list 'a*)
val _ = Define `
 ((update_subrange_list:bool -> 'a list -> int -> int -> 'a list -> 'a list) is_inc xs i j xs'=
   (if is_inc then update_subrange_list_inc xs i j xs' else update_subrange_list_dec xs i j xs'))`;


(*val access_list_inc : forall 'a. list 'a -> integer -> 'a*)
val _ = Define `
 ((access_list_inc:'a list -> int -> 'a) xs n=  (EL (nat_of_int n) xs))`;


(*val access_list_dec : forall 'a. list 'a -> integer -> 'a*)
val _ = Define `
 ((access_list_dec:'a list -> int -> 'a) xs n=
   (let top = ((int_of_num (LENGTH xs)) -( 1 : int)) in
  access_list_inc xs (top - n)))`;


(*val access_list : forall 'a. bool -> list 'a -> integer -> 'a*)
val _ = Define `
 ((access_list:bool -> 'a list -> int -> 'a) is_inc xs n=
   (if is_inc then access_list_inc xs n else access_list_dec xs n))`;


(*val update_list_inc : forall 'a. list 'a -> integer -> 'a -> list 'a*)
val _ = Define `
 ((update_list_inc:'a list -> int -> 'a -> 'a list) xs n x=  (LUPDATE x (nat_of_int n) xs))`;


(*val update_list_dec : forall 'a. list 'a -> integer -> 'a -> list 'a*)
val _ = Define `
 ((update_list_dec:'a list -> int -> 'a -> 'a list) xs n x=
   (let top = ((int_of_num (LENGTH xs)) -( 1 : int)) in
  update_list_inc xs (top - n) x))`;


(*val update_list : forall 'a. bool -> list 'a -> integer -> 'a -> list 'a*)
val _ = Define `
 ((update_list:bool -> 'a list -> int -> 'a -> 'a list) is_inc xs n x=
   (if is_inc then update_list_inc xs n x else update_list_dec xs n x))`;


val _ = Define `
 ((extract_only_bit:(bitU)list -> bitU)= 
  (\x .  (case x of   [] => BU | [e] => e | _ => BU )))`;


(*** Machine words *)

(*val length_mword : forall 'a. mword 'a -> integer*)

(*val slice_mword_dec : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b*)
val _ = Define `
 ((slice_mword_dec:'a words$word -> int -> int -> 'b words$word) w i j=  (words$word_extract (nat_of_int j) (nat_of_int i) w))`;


(*val slice_mword_inc : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b*)
val _ = Define `
 ((slice_mword_inc:'a words$word -> int -> int -> 'b words$word) w i j=
   (let top = ((int_of_num (words$word_len w)) -( 1 : int)) in
  slice_mword_dec w (top - i) (top - j)))`;


(*val slice_mword : forall 'a 'b. bool -> mword 'a -> integer -> integer -> mword 'b*)
val _ = Define `
 ((slice_mword:bool -> 'a words$word -> int -> int -> 'b words$word) is_inc w i j=  (if is_inc then slice_mword_inc w i j else slice_mword_dec w i j))`;


(*val update_slice_mword_dec : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b -> mword 'a*)
val _ = Define `
 ((update_slice_mword_dec:'a words$word -> int -> int -> 'b words$word -> 'a words$word) w i j w'=  (words$bit_field_insert (nat_of_int j) (nat_of_int i) w' w))`;


(*val update_slice_mword_inc : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b -> mword 'a*)
val _ = Define `
 ((update_slice_mword_inc:'a words$word -> int -> int -> 'b words$word -> 'a words$word) w i j w'=
   (let top = ((int_of_num (words$word_len w)) -( 1 : int)) in
  update_slice_mword_dec w (top - i) (top - j) w'))`;


(*val update_slice_mword : forall 'a 'b. bool -> mword 'a -> integer -> integer -> mword 'b -> mword 'a*)
val _ = Define `
 ((update_slice_mword:bool -> 'a words$word -> int -> int -> 'b words$word -> 'a words$word) is_inc w i j w'=
   (if is_inc then update_slice_mword_inc w i j w' else update_slice_mword_dec w i j w'))`;


(*val access_mword_dec : forall 'a. mword 'a -> integer -> bitU*)
val _ = Define `
 ((access_mword_dec:'a words$word -> int -> bitU) w n=  (bitU_of_bool (words$word_bit (nat_of_int n) w)))`;


(*val access_mword_inc : forall 'a. mword 'a -> integer -> bitU*)
val _ = Define `
 ((access_mword_inc:'a words$word -> int -> bitU) w n=
   (let top = ((int_of_num (words$word_len w)) -( 1 : int)) in
  access_mword_dec w (top - n)))`;


(*val access_mword : forall 'a. bool -> mword 'a -> integer -> bitU*)
val _ = Define `
 ((access_mword:bool -> 'a words$word -> int -> bitU) is_inc w n=
   (if is_inc then access_mword_inc w n else access_mword_dec w n))`;


(*val update_mword_bool_dec : forall 'a. mword 'a -> integer -> bool -> mword 'a*)
val _ = Define `
 ((update_mword_bool_dec:'a words$word -> int -> bool -> 'a words$word) w n b=  ($:+ (nat_of_int n) b w))`;

val _ = Define `
 ((update_mword_dec:'a words$word -> int -> bitU ->('a words$word)option) w n b=  (OPTION_MAP (update_mword_bool_dec w n) (bool_of_bitU b)))`;


(*val update_mword_bool_inc : forall 'a. mword 'a -> integer -> bool -> mword 'a*)
val _ = Define `
 ((update_mword_bool_inc:'a words$word -> int -> bool -> 'a words$word) w n b=
   (let top = ((int_of_num (words$word_len w)) -( 1 : int)) in
  update_mword_bool_dec w (top - n) b))`;

val _ = Define `
 ((update_mword_inc:'a words$word -> int -> bitU ->('a words$word)option) w n b=  (OPTION_MAP (update_mword_bool_inc w n) (bool_of_bitU b)))`;


(*val int_of_mword : forall 'a. bool -> mword 'a -> integer*)
val _ = Define `
 ((int_of_mword:bool -> 'a words$word -> int) sign w=
   (if sign then integer_word$w2i w else lem$w2ui w))`;


(* Translating between a type level number (itself 'n) and an integer *)

val _ = Define `
 ((size_itself_int:'a itself -> int) x=  (int_of_num (size_itself x)))`;


(* NB: the corresponding sail type is forall 'n. atom('n) -> itself('n),
   the actual integer is ignored. *)

(*val make_the_value : forall 'n. integer -> itself 'n*)
val _ = Define `
 ((make_the_value:int -> 'n itself) _=  the_value)`;


(*** Bitvectors *)

val _ = Hol_datatype `
(*  'a *) Bitvector_class= <|
  bits_of_method : 'a -> bitU list;
  (* We allow of_bits to be partial, as not all bitvector representations
     support undefined bits *)
  of_bits_method : bitU list ->  'a option;
  of_bools_method : bool list -> 'a;
  length_method : 'a -> int;
  (* of_int: the first parameter specifies the desired length of the bitvector *)
  of_int_method : int -> int -> 'a;
  (* Conversion to integers is undefined if any bit is undefined *)
  unsigned_method : 'a ->  int option;
  signed_method : 'a ->  int option;
  (* Lifting of integer operations to bitvectors:  The boolean flag indicates
     whether to treat the bitvectors as signed (true) or not (false). *)
  arith_op_bv_method : (int -> int -> int) -> bool -> 'a -> 'a -> 'a
|>`;


(*val of_bits_failwith : forall 'a. Bitvector 'a => list bitU -> 'a*)
val _ = Define `
 ((of_bits_failwith:'a Bitvector_class ->(bitU)list -> 'a)dict_Sail2_values_Bitvector_a bits=  (maybe_failwith (
  dict_Sail2_values_Bitvector_a.of_bits_method bits)))`;


val _ = Define `
 ((int_of_bv:'a Bitvector_class -> bool -> 'a ->(int)option)dict_Sail2_values_Bitvector_a sign=  (if sign then  
  dict_Sail2_values_Bitvector_a.signed_method else  dict_Sail2_values_Bitvector_a.unsigned_method))`;


val _ = Define `
((instance_Sail2_values_Bitvector_list_dict:'a BitU_class ->('a list)Bitvector_class)dict_Sail2_values_BitU_a= (<|

  bits_of_method := (\ v. MAP  
  dict_Sail2_values_BitU_a.to_bitU_method v);

  of_bits_method := (\ v. SOME (MAP  
  dict_Sail2_values_BitU_a.of_bitU_method v));

  of_bools_method := (\ v. MAP  
  dict_Sail2_values_BitU_a.of_bitU_method (MAP bitU_of_bool v));

  length_method := (\ xs. int_of_num (LENGTH xs));

  of_int_method := (\ len n. MAP  
  dict_Sail2_values_BitU_a.of_bitU_method (bits_of_int len n));

  unsigned_method := (\ v. unsigned_of_bits (MAP  
  dict_Sail2_values_BitU_a.to_bitU_method v));

  signed_method := (\ v. signed_of_bits (MAP  
  dict_Sail2_values_BitU_a.to_bitU_method v));

  arith_op_bv_method := (\ op sign l r. MAP  
  dict_Sail2_values_BitU_a.of_bitU_method (arith_op_bits op sign (MAP  
  dict_Sail2_values_BitU_a.to_bitU_method l) (MAP  dict_Sail2_values_BitU_a.to_bitU_method r)))|>))`;


val _ = Define `
((instance_Sail2_values_Bitvector_Machine_word_mword_dict:('a words$word)Bitvector_class)= (<|

  bits_of_method := (\ v. MAP bitU_of_bool (bitstring$w2v v));

  of_bits_method := (\ v. OPTION_MAP bitstring$v2w (just_list (MAP bool_of_bitU v)));

  of_bools_method := (\ v. bitstring$v2w v);

  length_method := (\ v. int_of_num (words$word_len v));

  of_int_method := (\i n .  
  (case (i ,n ) of ( _ , n ) => integer_word$i2w n ));

  unsigned_method := (\ v. SOME (lem$w2ui v));

  signed_method := (\ v. SOME (integer_word$w2i v));

  arith_op_bv_method := (\ op sign l r. integer_word$i2w (op (int_of_mword sign l) (int_of_mword sign r)))|>))`;


val _ = Define `
 ((access_bv_inc:'a Bitvector_class -> 'a -> int -> bitU)dict_Sail2_values_Bitvector_a v n=  (access_list T  (
  dict_Sail2_values_Bitvector_a.bits_of_method v) n))`;

val _ = Define `
 ((access_bv_dec:'a Bitvector_class -> 'a -> int -> bitU)dict_Sail2_values_Bitvector_a v n=  (access_list F (
  dict_Sail2_values_Bitvector_a.bits_of_method v) n))`;


val _ = Define `
 ((update_bv_inc:'a Bitvector_class -> 'a -> int -> bitU ->(bitU)list)dict_Sail2_values_Bitvector_a v n b=  (update_list T  (
  dict_Sail2_values_Bitvector_a.bits_of_method v) n b))`;

val _ = Define `
 ((update_bv_dec:'a Bitvector_class -> 'a -> int -> bitU ->(bitU)list)dict_Sail2_values_Bitvector_a v n b=  (update_list F (
  dict_Sail2_values_Bitvector_a.bits_of_method v) n b))`;


val _ = Define `
 ((subrange_bv_inc:'a Bitvector_class -> 'a -> int -> int ->(bitU)list)dict_Sail2_values_Bitvector_a v i j=  (subrange_list T  (
  dict_Sail2_values_Bitvector_a.bits_of_method v) i j))`;

val _ = Define `
 ((subrange_bv_dec:'a Bitvector_class -> 'a -> int -> int ->(bitU)list)dict_Sail2_values_Bitvector_a v i j=  (subrange_list F (
  dict_Sail2_values_Bitvector_a.bits_of_method v) i j))`;


val _ = Define `
 ((update_subrange_bv_inc:'a Bitvector_class -> 'b Bitvector_class -> 'b -> int -> int -> 'a ->(bitU)list)dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b v i j v'=  (update_subrange_list T  (
  dict_Sail2_values_Bitvector_b.bits_of_method v) i j (dict_Sail2_values_Bitvector_a.bits_of_method v')))`;

val _ = Define `
 ((update_subrange_bv_dec:'a Bitvector_class -> 'b Bitvector_class -> 'b -> int -> int -> 'a ->(bitU)list)dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b v i j v'=  (update_subrange_list F (
  dict_Sail2_values_Bitvector_b.bits_of_method v) i j (dict_Sail2_values_Bitvector_a.bits_of_method v')))`;


(*val extz_bv : forall 'a. Bitvector 'a => integer -> 'a -> list bitU*)
val _ = Define `
 ((extz_bv:'a Bitvector_class -> int -> 'a ->(bitU)list)dict_Sail2_values_Bitvector_a n v=  (extz_bits n (
  dict_Sail2_values_Bitvector_a.bits_of_method v)))`;


(*val exts_bv : forall 'a. Bitvector 'a => integer -> 'a -> list bitU*)
val _ = Define `
 ((exts_bv:'a Bitvector_class -> int -> 'a ->(bitU)list)dict_Sail2_values_Bitvector_a n v=  (exts_bits n (
  dict_Sail2_values_Bitvector_a.bits_of_method v)))`;


(*val nat_of_bv : forall 'a. Bitvector 'a => 'a -> maybe nat*)
val _ = Define `
 ((nat_of_bv:'a Bitvector_class -> 'a ->(num)option)dict_Sail2_values_Bitvector_a v=  (OPTION_MAP nat_of_int (
  dict_Sail2_values_Bitvector_a.unsigned_method v)))`;


(*val string_of_bv : forall 'a. Bitvector 'a => 'a -> string*)
val _ = Define `
 ((string_of_bv:'a Bitvector_class -> 'a -> string)dict_Sail2_values_Bitvector_a v=  (show_bitlist (
  dict_Sail2_values_Bitvector_a.bits_of_method v)))`;


(*val print_bits : forall 'a. Bitvector 'a => string -> 'a -> unit*)
val _ = Define `
 ((print_bits:'a Bitvector_class -> string -> 'a -> unit)dict_Sail2_values_Bitvector_a str v=  (print_endline ( STRCAT str (string_of_bv 
  dict_Sail2_values_Bitvector_a v))))`;


(*val dec_str : integer -> string*)
val _ = Define `
 ((dec_str:int -> string) bv=  (lem_string_extra$stringFromInteger bv))`;


(*val concat_str : string -> string -> string*)
val _ = Define `
 ((concat_str:string -> string -> string) str1 str2=   (STRCAT str1 str2))`;


(*val int_of_bit : bitU -> integer*)
val _ = Define `
 ((int_of_bit:bitU -> int) b=
   ((case b of
    B0 =>( 0 : int)
  | B1 =>( 1 : int)
  | _ => failwith "int_of_bit saw unknown"
  )))`;


(*val count_leading_zero_bits : list bitU -> integer*)
 val count_leading_zero_bits_defn = Hol_defn "count_leading_zero_bits" `
 ((count_leading_zero_bits:(bitU)list -> int) v=
   ((case v of
    B0 :: v' => count_leading_zero_bits v' +( 1 : int)
  | _ =>( 0 : int)
  )))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn count_leading_zero_bits_defn;

(*val count_leading_zeros_bv : forall 'a. Bitvector 'a => 'a -> integer*)
val _ = Define `
 ((count_leading_zeros_bv:'a Bitvector_class -> 'a -> int)dict_Sail2_values_Bitvector_a v=  (count_leading_zero_bits (
  dict_Sail2_values_Bitvector_a.bits_of_method v)))`;


(*val decimal_string_of_bv : forall 'a. Bitvector 'a => 'a -> string*)
val _ = Define `
 ((decimal_string_of_bv:'a Bitvector_class -> 'a -> string)dict_Sail2_values_Bitvector_a bv=
   (let place_values =
    (lem_list$mapi
      (\ i b .  (int_of_bit b) * (( 2 : int) ** i))
      (REVERSE (dict_Sail2_values_Bitvector_a.bits_of_method bv)))
  in
  let sum = (FOLDL (+)(( 0 : int)) place_values) in
  lem_string_extra$stringFromInteger sum))`;


(*** Bytes and addresses *)

val _ = type_abbrev( "memory_byte" , ``: bitU list``);

(*val byte_chunks : forall 'a. list 'a -> maybe (list (list 'a))*)
 val _ = Define `
 ((byte_chunks:'a list ->(('a list)list)option) bs=  ((case bs of
    [] => SOME []
  | a::b::c::d::e::f::g::h::rest =>
     OPTION_BIND (byte_chunks rest) (\ rest .  SOME ([a;b;c;d;e;f;g;h] :: rest))
  | _ => NONE
)))`;


(*val bytes_of_bits : forall 'a. Bitvector 'a => 'a -> maybe (list memory_byte)*)
val _ = Define `
 ((bytes_of_bits:'a Bitvector_class -> 'a ->((memory_byte)list)option)dict_Sail2_values_Bitvector_a bs=  (byte_chunks (
  dict_Sail2_values_Bitvector_a.bits_of_method bs)))`;


(*val bits_of_bytes : list memory_byte -> list bitU*)
val _ = Define `
 ((bits_of_bytes:((bitU)list)list ->(bitU)list) bs=  (FLAT (MAP (\ v. MAP (\ b. b) v) bs)))`;


val _ = Define `
 ((mem_bytes_of_bits:'a Bitvector_class -> 'a ->(((bitU)list)list)option)dict_Sail2_values_Bitvector_a bs=  (OPTION_MAP REVERSE (bytes_of_bits 
  dict_Sail2_values_Bitvector_a bs)))`;

val _ = Define `
 ((bits_of_mem_bytes:((bitU)list)list ->(bitU)list) bs=  (bits_of_bytes (REVERSE bs)))`;


(*val bitv_of_byte_lifteds : list Sail_impl_base.byte_lifted -> list bitU
let bitv_of_byte_lifteds v =
  foldl (fun x (Byte_lifted y) -> x ++ (List.map bitU_of_bit_lifted y)) [] v

val bitv_of_bytes : list Sail_impl_base.byte -> list bitU
let bitv_of_bytes v =
  foldl (fun x (Byte y) -> x ++ (List.map bitU_of_bit y)) [] v

val byte_lifteds_of_bitv : list bitU -> list byte_lifted
let byte_lifteds_of_bitv bits =
  let bits = List.map bit_lifted_of_bitU bits in
  byte_lifteds_of_bit_lifteds bits

val bytes_of_bitv : list bitU -> list byte
let bytes_of_bitv bits =
  let bits = List.map bit_of_bitU bits in
  bytes_of_bits bits

val bit_lifteds_of_bitUs : list bitU -> list bit_lifted
let bit_lifteds_of_bitUs bits = List.map bit_lifted_of_bitU bits

val bit_lifteds_of_bitv : list bitU -> list bit_lifted
let bit_lifteds_of_bitv v = bit_lifteds_of_bitUs v


val address_lifted_of_bitv : list bitU -> address_lifted
let address_lifted_of_bitv v =
  let byte_lifteds = byte_lifteds_of_bitv v in
  let maybe_address_integer =
    match (maybe_all (List.map byte_of_byte_lifted byte_lifteds)) with
    | Just bs -> Just (integer_of_byte_list bs)
    | _ -> Nothing
    end in
  Address_lifted byte_lifteds maybe_address_integer

val bitv_of_address_lifted : address_lifted -> list bitU
let bitv_of_address_lifted (Address_lifted bs _) = bitv_of_byte_lifteds bs

val address_of_bitv : list bitU -> address
let address_of_bitv v =
  let bytes = bytes_of_bitv v in
  address_of_byte_list bytes*)

 val reverse_endianness_list_defn = Hol_defn "reverse_endianness_list" `
 ((reverse_endianness_list:'a list -> 'a list) bits=
   (if LENGTH bits <=( 8 : num) then bits else
    reverse_endianness_list (drop_list(( 8 : int)) bits) ++ take_list(( 8 : int)) bits))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn reverse_endianness_list_defn;


(*** Registers *)

(*type register_field = string
type register_field_index = string * (integer * integer) (* name, start and end *)

type register =
  | Register of string * (* name *)
                integer * (* length *)
                integer * (* start index *)
                bool * (* is increasing *)
                  list register_field_index
  | UndefinedRegister of integer (* length *)
  | RegisterPair of register * register*)

val _ = Hol_datatype `
(* ( 'a_regstate, 'b_regval, 'c_a) *) register_ref =
  <| name : string;
     (*is_inc : bool;*)
     read_from :'a_regstate -> 'c_a;
     write_to :'c_a -> 'a_regstate -> 'a_regstate;
     of_regval :'b_regval -> 'c_a option;
     regval_of :'c_a -> 'b_regval |>`;


(* Register accessors: pair of functions for reading and writing register values *)
val _ = type_abbrev((* ( 'regstate, 'regval) *) "register_accessors" , ``:
  ((string -> 'regstate ->  'regval option) #
   (string -> 'regval -> 'regstate ->  'regstate option))``);

val _ = Hol_datatype `
(* ( 'a_regtype, 'b_a) *) field_ref =
  <| field_name : string;
     field_start : int;
     field_is_inc : bool;
     get_field :'a_regtype -> 'b_a;
     set_field :'a_regtype -> 'b_a -> 'a_regtype |>`;


(*let name_of_reg = function
  | Register name _ _ _ _ -> name
  | UndefinedRegister _ -> failwith "name_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "name_of_reg RegisterPair"
end

let size_of_reg = function
  | Register _ size _ _ _ -> size
  | UndefinedRegister size -> size
  | RegisterPair _ _ -> failwith "size_of_reg RegisterPair"
end

let start_of_reg = function
  | Register _ _ start _ _ -> start
  | UndefinedRegister _ -> failwith "start_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "start_of_reg RegisterPair"
end

let is_inc_of_reg = function
  | Register _ _ _ is_inc _ -> is_inc
  | UndefinedRegister _ -> failwith "is_inc_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "in_inc_of_reg RegisterPair"
end

let dir_of_reg = function
  | Register _ _ _ is_inc _ -> dir_of_bool is_inc
  | UndefinedRegister _ -> failwith "dir_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "dir_of_reg RegisterPair"
end

let size_of_reg_nat reg = natFromInteger (size_of_reg reg)
let start_of_reg_nat reg = natFromInteger (start_of_reg reg)

val register_field_indices_aux : register -> register_field -> maybe (integer * integer)
let rec register_field_indices_aux register rfield =
  match register with
  | Register _ _ _ _ rfields -> List.lookup rfield rfields
  | RegisterPair r1 r2 ->
      let m_indices = register_field_indices_aux r1 rfield in
      if isJust m_indices then m_indices else register_field_indices_aux r2 rfield
  | UndefinedRegister _ -> Nothing
  end

val register_field_indices : register -> register_field -> integer * integer
let register_field_indices register rfield =
  match register_field_indices_aux register rfield with
  | Just indices -> indices
  | Nothing -> failwith "Invalid register/register-field combination"
  end

let register_field_indices_nat reg regfield=
  let (i,j) = register_field_indices reg regfield in
  (natFromInteger i,natFromInteger j)*)

(*let rec external_reg_value reg_name v =
  let (internal_start, external_start, direction) =
    match reg_name with
     | Reg _ start size dir ->
        (start, (if dir = D_increasing then start else (start - (size +1))), dir)
     | Reg_slice _ reg_start dir (slice_start, _) ->
        ((if dir = D_increasing then slice_start else (reg_start - slice_start)),
         slice_start, dir)
     | Reg_field _ reg_start dir _ (slice_start, _) ->
        ((if dir = D_increasing then slice_start else (reg_start - slice_start)),
         slice_start, dir)
     | Reg_f_slice _ reg_start dir _ _ (slice_start, _) ->
        ((if dir = D_increasing then slice_start else (reg_start - slice_start)),
         slice_start, dir)
     end in
  let bits = bit_lifteds_of_bitv v in
  <| rv_bits           = bits;
     rv_dir            = direction;
     rv_start          = external_start;
     rv_start_internal = internal_start |>

val internal_reg_value : register_value -> list bitU
let internal_reg_value v =
  List.map bitU_of_bit_lifted v.rv_bits
         (*(integerFromNat v.rv_start_internal)
         (v.rv_dir = D_increasing)*)


let external_slice (d:direction) (start:nat) ((i,j):(nat*nat)) =
  match d with
  (*This is the case the thread/concurrecny model expects, so no change needed*)
  | D_increasing -> (i,j)
  | D_decreasing -> let slice_i = start - i in
                    let slice_j = (i - j) + slice_i in
                    (slice_i,slice_j)
  end *)

(* TODO
let external_reg_whole r =
  Reg (r.name) (natFromInteger r.start) (natFromInteger r.size) (dir_of_bool r.is_inc)

let external_reg_slice r (i,j) =
  let start = natFromInteger r.start in
  let dir = dir_of_bool r.is_inc in
  Reg_slice (r.name) start dir (external_slice dir start (i,j))

let external_reg_field_whole reg rfield =
  let (m,n) = register_field_indices_nat reg rfield in
  let start = start_of_reg_nat reg in
  let dir = dir_of_reg reg in
  Reg_field (name_of_reg reg) start dir rfield (external_slice dir start (m,n))

let external_reg_field_slice reg rfield (i,j) =
  let (m,n) = register_field_indices_nat reg rfield in
  let start = start_of_reg_nat reg in
  let dir = dir_of_reg reg in
  Reg_f_slice (name_of_reg reg) start dir rfield
              (external_slice dir start (m,n))
              (external_slice dir start (i,j))*)

(*val external_mem_value : list bitU -> memory_value
let external_mem_value v =
  byte_lifteds_of_bitv v $> List.reverse

val internal_mem_value : memory_value -> list bitU
let internal_mem_value bytes =
  List.reverse bytes $> bitv_of_byte_lifteds*)


(*val foreach : forall 'a 'vars.
  (list 'a) -> 'vars -> ('a -> 'vars -> 'vars) -> 'vars*)
 val _ = Define `
 ((foreach:'a list -> 'vars ->('a -> 'vars -> 'vars) -> 'vars) l vars body=
   ((case l of
      [] => vars
    | (x :: xs) => foreach xs (body x vars) body
  )))`;


(*val index_list : integer -> integer -> integer -> list integer*)
 val index_list_defn = Hol_defn "index_list" `
 ((index_list:int -> int -> int ->(int)list) from to step=
   (if ((step >( 0 : int)) /\ (from <= to)) \/ ((step <( 0 : int)) /\ (to <= from)) then
    from :: index_list (from + step) to step
  else []))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn index_list_defn;

(*val while : forall 'vars. 'vars -> ('vars -> bool) -> ('vars -> 'vars) -> 'vars*)
 val while_defn = Hol_defn "while" `
 ((while:'vars ->('vars -> bool) ->('vars -> 'vars) -> 'vars) vars cond body=
   (if cond vars then while (body vars) cond body else vars))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn while_defn;

(*val until : forall 'vars. 'vars -> ('vars -> bool) -> ('vars -> 'vars) -> 'vars*)
 val until_defn = Hol_defn "until" `
 ((until:'vars ->('vars -> bool) ->('vars -> 'vars) -> 'vars) vars cond body=
   (let vars = (body vars) in
  if cond vars then vars else until (body vars) cond body))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) Defn.save_defn until_defn;


(* convert numbers unsafely to naturals *)

val _ = Hol_datatype `
(*  'a *) ToNatural_class= <| toNatural_method : 'a -> num |>`;

(* eta-expanded for Isabelle output, otherwise it breaks *)
val _ = Define `
((instance_Sail2_values_ToNatural_Num_integer_dict:(int)ToNatural_class)= (<|

  toNatural_method := (\ n .  Num (ABS n))|>))`;

val _ = Define `
((instance_Sail2_values_ToNatural_Num_int_dict:(int)ToNatural_class)= (<|

  toNatural_method := (\ n .  ((Num (ABS n)):num))|>))`;

val _ = Define `
((instance_Sail2_values_ToNatural_nat_dict:(num)ToNatural_class)= (<|

  toNatural_method := (\ n .  ( n:num))|>))`;

val _ = Define `
((instance_Sail2_values_ToNatural_Num_natural_dict:(num)ToNatural_class)= (<|

  toNatural_method := (\ n .  n)|>))`;


val _ = Define `
 ((toNaturalFiveTup:'a ToNatural_class -> 'b ToNatural_class -> 'c ToNatural_class -> 'd ToNatural_class -> 'e ToNatural_class -> 'd#'c#'b#'a#'e -> num#num#num#num#num)dict_Sail2_values_ToNatural_a dict_Sail2_values_ToNatural_b dict_Sail2_values_ToNatural_c dict_Sail2_values_ToNatural_d dict_Sail2_values_ToNatural_e (n1,n2,n3,n4,n5)=
   (dict_Sail2_values_ToNatural_d.toNatural_method n1, dict_Sail2_values_ToNatural_c.toNatural_method n2, dict_Sail2_values_ToNatural_b.toNatural_method n3, dict_Sail2_values_ToNatural_a.toNatural_method n4, dict_Sail2_values_ToNatural_e.toNatural_method n5))`;


(* Let the following types be generated by Sail per spec, using either bitlists
   or machine words as bitvector representation *)
(*type regfp =
  | RFull of (string)
  | RSlice of (string * integer * integer)
  | RSliceBit of (string * integer)
  | RField of (string * string)

type niafp =
  | NIAFP_successor
  | NIAFP_concrete_address of vector bitU
  | NIAFP_indirect_address

(* only for MIPS *)
type diafp =
  | DIAFP_none
  | DIAFP_concrete of vector bitU
  | DIAFP_reg of regfp

let regfp_to_reg (reg_info : string -> maybe string -> (nat * nat * direction * (nat * nat))) = function
  | RFull name ->
     let (start,length,direction,_) = reg_info name Nothing in
     Reg name start length direction
  | RSlice (name,i,j) ->
     let i = natFromInteger i in
     let j = natFromInteger j in
     let (start,length,direction,_) = reg_info name Nothing in
     let slice = external_slice direction start (i,j) in
     Reg_slice name start direction slice
  | RSliceBit (name,i) ->
     let i = natFromInteger i in
     let (start,length,direction,_) = reg_info name Nothing in
     let slice = external_slice direction start (i,i) in
     Reg_slice name start direction slice
  | RField (name,field_name) ->
     let (start,length,direction,span) = reg_info name (Just field_name) in
     let slice = external_slice direction start span in
     Reg_field name start direction field_name slice
end

let niafp_to_nia reginfo = function
  | NIAFP_successor -> NIA_successor
  | NIAFP_concrete_address v -> NIA_concrete_address (address_of_bitv v)
  | NIAFP_indirect_address -> NIA_indirect_address
end

let diafp_to_dia reginfo = function
  | DIAFP_none -> DIA_none
  | DIAFP_concrete v -> DIA_concrete_address (address_of_bitv v)
  | DIAFP_reg r -> DIA_register (regfp_to_reg reginfo r)
end
*)
val _ = export_theory()

