(*Generated by Lem from num_extra.lem.*)
open HolKernel Parse boolLib bossLib;
open lem_numTheory lem_basic_classesTheory lem_assert_extraTheory lem_stringTheory ASCIInumbersTheory;

val _ = numLib.prefer_num();



val _ = new_theory "lem_num_extra"

(* **************************************************** *)
(*                                                      *)
(* A library of additional functions on numbers         *)
(*                                                      *)
(* **************************************************** *)

(*open import Basic_classes*)
(*open import Num*)
(*open import String*)
(*open import Assert_extra*)

(*open import {hol} `ASCIInumbersTheory`*)

(*val naturalOfString : string -> natural*)

(*val integerOfString : string -> integer*)

(*val integerOfChar : char -> integer*)

val _ = Define `
 ((integerOfChar:char -> int)= 
  (\x .  (case x of
               #"0" =>( 0 : int)
           | #"1" =>( 1 : int)
           | #"2" =>( 2 : int)
           | #"3" =>( 3 : int)
           | #"4" =>( 4 : int)
           | #"5" =>( 5 : int)
           | #"6" =>( 6 : int)
           | #"7" =>( 7 : int)
           | #"8" =>( 8 : int)
           | #"9" =>( 9 : int)
           | _ => failwith "integerOfChar: unexpected character"
         )))`;


(*val integerOfStringHelper : list char -> integer*)

 val integerOfStringHelper_defn = Defn.Hol_multi_defns `
 ((integerOfStringHelper:(char)list -> int) (d :: ds)=  (integerOfChar d + (( 10 : int) * integerOfStringHelper ds)))
/\ ((integerOfStringHelper:(char)list -> int) ([])= (( 0 : int)))`;

val _ = Lib.with_flag (computeLib.auto_import_definitions, false) (List.map Defn.save_defn) integerOfStringHelper_defn;

val _ = Define `
 ((integerOfString:string -> int) s= 
  (list_CASE s (int_of_num (toNum s))
     (\c s0. (case(c,s0) of
                 ( #"-",_) => ~ (int_of_num (toNum s0))
               | (_,_) => int_of_num (toNum s)
             ))))`;


(* Truncation integer division (round toward zero) *)
(*val integerDiv_t: integer -> integer -> integer*)

(* Truncation modulo *)
(*val integerRem_t: integer -> integer -> integer*)

(* Flooring modulo *)
(*val integerRem_f: integer -> integer -> integer*)
val _ = export_theory()

