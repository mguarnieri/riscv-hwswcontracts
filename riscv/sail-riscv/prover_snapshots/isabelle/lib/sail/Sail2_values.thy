chapter \<open>Generated by Lem from \<open>../../src/gen_lib/sail2_values.lem\<close>.\<close>

theory "Sail2_values" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "LEM.Lem_machine_word"

begin 

\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Machine_word\<close>\<close>
\<comment> \<open>\<open>open import Sail_impl_base\<close>\<close>


type_synonym ii =" int "
type_synonym nn =" nat "

\<comment> \<open>\<open>val nat_of_int : integer -> nat\<close>\<close>
definition nat_of_int  :: " int \<Rightarrow> nat "  where 
     " nat_of_int i = ( if i <( 0 :: int) then( 0 :: nat) else nat (abs ( i)))"


\<comment> \<open>\<open>val pow : integer -> integer -> integer\<close>\<close>
definition pow  :: " int \<Rightarrow> int \<Rightarrow> int "  where 
     " pow m n = ( m ^ (nat_of_int n))"


definition pow2  :: " int \<Rightarrow> int "  where 
     " pow2 n = ( pow(( 2 :: int)) n )"


\<comment> \<open>\<open>val eq : forall 'a. Eq 'a => 'a -> 'a -> bool\<close>\<close>

\<comment> \<open>\<open>val neq : forall 'a. Eq 'a => 'a -> 'a -> bool\<close>\<close>

\<comment> \<open>\<open>let add_int l r = integerAdd l r
let add_signed l r = integerAdd l r
let sub_int l r = integerMinus l r
let mult_int l r = integerMult l r
let div_int l r = integerDiv l r
let div_nat l r = natDiv l r
let power_int_nat l r = integerPow l r
let power_int_int l r = integerPow l (nat_of_int r)
let negate_int i = integerNegate i
let min_int l r = integerMin l r
let max_int l r = integerMax l r

let add_real l r = realAdd l r
let sub_real l r = realMinus l r
let mult_real l r = realMult l r
let div_real l r = realDiv l r
let negate_real r = realNegate r
let abs_real r = realAbs r
let power_real b e = realPowInteger b e\<close>\<close>

\<comment> \<open>\<open>val print_endline : string -> unit\<close>\<close>
definition print_endline  :: " string \<Rightarrow> unit "  where 
     " print_endline _ = ( ()  )"


\<comment> \<open>\<open>val print : string -> unit\<close>\<close>
definition print  :: " string \<Rightarrow> unit "  where 
     " print _ = ( ()  )"


\<comment> \<open>\<open>val prerr_endline : string -> unit\<close>\<close>
definition prerr_endline  :: " string \<Rightarrow> unit "  where 
     " prerr_endline _ = ( ()  )"


definition prerr  :: " string \<Rightarrow> unit "  where 
     " prerr x = ( prerr_endline x )"


\<comment> \<open>\<open>val print_int : string -> integer -> unit\<close>\<close>
definition print_int  :: " string \<Rightarrow> int \<Rightarrow> unit "  where 
     " print_int msg i = ( print_endline (msg @ (stringFromInteger i)))"


\<comment> \<open>\<open>val prerr_int : string -> integer -> unit\<close>\<close>
definition prerr_int  :: " string \<Rightarrow> int \<Rightarrow> unit "  where 
     " prerr_int msg i = ( prerr_endline (msg @ (stringFromInteger i)))"


\<comment> \<open>\<open>val putchar : integer -> unit\<close>\<close>
definition putchar  :: " int \<Rightarrow> unit "  where 
     " putchar _ = ( ()  )"


\<comment> \<open>\<open>val shr_int : ii -> ii -> ii\<close>\<close>
function (sequential,domintros)  shr_int  :: " int \<Rightarrow> int \<Rightarrow> int "  where 
     " shr_int x s = ( if s >( 0 :: int) then shr_int (x div( 2 :: int)) (s -( 1 :: int)) else x )" 
by pat_completeness auto


\<comment> \<open>\<open>val shl_int : integer -> integer -> integer\<close>\<close>
function (sequential,domintros)  shl_int  :: " int \<Rightarrow> int \<Rightarrow> int "  where 
     " shl_int i shift = ( if shift >( 0 :: int) then( 2 :: int) * shl_int i (shift -( 1 :: int)) else i )" 
by pat_completeness auto

definition take_list  :: " int \<Rightarrow> 'a list \<Rightarrow> 'a list "  where 
     " take_list n xs = ( List.take (nat_of_int n) xs )"

definition drop_list  :: " int \<Rightarrow> 'a list \<Rightarrow> 'a list "  where 
     " drop_list n xs = ( List.drop (nat_of_int n) xs )"


\<comment> \<open>\<open>val repeat : forall 'a. list 'a -> integer -> list 'a\<close>\<close>
fun  repeat  :: " 'a list \<Rightarrow> int \<Rightarrow> 'a list "  where 
     " repeat xs n = (
  if n \<le>( 0 :: int) then []
  else xs @ repeat xs (n-( 1 :: int)))"


definition duplicate_to_list  :: " 'a \<Rightarrow> int \<Rightarrow> 'a list "  where 
     " duplicate_to_list bit length1 = ( repeat [bit] length1 )"


fun  replace  :: " 'a list \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> 'a list "  where 
     " replace ([]) (n :: int) b' = ( [])"
|" replace (b # bs) (n :: int) b' = (
     if n =( 0 :: int) then b' # bs
              else b # replace bs (n -( 1 :: int)) b' )"


definition upper  :: " 'a \<Rightarrow> 'a "  where 
     " upper n = ( n )"


\<comment> \<open>\<open> Modulus operation corresponding to quot below -- result
   has sign of dividend. \<close>\<close>
definition hardware_mod  :: " int \<Rightarrow> int \<Rightarrow> int "  where 
     " hardware_mod (a:: int) (b::int) = (
  (let m = ((abs a) mod (abs b)) in
  if a <( 0 :: int) then - m else m))"


\<comment> \<open>\<open> There are different possible answers for integer divide regarding
rounding behaviour on negative operands. Positive operands always
round down so derive the one we want (trucation towards zero) from
that \<close>\<close>
definition hardware_quot  :: " int \<Rightarrow> int \<Rightarrow> int "  where 
     " hardware_quot (a::int) (b::int) = (
  (let q = ((abs a) div (abs b)) in
  if ((a<( 0 :: int)) \<longleftrightarrow> (b<( 0 :: int))) then
    q  \<comment> \<open>\<open> same sign -- result positive \<close>\<close>
  else
    - q))"
 \<comment> \<open>\<open> different sign -- result negative \<close>\<close>

definition max_64u  :: " int "  where 
     " max_64u = ( ((( 2 :: int))^(( 64 :: nat))) -( 1 :: int))"

definition max_64  :: " int "   where 
     " max_64  = ( ((( 2 :: int))^(( 63 :: nat))) -( 1 :: int))"

definition min_64  :: " int "   where 
     " min_64  = (( 0 :: int) - ((( 2 :: int))^(( 63 :: nat))))"

definition max_32u  :: " int "  where 
     " max_32u = ( (( 4294967295 :: int) :: int))"

definition max_32  :: " int "   where 
     " max_32  = ( (( 2147483647 :: int) :: int))"

definition min_32  :: " int "   where 
     " min_32  = ( (( 0 :: int) -( 2147483648 :: int) :: int))"

definition max_8  :: " int "    where 
     " max_8   = ( (( 127 :: int) :: int))"

definition min_8  :: " int "    where 
     " min_8   = ( (( 0 :: int) -( 128 :: int) :: int))"

definition max_5  :: " int "    where 
     " max_5   = ( (( 31 :: int) :: int))"

definition min_5  :: " int "    where 
     " min_5   = ( (( 0 :: int) -( 32 :: int) :: int))"


\<comment> \<open>\<open> just_list takes a list of maybes and returns Just xs if all elements have
   a value, and Nothing if one of the elements is Nothing. \<close>\<close>
\<comment> \<open>\<open>val just_list : forall 'a. list (maybe 'a) -> maybe (list 'a)\<close>\<close>
fun  just_list  :: "('a option)list \<Rightarrow>('a list)option "  where 
     " just_list ([]) = ( Some [])"
|" just_list (x # xs) = (
    (case  (x, just_list xs) of
        (Some x, Some xs) => Some (x # xs)
      | (_, _) => None
    ))"


\<comment> \<open>\<open>val maybe_failwith : forall 'a. maybe 'a -> 'a\<close>\<close>
definition maybe_failwith  :: " 'a option \<Rightarrow> 'a "  where 
     " maybe_failwith = ( \<lambda>x .  
  (case  x of   Some a => a | None => failwith (''maybe_failwith'') ) )"


\<comment> \<open>\<open>** Bits \<close>\<close>
datatype bitU = B0 | B1 | BU

definition showBitU  :: " bitU \<Rightarrow> string "  where 
     " showBitU = ( \<lambda>x .  
  (case  x of   B0 => (''O'') | B1 => (''I'') | BU => (''U'') ) )"


definition bitU_char  :: " bitU \<Rightarrow> char "  where 
     " bitU_char = ( \<lambda>x .  
  (case  x of   B0 => (CHR ''0'') | B1 => (CHR ''1'') | BU => (CHR ''?'') ) )"


definition instance_Show_Show_Sail2_values_bitU_dict  :: "(bitU)Show_class "  where 
     " instance_Show_Show_Sail2_values_bitU_dict = ((|

  show_method = showBitU |) )"


\<comment> \<open>\<open>val compare_bitU : bitU -> bitU -> ordering\<close>\<close>
fun compare_bitU  :: " bitU \<Rightarrow> bitU \<Rightarrow> ordering "  where 
     " compare_bitU BU BU = ( EQ )"
|" compare_bitU B0 B0 = ( EQ )"
|" compare_bitU B1 B1 = ( EQ )"
|" compare_bitU BU _ = ( LT )"
|" compare_bitU _ BU = ( GT )"
|" compare_bitU B0 _ = ( LT )"
|" compare_bitU _ _ = ( GT )"


definition instance_Basic_classes_Ord_Sail2_values_bitU_dict  :: "(bitU)Ord_class "  where 
     " instance_Basic_classes_Ord_Sail2_values_bitU_dict = ((|

  compare_method = compare_bitU,

  isLess_method = (\<lambda>  l r. (compare_bitU l r) = LT),

  isLessEqual_method = (\<lambda> l r. (compare_bitU l r) \<noteq> GT),

  isGreater_method = (\<lambda>  l r. (compare_bitU l r) = GT),

  isGreaterEqual_method = (\<lambda> l r. (compare_bitU l r) \<noteq> LT)|) )"


record 'a BitU_class=

  to_bitU_method ::" 'a \<Rightarrow> bitU " 

  of_bitU_method ::" bitU \<Rightarrow> 'a "



definition instance_Sail2_values_BitU_Sail2_values_bitU_dict  :: "(bitU)BitU_class "  where 
     " instance_Sail2_values_BitU_Sail2_values_bitU_dict = ((|

  to_bitU_method = (\<lambda> b. b),

  of_bitU_method = (\<lambda> b. b)|) )"


definition bool_of_bitU  :: " bitU \<Rightarrow>(bool)option "  where 
     " bool_of_bitU = ( \<lambda>x .  
  (case  x of   B0 => Some False | B1 => Some True | BU => None ) )"


definition bitU_of_bool  :: " bool \<Rightarrow> bitU "  where 
     " bitU_of_bool b = ( if b then B1 else B0 )"


\<comment> \<open>\<open>instance (BitU bool)
  let to_bitU = bitU_of_bool
  let of_bitU = bool_of_bitU
end\<close>\<close>

definition cast_bit_bool  :: " bitU \<Rightarrow>(bool)option "  where 
     " cast_bit_bool = ( bool_of_bitU )"


definition not_bit  :: " bitU \<Rightarrow> bitU "  where 
     " not_bit = ( \<lambda>x .  
  (case  x of   B1 => B0 | B0 => B1 | BU => BU ) )"


\<comment> \<open>\<open>val is_one : integer -> bitU\<close>\<close>
definition is_one  :: " int \<Rightarrow> bitU "  where 
     " is_one i = (
  if i =( 1 :: int) then B1 else B0 )"


\<comment> \<open>\<open>val and_bit : bitU -> bitU -> bitU\<close>\<close>
fun and_bit  :: " bitU \<Rightarrow> bitU \<Rightarrow> bitU "  where 
     " and_bit B0 _ = ( B0 )"
|" and_bit _ B0 = ( B0 )"
|" and_bit B1 B1 = ( B1 )"
|" and_bit _ _ = ( BU )"


\<comment> \<open>\<open>val or_bit : bitU -> bitU -> bitU\<close>\<close>
fun or_bit  :: " bitU \<Rightarrow> bitU \<Rightarrow> bitU "  where 
     " or_bit B1 _ = ( B1 )"
|" or_bit _ B1 = ( B1 )"
|" or_bit B0 B0 = ( B0 )"
|" or_bit _ _ = ( BU )"


\<comment> \<open>\<open>val xor_bit : bitU -> bitU -> bitU\<close>\<close>
fun xor_bit  :: " bitU \<Rightarrow> bitU \<Rightarrow> bitU "  where 
     " xor_bit B0 B0 = ( B0 )"
|" xor_bit B0 B1 = ( B1 )"
|" xor_bit B1 B0 = ( B1 )"
|" xor_bit B1 B1 = ( B0 )"
|" xor_bit _ _ = ( BU )"


\<comment> \<open>\<open>val &. : bitU -> bitU -> bitU\<close>\<close>

\<comment> \<open>\<open>val |. : bitU -> bitU -> bitU\<close>\<close>

\<comment> \<open>\<open>val +. : bitU -> bitU -> bitU\<close>\<close>


\<comment> \<open>\<open>** Bool lists **\<close>\<close>

\<comment> \<open>\<open>val bools_of_nat_aux : integer -> natural -> list bool -> list bool\<close>\<close>
fun  bools_of_nat_aux  :: " int \<Rightarrow> nat \<Rightarrow>(bool)list \<Rightarrow>(bool)list "  where 
     " bools_of_nat_aux len x acc1 = (
  if len \<le>( 0 :: int) then acc1
  else bools_of_nat_aux (len -( 1 :: int)) (x div( 2 :: nat)) ((if (x mod( 2 :: nat)) =( 1 :: nat) then True else False) # acc1))"

definition bools_of_nat  :: " int \<Rightarrow> nat \<Rightarrow>(bool)list "  where 
     " bools_of_nat len n = ( bools_of_nat_aux len n [])"
 \<comment> \<open>\<open>List.reverse (bools_of_nat_aux n)\<close>\<close>

\<comment> \<open>\<open>val nat_of_bools_aux : natural -> list bool -> natural\<close>\<close>
fun  nat_of_bools_aux  :: " nat \<Rightarrow>(bool)list \<Rightarrow> nat "  where 
     " nat_of_bools_aux acc1 ([]) = ( acc1 )"
|" nat_of_bools_aux acc1 (True # bs) = ( nat_of_bools_aux ((( 2 :: nat) * acc1) +( 1 :: nat)) bs )"
|" nat_of_bools_aux acc1 (False # bs) = ( nat_of_bools_aux (( 2 :: nat) * acc1) bs )"

definition nat_of_bools  :: "(bool)list \<Rightarrow> nat "  where 
     " nat_of_bools bs = ( nat_of_bools_aux(( 0 :: nat)) bs )"


\<comment> \<open>\<open>val unsigned_of_bools : list bool -> integer\<close>\<close>
definition unsigned_of_bools  :: "(bool)list \<Rightarrow> int "  where 
     " unsigned_of_bools bs = ( int (nat_of_bools bs))"


\<comment> \<open>\<open>val signed_of_bools : list bool -> integer\<close>\<close>
definition signed_of_bools  :: "(bool)list \<Rightarrow> int "  where 
     " signed_of_bools bs = (
  (case  bs of
      True # _  =>( 0 :: int) - (( 1 :: int) + (unsigned_of_bools (List.map (\<lambda> x. \<not> x) bs)))
    | False # _ => unsigned_of_bools bs
    | [] =>( 0 :: int) \<comment> \<open>\<open> Treat empty list as all zeros \<close>\<close>
  ))"


\<comment> \<open>\<open>val int_of_bools : bool -> list bool -> integer\<close>\<close>
definition int_of_bools  :: " bool \<Rightarrow>(bool)list \<Rightarrow> int "  where 
     " int_of_bools sign bs = ( if sign then signed_of_bools bs else unsigned_of_bools bs )"


\<comment> \<open>\<open>val pad_list : forall 'a. 'a -> list 'a -> integer -> list 'a\<close>\<close>
fun  pad_list  :: " 'a \<Rightarrow> 'a list \<Rightarrow> int \<Rightarrow> 'a list "  where 
     " pad_list x xs n = (
  if n \<le>( 0 :: int) then xs else pad_list x (x # xs) (n -( 1 :: int)))"


definition ext_list  :: " 'a \<Rightarrow> int \<Rightarrow> 'a list \<Rightarrow> 'a list "  where 
     " ext_list pad len xs = (
  (let longer = (len - (int (List.length xs))) in
  if longer <( 0 :: int) then List.drop (nat_of_int (abs (longer))) xs
  else pad_list pad xs longer))"


definition extz_bools  :: " int \<Rightarrow>(bool)list \<Rightarrow>(bool)list "  where 
     " extz_bools len bs = ( ext_list False len bs )"

definition exts_bools  :: " int \<Rightarrow>(bool)list \<Rightarrow>(bool)list "  where 
     " exts_bools len bs = (
  (case  bs of
      True # _ => ext_list True len bs
    | _ => ext_list False len bs
  ))"


fun  add_one_bool_ignore_overflow_aux  :: "(bool)list \<Rightarrow>(bool)list "  where 
     " add_one_bool_ignore_overflow_aux ([]) = ( [])"
|" add_one_bool_ignore_overflow_aux (False # bits) = ( True # bits )"
|" add_one_bool_ignore_overflow_aux (True # bits) = ( False # add_one_bool_ignore_overflow_aux bits )"


definition add_one_bool_ignore_overflow  :: "(bool)list \<Rightarrow>(bool)list "  where 
     " add_one_bool_ignore_overflow bits = (
  List.rev (add_one_bool_ignore_overflow_aux (List.rev bits)))"


\<comment> \<open>\<open>let bool_list_of_int n =
  let bs_abs = false :: bools_of_nat (naturalFromInteger (abs n)) in
  if n >= (0 : integer) then bs_abs
  else add_one_bool_ignore_overflow (List.map not bs_abs)
let bools_of_int len n = exts_bools len (bool_list_of_int n)\<close>\<close>
definition bools_of_int  :: " int \<Rightarrow> int \<Rightarrow>(bool)list "  where 
     " bools_of_int len n = (
  (let bs_abs = (bools_of_nat len (nat (abs (abs n)))) in
  if n \<ge> (( 0 :: int) :: int) then bs_abs
  else add_one_bool_ignore_overflow (List.map (\<lambda> x. \<not> x) bs_abs)))"


\<comment> \<open>\<open>** Bit lists **\<close>\<close>

\<comment> \<open>\<open>val has_undefined_bits : list bitU -> bool\<close>\<close>
definition has_undefined_bits  :: "(bitU)list \<Rightarrow> bool "  where 
     " has_undefined_bits bs = ( ((\<exists> x \<in> (set bs).  (\<lambda>x .  
  (case  x of BU => True | _ => False )) x)))"


definition bits_of_nat  :: " int \<Rightarrow> nat \<Rightarrow>(bitU)list "  where 
     " bits_of_nat len n = ( List.map bitU_of_bool (bools_of_nat len n))"


definition nat_of_bits  :: "(bitU)list \<Rightarrow>(nat)option "  where 
     " nat_of_bits bits = (
  (case  (just_list (List.map bool_of_bitU bits)) of
      Some bs => Some (nat_of_bools bs)
    | None => None
  ))"


definition not_bits  :: "(bitU)list \<Rightarrow>(bitU)list "  where 
     " not_bits = ( List.map not_bit )"


\<comment> \<open>\<open>val binop_list : forall 'a. ('a -> 'a -> 'a) -> list 'a -> list 'a -> list 'a\<close>\<close>
definition binop_list  :: "('a \<Rightarrow> 'a \<Rightarrow> 'a)\<Rightarrow> 'a list \<Rightarrow> 'a list \<Rightarrow> 'a list "  where 
     " binop_list op1 xs ys = (
  List.foldr ( \<lambda>x .  
  (case  x of (x, y) => \<lambda> acc1 .  op1 x y # acc1 )) (List.zip xs ys) [])"


definition unsigned_of_bits  :: "(bitU)list \<Rightarrow>(int)option "  where 
     " unsigned_of_bits bits = (
  (case  (just_list (List.map bool_of_bitU bits)) of
      Some bs => Some (unsigned_of_bools bs)
    | None => None
  ))"


definition signed_of_bits  :: "(bitU)list \<Rightarrow>(int)option "  where 
     " signed_of_bits bits = (
  (case  (just_list (List.map bool_of_bitU bits)) of
      Some bs => Some (signed_of_bools bs)
    | None => None
  ))"


\<comment> \<open>\<open>val int_of_bits : bool -> list bitU -> maybe integer\<close>\<close>
definition int_of_bits  :: " bool \<Rightarrow>(bitU)list \<Rightarrow>(int)option "  where 
     " int_of_bits sign bs = ( if sign then signed_of_bits bs else unsigned_of_bits bs )"


definition extz_bits  :: " int \<Rightarrow>(bitU)list \<Rightarrow>(bitU)list "  where 
     " extz_bits len bits = ( ext_list B0 len bits )"

definition exts_bits  :: " int \<Rightarrow>(bitU)list \<Rightarrow>(bitU)list "  where 
     " exts_bits len bits = (
  (case  bits of
    BU # _ => ext_list BU len bits
  | B1 # _ => ext_list B1 len bits
  | _ => ext_list B0 len bits
  ))"


fun  add_one_bit_ignore_overflow_aux  :: "(bitU)list \<Rightarrow>(bitU)list "  where 
     " add_one_bit_ignore_overflow_aux ([]) = ( [])"
|" add_one_bit_ignore_overflow_aux (B0 # bits) = ( B1 # bits )"
|" add_one_bit_ignore_overflow_aux (B1 # bits) = ( B0 # add_one_bit_ignore_overflow_aux bits )"
|" add_one_bit_ignore_overflow_aux (BU # bits) = ( BU # List.map ( \<lambda>x .  
  (case  x of _ => BU )) bits )"


definition add_one_bit_ignore_overflow  :: "(bitU)list \<Rightarrow>(bitU)list "  where 
     " add_one_bit_ignore_overflow bits = (
  List.rev (add_one_bit_ignore_overflow_aux (List.rev bits)))"


\<comment> \<open>\<open>let bit_list_of_int n = List.map bitU_of_bool (bool_list_of_int n)
let bits_of_int len n = exts_bits len (bit_list_of_int n)\<close>\<close>
definition bits_of_int  :: " int \<Rightarrow> int \<Rightarrow>(bitU)list "  where 
     " bits_of_int len n = ( List.map bitU_of_bool (bools_of_int len n))"


\<comment> \<open>\<open>val arith_op_bits :
  (integer -> integer -> integer) -> bool -> list bitU -> list bitU -> list bitU\<close>\<close>
definition arith_op_bits  :: "(int \<Rightarrow> int \<Rightarrow> int)\<Rightarrow> bool \<Rightarrow>(bitU)list \<Rightarrow>(bitU)list \<Rightarrow>(bitU)list "  where 
     " arith_op_bits op1 sign l r = (
  (case  (int_of_bits sign l, int_of_bits sign r) of
      (Some li, Some ri) => bits_of_int (int (List.length l)) (op1 li ri)
    | (_, _) => repeat [BU] (int (List.length l))
  ))"


definition char_of_nibble  :: " bitU*bitU*bitU*bitU \<Rightarrow>(char)option "  where 
     " char_of_nibble = ( \<lambda>x .  
  (case  x of
        (B0, B0, B0, B0) => Some (CHR ''0'')
    | (B0, B0, B0, B1) => Some (CHR ''1'')
    | (B0, B0, B1, B0) => Some (CHR ''2'')
    | (B0, B0, B1, B1) => Some (CHR ''3'')
    | (B0, B1, B0, B0) => Some (CHR ''4'')
    | (B0, B1, B0, B1) => Some (CHR ''5'')
    | (B0, B1, B1, B0) => Some (CHR ''6'')
    | (B0, B1, B1, B1) => Some (CHR ''7'')
    | (B1, B0, B0, B0) => Some (CHR ''8'')
    | (B1, B0, B0, B1) => Some (CHR ''9'')
    | (B1, B0, B1, B0) => Some (CHR ''A'')
    | (B1, B0, B1, B1) => Some (CHR ''B'')
    | (B1, B1, B0, B0) => Some (CHR ''C'')
    | (B1, B1, B0, B1) => Some (CHR ''D'')
    | (B1, B1, B1, B0) => Some (CHR ''E'')
    | (B1, B1, B1, B1) => Some (CHR ''F'')
    | _ => None
  ) )"


fun  hexstring_of_bits  :: "(bitU)list \<Rightarrow>((char)list)option "  where 
     " hexstring_of_bits (b1 # b2 # b3 # b4 # bs) = (
     (let n = (char_of_nibble (b1, b2, b3, b4)) in
     (let s = (hexstring_of_bits bs) in
     (case  (n, s) of
       (Some n, Some s) => Some (n # s)
     | _ => None
     ))))"
|" hexstring_of_bits ([]) = ( Some [])"
|" hexstring_of_bits _ = ( None )"


definition show_bitlist  :: "(bitU)list \<Rightarrow> string "  where 
     " show_bitlist bs = (
  (case  hexstring_of_bits bs of
    Some s => ((CHR ''0'') # ((CHR ''x'') # s))
  | None => ((CHR ''0'') # ((CHR ''b'') # List.map bitU_char bs))
  ))"


\<comment> \<open>\<open>val subrange_list_inc : forall 'a. list 'a -> integer -> integer -> list 'a\<close>\<close>
definition subrange_list_inc  :: " 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list "  where 
     " subrange_list_inc xs i j = (
  (let (toJ,suffix0) = (split_at (nat_of_int (j +( 1 :: int))) xs) in
  (let (prefix0,fromItoJ) = (split_at (nat_of_int i) toJ) in
  fromItoJ)))"


\<comment> \<open>\<open>val subrange_list_dec : forall 'a. list 'a -> integer -> integer -> list 'a\<close>\<close>
definition subrange_list_dec  :: " 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list "  where 
     " subrange_list_dec xs i j = (
  (let top1 = ((int (List.length xs)) -( 1 :: int)) in
  subrange_list_inc xs (top1 - i) (top1 - j)))"


\<comment> \<open>\<open>val subrange_list : forall 'a. bool -> list 'a -> integer -> integer -> list 'a\<close>\<close>
definition subrange_list  :: " bool \<Rightarrow> 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list "  where 
     " subrange_list is_inc xs i j = ( if is_inc then subrange_list_inc xs i j else subrange_list_dec xs i j )"


\<comment> \<open>\<open>val update_subrange_list_inc : forall 'a. list 'a -> integer -> integer -> list 'a -> list 'a\<close>\<close>
definition update_subrange_list_inc  :: " 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list \<Rightarrow> 'a list "  where 
     " update_subrange_list_inc xs i j xs' = (
  (let (toJ,suffix) = (split_at (nat_of_int (j +( 1 :: int))) xs) in
  (let (prefix,fromItoJ0) = (split_at (nat_of_int i) toJ) in
  (prefix @ xs') @ suffix)))"


\<comment> \<open>\<open>val update_subrange_list_dec : forall 'a. list 'a -> integer -> integer -> list 'a -> list 'a\<close>\<close>
definition update_subrange_list_dec  :: " 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list \<Rightarrow> 'a list "  where 
     " update_subrange_list_dec xs i j xs' = (
  (let top1 = ((int (List.length xs)) -( 1 :: int)) in
  update_subrange_list_inc xs (top1 - i) (top1 - j) xs'))"


\<comment> \<open>\<open>val update_subrange_list : forall 'a. bool -> list 'a -> integer -> integer -> list 'a -> list 'a\<close>\<close>
definition update_subrange_list  :: " bool \<Rightarrow> 'a list \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a list \<Rightarrow> 'a list "  where 
     " update_subrange_list is_inc xs i j xs' = (
  if is_inc then update_subrange_list_inc xs i j xs' else update_subrange_list_dec xs i j xs' )"


\<comment> \<open>\<open>val access_list_inc : forall 'a. list 'a -> integer -> 'a\<close>\<close>
definition access_list_inc  :: " 'a list \<Rightarrow> int \<Rightarrow> 'a "  where 
     " access_list_inc xs n = ( List.nth xs (nat_of_int n))"


\<comment> \<open>\<open>val access_list_dec : forall 'a. list 'a -> integer -> 'a\<close>\<close>
definition access_list_dec  :: " 'a list \<Rightarrow> int \<Rightarrow> 'a "  where 
     " access_list_dec xs n = (
  (let top1 = ((int (List.length xs)) -( 1 :: int)) in
  access_list_inc xs (top1 - n)))"


\<comment> \<open>\<open>val access_list : forall 'a. bool -> list 'a -> integer -> 'a\<close>\<close>
definition access_list  :: " bool \<Rightarrow> 'a list \<Rightarrow> int \<Rightarrow> 'a "  where 
     " access_list is_inc xs n = (
  if is_inc then access_list_inc xs n else access_list_dec xs n )"


\<comment> \<open>\<open>val update_list_inc : forall 'a. list 'a -> integer -> 'a -> list 'a\<close>\<close>
definition update_list_inc  :: " 'a list \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> 'a list "  where 
     " update_list_inc xs n x = ( List.list_update xs (nat_of_int n) x )"


\<comment> \<open>\<open>val update_list_dec : forall 'a. list 'a -> integer -> 'a -> list 'a\<close>\<close>
definition update_list_dec  :: " 'a list \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> 'a list "  where 
     " update_list_dec xs n x = (
  (let top1 = ((int (List.length xs)) -( 1 :: int)) in
  update_list_inc xs (top1 - n) x))"


\<comment> \<open>\<open>val update_list : forall 'a. bool -> list 'a -> integer -> 'a -> list 'a\<close>\<close>
definition update_list  :: " bool \<Rightarrow> 'a list \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow> 'a list "  where 
     " update_list is_inc xs n x = (
  if is_inc then update_list_inc xs n x else update_list_dec xs n x )"


definition extract_only_bit  :: "(bitU)list \<Rightarrow> bitU "  where 
     " extract_only_bit = ( \<lambda>x .  
  (case  x of   [] => BU | [e] => e | _ => BU ) )"


\<comment> \<open>\<open>** Machine words \<close>\<close>

\<comment> \<open>\<open>val length_mword : forall 'a. mword 'a -> integer\<close>\<close>

\<comment> \<open>\<open>val slice_mword_dec : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b\<close>\<close>
definition slice_mword_dec  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word "  where 
     " slice_mword_dec w i j = ( Word.slice (nat_of_int i) w )"


\<comment> \<open>\<open>val slice_mword_inc : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b\<close>\<close>
definition slice_mword_inc  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word "  where 
     " slice_mword_inc w i j = (
  (let top1 = ((int (size w)) -( 1 :: int)) in
  slice_mword_dec w (top1 - i) (top1 - j)))"


\<comment> \<open>\<open>val slice_mword : forall 'a 'b. bool -> mword 'a -> integer -> integer -> mword 'b\<close>\<close>
definition slice_mword  :: " bool \<Rightarrow>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word "  where 
     " slice_mword is_inc w i j = ( if is_inc then slice_mword_inc w i j else slice_mword_dec w i j )"


\<comment> \<open>\<open>val update_slice_mword_dec : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b -> mword 'a\<close>\<close>
definition update_slice_mword_dec  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<Rightarrow>('a::len)Word.word "  where 
     " update_slice_mword_dec w i j w' = ( Lem.word_update w (nat_of_int i) (nat_of_int j) w' )"


\<comment> \<open>\<open>val update_slice_mword_inc : forall 'a 'b. mword 'a -> integer -> integer -> mword 'b -> mword 'a\<close>\<close>
definition update_slice_mword_inc  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<Rightarrow>('a::len)Word.word "  where 
     " update_slice_mword_inc w i j w' = (
  (let top1 = ((int (size w)) -( 1 :: int)) in
  update_slice_mword_dec w (top1 - i) (top1 - j) w'))"


\<comment> \<open>\<open>val update_slice_mword : forall 'a 'b. bool -> mword 'a -> integer -> integer -> mword 'b -> mword 'a\<close>\<close>
definition update_slice_mword  :: " bool \<Rightarrow>('a::len)Word.word \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('b::len)Word.word \<Rightarrow>('a::len)Word.word "  where 
     " update_slice_mword is_inc w i j w' = (
  if is_inc then update_slice_mword_inc w i j w' else update_slice_mword_dec w i j w' )"


\<comment> \<open>\<open>val access_mword_dec : forall 'a. mword 'a -> integer -> bitU\<close>\<close>
definition access_mword_dec  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU "  where 
     " access_mword_dec w n = ( bitU_of_bool (Bits.test_bit w (nat_of_int n)))"


\<comment> \<open>\<open>val access_mword_inc : forall 'a. mword 'a -> integer -> bitU\<close>\<close>
definition access_mword_inc  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU "  where 
     " access_mword_inc w n = (
  (let top1 = ((int (size w)) -( 1 :: int)) in
  access_mword_dec w (top1 - n)))"


\<comment> \<open>\<open>val access_mword : forall 'a. bool -> mword 'a -> integer -> bitU\<close>\<close>
definition access_mword  :: " bool \<Rightarrow>('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU "  where 
     " access_mword is_inc w n = (
  if is_inc then access_mword_inc w n else access_mword_dec w n )"


\<comment> \<open>\<open>val update_mword_bool_dec : forall 'a. mword 'a -> integer -> bool -> mword 'a\<close>\<close>
definition update_mword_bool_dec  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('a::len)Word.word "  where 
     " update_mword_bool_dec w n b = ( Bits.set_bit w (nat_of_int n) b )"

definition update_mword_dec  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>(('a::len)Word.word)option "  where 
     " update_mword_dec w n b = ( map_option (update_mword_bool_dec w n) (bool_of_bitU b))"


\<comment> \<open>\<open>val update_mword_bool_inc : forall 'a. mword 'a -> integer -> bool -> mword 'a\<close>\<close>
definition update_mword_bool_inc  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>('a::len)Word.word "  where 
     " update_mword_bool_inc w n b = (
  (let top1 = ((int (size w)) -( 1 :: int)) in
  update_mword_bool_dec w (top1 - n) b))"

definition update_mword_inc  :: "('a::len)Word.word \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>(('a::len)Word.word)option "  where 
     " update_mword_inc w n b = ( map_option (update_mword_bool_inc w n) (bool_of_bitU b))"


\<comment> \<open>\<open>val int_of_mword : forall 'a. bool -> mword 'a -> integer\<close>\<close>
definition int_of_mword  :: " bool \<Rightarrow>('a::len)Word.word \<Rightarrow> int "  where 
     " int_of_mword sign w = (
  if sign then Word.sint w else Word.uint w )"


\<comment> \<open>\<open> Translating between a type level number (itself 'n) and an integer \<close>\<close>

definition size_itself_int  :: "('a::len)itself \<Rightarrow> int "  where 
     " size_itself_int x = ( int (size_itself x))"


\<comment> \<open>\<open> NB: the corresponding sail type is forall 'n. atom('n) -> itself('n),
   the actual integer is ignored. \<close>\<close>

\<comment> \<open>\<open>val make_the_value : forall 'n. integer -> itself 'n\<close>\<close>
definition make_the_value  :: " int \<Rightarrow>('n::len)itself "  where 
     " make_the_value _ = ( TYPE(_) )"


\<comment> \<open>\<open>** Bitvectors \<close>\<close>

record 'a Bitvector_class=

  bits_of_method ::" 'a \<Rightarrow> bitU list " 

  \<comment> \<open>\<open> We allow of_bits to be partial, as not all bitvector representations
     support undefined bits \<close>\<close>
  of_bits_method ::" bitU list \<Rightarrow>  'a option " 

  of_bools_method ::" bool list \<Rightarrow> 'a " 

  length_method ::" 'a \<Rightarrow> int " 

  \<comment> \<open>\<open> of_int: the first parameter specifies the desired length of the bitvector \<close>\<close>
  of_int_method ::" int \<Rightarrow> int \<Rightarrow> 'a " 

  \<comment> \<open>\<open> Conversion to integers is undefined if any bit is undefined \<close>\<close>
  unsigned_method ::" 'a \<Rightarrow>  int option " 

  signed_method ::" 'a \<Rightarrow>  int option " 

  \<comment> \<open>\<open> Lifting of integer operations to bitvectors:  The boolean flag indicates
     whether to treat the bitvectors as signed (true) or not (false). \<close>\<close>
  arith_op_bv_method ::" (int \<Rightarrow> int \<Rightarrow> int) \<Rightarrow> bool \<Rightarrow> 'a \<Rightarrow> 'a \<Rightarrow> 'a "



\<comment> \<open>\<open>val of_bits_failwith : forall 'a. Bitvector 'a => list bitU -> 'a\<close>\<close>
definition of_bits_failwith  :: " 'a Bitvector_class \<Rightarrow>(bitU)list \<Rightarrow> 'a "  where 
     " of_bits_failwith dict_Sail2_values_Bitvector_a bits = ( maybe_failwith (
  (of_bits_method   dict_Sail2_values_Bitvector_a) bits))"


definition int_of_bv  :: " 'a Bitvector_class \<Rightarrow> bool \<Rightarrow> 'a \<Rightarrow>(int)option "  where 
     " int_of_bv dict_Sail2_values_Bitvector_a sign = ( if sign then 
  (signed_method   dict_Sail2_values_Bitvector_a) else (unsigned_method   dict_Sail2_values_Bitvector_a) )"


definition instance_Sail2_values_Bitvector_list_dict  :: " 'a BitU_class \<Rightarrow>('a list)Bitvector_class "  where 
     " instance_Sail2_values_Bitvector_list_dict dict_Sail2_values_BitU_a = ((|

  bits_of_method = (\<lambda> v. List.map 
  (to_bitU_method   dict_Sail2_values_BitU_a) v),

  of_bits_method = (\<lambda> v. Some (List.map 
  (of_bitU_method   dict_Sail2_values_BitU_a) v)),

  of_bools_method = (\<lambda> v. List.map 
  (of_bitU_method   dict_Sail2_values_BitU_a) (List.map bitU_of_bool v)),

  length_method = (\<lambda> xs. int (List.length xs)),

  of_int_method = (\<lambda> len n. List.map 
  (of_bitU_method   dict_Sail2_values_BitU_a) (bits_of_int len n)),

  unsigned_method = (\<lambda> v. unsigned_of_bits (List.map 
  (to_bitU_method   dict_Sail2_values_BitU_a) v)),

  signed_method = (\<lambda> v. signed_of_bits (List.map 
  (to_bitU_method   dict_Sail2_values_BitU_a) v)),

  arith_op_bv_method = (\<lambda> op1 sign l r. List.map 
  (of_bitU_method   dict_Sail2_values_BitU_a) (arith_op_bits op1 sign (List.map 
  (to_bitU_method   dict_Sail2_values_BitU_a) l) (List.map (to_bitU_method   dict_Sail2_values_BitU_a) r)))|) )"


definition instance_Sail2_values_Bitvector_Machine_word_mword_dict  :: "(('a::len)Word.word)Bitvector_class "  where 
     " instance_Sail2_values_Bitvector_Machine_word_mword_dict = ((|

  bits_of_method = (\<lambda> v. List.map bitU_of_bool (Word.to_bl v)),

  of_bits_method = (\<lambda> v. map_option Word.of_bl (just_list (List.map bool_of_bitU v))),

  of_bools_method = (\<lambda> v. Word.of_bl v),

  length_method = (\<lambda> v. int (size v)),

  of_int_method = ( \<lambda>x .  
  (case  x of _ => \<lambda> n .  Word.word_of_int n )),

  unsigned_method = (\<lambda> v. Some (Word.uint v)),

  signed_method = (\<lambda> v. Some (Word.sint v)),

  arith_op_bv_method = (\<lambda> op1 sign l r. Word.word_of_int (op1 (int_of_mword sign l) (int_of_mword sign r)))|) )"


definition access_bv_inc  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> bitU "  where 
     " access_bv_inc dict_Sail2_values_Bitvector_a v n = ( access_list True  (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) n )"

definition access_bv_dec  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> bitU "  where 
     " access_bv_dec dict_Sail2_values_Bitvector_a v n = ( access_list False (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) n )"


definition update_bv_inc  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>(bitU)list "  where 
     " update_bv_inc dict_Sail2_values_Bitvector_a v n b = ( update_list True  (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) n b )"

definition update_bv_dec  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> bitU \<Rightarrow>(bitU)list "  where 
     " update_bv_dec dict_Sail2_values_Bitvector_a v n b = ( update_list False (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) n b )"


definition subrange_bv_inc  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(bitU)list "  where 
     " subrange_bv_inc dict_Sail2_values_Bitvector_a v i j = ( subrange_list True  (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) i j )"

definition subrange_bv_dec  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(bitU)list "  where 
     " subrange_bv_dec dict_Sail2_values_Bitvector_a v i j = ( subrange_list False (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v) i j )"


definition update_subrange_bv_inc  :: " 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> 'b \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow>(bitU)list "  where 
     " update_subrange_bv_inc dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b v i j v' = ( update_subrange_list True  (
  (bits_of_method   dict_Sail2_values_Bitvector_b) v) i j ((bits_of_method   dict_Sail2_values_Bitvector_a) v'))"

definition update_subrange_bv_dec  :: " 'a Bitvector_class \<Rightarrow> 'b Bitvector_class \<Rightarrow> 'b \<Rightarrow> int \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow>(bitU)list "  where 
     " update_subrange_bv_dec dict_Sail2_values_Bitvector_a dict_Sail2_values_Bitvector_b v i j v' = ( update_subrange_list False (
  (bits_of_method   dict_Sail2_values_Bitvector_b) v) i j ((bits_of_method   dict_Sail2_values_Bitvector_a) v'))"


\<comment> \<open>\<open>val extz_bv : forall 'a. Bitvector 'a => integer -> 'a -> list bitU\<close>\<close>
definition extz_bv  :: " 'a Bitvector_class \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow>(bitU)list "  where 
     " extz_bv dict_Sail2_values_Bitvector_a n v = ( extz_bits n (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v))"


\<comment> \<open>\<open>val exts_bv : forall 'a. Bitvector 'a => integer -> 'a -> list bitU\<close>\<close>
definition exts_bv  :: " 'a Bitvector_class \<Rightarrow> int \<Rightarrow> 'a \<Rightarrow>(bitU)list "  where 
     " exts_bv dict_Sail2_values_Bitvector_a n v = ( exts_bits n (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v))"


\<comment> \<open>\<open>val nat_of_bv : forall 'a. Bitvector 'a => 'a -> maybe nat\<close>\<close>
definition nat_of_bv  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow>(nat)option "  where 
     " nat_of_bv dict_Sail2_values_Bitvector_a v = ( map_option nat_of_int (
  (unsigned_method   dict_Sail2_values_Bitvector_a) v))"


\<comment> \<open>\<open>val string_of_bv : forall 'a. Bitvector 'a => 'a -> string\<close>\<close>
definition string_of_bv  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> string "  where 
     " string_of_bv dict_Sail2_values_Bitvector_a v = ( show_bitlist (
  (bits_of_method   dict_Sail2_values_Bitvector_a) v))"


\<comment> \<open>\<open>val print_bits : forall 'a. Bitvector 'a => string -> 'a -> unit\<close>\<close>
definition print_bits  :: " 'a Bitvector_class \<Rightarrow> string \<Rightarrow> 'a \<Rightarrow> unit "  where 
     " print_bits dict_Sail2_values_Bitvector_a str v = ( print_endline (str @ string_of_bv 
  dict_Sail2_values_Bitvector_a v))"


\<comment> \<open>\<open>val dec_str : integer -> string\<close>\<close>
definition dec_str  :: " int \<Rightarrow> string "  where 
     " dec_str bv = ( Lem_string_extra.stringFromInteger bv )"


\<comment> \<open>\<open>val concat_str : string -> string -> string\<close>\<close>
definition concat_str  :: " string \<Rightarrow> string \<Rightarrow> string "  where 
     " concat_str str1 str2 = ( str1 @ str2 )"


\<comment> \<open>\<open>val int_of_bit : bitU -> integer\<close>\<close>
fun int_of_bit  :: " bitU \<Rightarrow> int "  where 
     " int_of_bit B0 = (( 0 :: int))"
|" int_of_bit B1 = (( 1 :: int))"
|" int_of_bit _ = ( failwith (''int_of_bit saw unknown''))"


\<comment> \<open>\<open>val decimal_string_of_bv : forall 'a. Bitvector 'a => 'a -> string\<close>\<close>
definition decimal_string_of_bv  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow> string "  where 
     " decimal_string_of_bv dict_Sail2_values_Bitvector_a bv = (
  (let place_values =
    (Lem_list.mapi
      (\<lambda> i b .  (int_of_bit b) * (( 2 :: int) ^ i))
      (List.rev ((bits_of_method   dict_Sail2_values_Bitvector_a) bv)))
  in
  (let sum1 = (List.foldl (+)(( 0 :: int)) place_values) in
  Lem_string_extra.stringFromInteger sum1)))"


\<comment> \<open>\<open>** Bytes and addresses \<close>\<close>

type_synonym memory_byte =" bitU list "

\<comment> \<open>\<open>val byte_chunks : forall 'a. list 'a -> maybe (list (list 'a))\<close>\<close>
fun  byte_chunks  :: " 'a list \<Rightarrow>(('a list)list)option "  where 
     " byte_chunks ([]) = ( Some [])"
|" byte_chunks (a # b # c # d # e # f # g # h # rest) = (
     Option.bind (byte_chunks rest) (\<lambda> rest .  Some ([a,b,c,d,e,f,g,h] # rest)))"
|" byte_chunks _ = ( None )"


\<comment> \<open>\<open>val bytes_of_bits : forall 'a. Bitvector 'a => 'a -> maybe (list memory_byte)\<close>\<close>
definition bytes_of_bits  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow>(((bitU)list)list)option "  where 
     " bytes_of_bits dict_Sail2_values_Bitvector_a bs = ( byte_chunks (
  (bits_of_method   dict_Sail2_values_Bitvector_a) bs))"


\<comment> \<open>\<open>val bits_of_bytes : list memory_byte -> list bitU\<close>\<close>
definition bits_of_bytes  :: "((bitU)list)list \<Rightarrow>(bitU)list "  where 
     " bits_of_bytes bs = ( List.concat (List.map (\<lambda> v. List.map (\<lambda> b. b) v) bs))"


definition mem_bytes_of_bits  :: " 'a Bitvector_class \<Rightarrow> 'a \<Rightarrow>(((bitU)list)list)option "  where 
     " mem_bytes_of_bits dict_Sail2_values_Bitvector_a bs = ( map_option List.rev (bytes_of_bits 
  dict_Sail2_values_Bitvector_a bs))"

definition bits_of_mem_bytes  :: "((bitU)list)list \<Rightarrow>(bitU)list "  where 
     " bits_of_mem_bytes bs = ( bits_of_bytes (List.rev bs))"


\<comment> \<open>\<open>val bitv_of_byte_lifteds : list Sail_impl_base.byte_lifted -> list bitU
let bitv_of_byte_lifteds v =
  foldl (fun x (Byte_lifted y) -> x ++ (List.map bitU_of_bit_lifted y)) [] v

val bitv_of_bytes : list Sail_impl_base.byte -> list bitU
let bitv_of_bytes v =
  foldl (fun x (Byte y) -> x ++ (List.map bitU_of_bit y)) [] v

val byte_lifteds_of_bitv : list bitU -> list byte_lifted
let byte_lifteds_of_bitv bits =
  let bits = List.map bit_lifted_of_bitU bits in
  byte_lifteds_of_bit_lifteds bits

val bytes_of_bitv : list bitU -> list byte
let bytes_of_bitv bits =
  let bits = List.map bit_of_bitU bits in
  bytes_of_bits bits

val bit_lifteds_of_bitUs : list bitU -> list bit_lifted
let bit_lifteds_of_bitUs bits = List.map bit_lifted_of_bitU bits

val bit_lifteds_of_bitv : list bitU -> list bit_lifted
let bit_lifteds_of_bitv v = bit_lifteds_of_bitUs v


val address_lifted_of_bitv : list bitU -> address_lifted
let address_lifted_of_bitv v =
  let byte_lifteds = byte_lifteds_of_bitv v in
  let maybe_address_integer =
    match (maybe_all (List.map byte_of_byte_lifted byte_lifteds)) with
    | Just bs -> Just (integer_of_byte_list bs)
    | _ -> Nothing
    end in
  Address_lifted byte_lifteds maybe_address_integer

val bitv_of_address_lifted : address_lifted -> list bitU
let bitv_of_address_lifted (Address_lifted bs _) = bitv_of_byte_lifteds bs

val address_of_bitv : list bitU -> address
let address_of_bitv v =
  let bytes = bytes_of_bitv v in
  address_of_byte_list bytes\<close>\<close>

function (sequential,domintros)  reverse_endianness_list  :: " 'a list \<Rightarrow> 'a list "  where 
     " reverse_endianness_list bits = (
  if List.length bits \<le>( 8 :: nat) then bits else
    reverse_endianness_list (drop_list(( 8 :: int)) bits) @ take_list(( 8 :: int)) bits )" 
by pat_completeness auto



\<comment> \<open>\<open>** Registers \<close>\<close>

\<comment> \<open>\<open>type register_field = string
type register_field_index = string * (integer * integer) \<open> name, start and end \<close>

type register =
  | Register of string * \<open> name \<close>
                integer * \<open> length \<close>
                integer * \<open> start index \<close>
                bool * \<open> is increasing \<close>
                  list register_field_index
  | UndefinedRegister of integer \<open> length \<close>
  | RegisterPair of register * register\<close>\<close>

record( 'regstate, 'regval, 'a) register_ref =
  
 name ::" string " 

     \<comment> \<open>\<open>is_inc : bool;\<close>\<close>
     read_from ::" 'regstate \<Rightarrow> 'a " 

     write_to ::" 'a \<Rightarrow> 'regstate \<Rightarrow> 'regstate " 

     of_regval ::" 'regval \<Rightarrow>  'a option " 

     regval_of ::" 'a \<Rightarrow> 'regval " 


\<comment> \<open>\<open> Register accessors: pair of functions for reading and writing register values \<close>\<close>
type_synonym( 'regstate, 'regval) register_accessors ="
  ((string \<Rightarrow> 'regstate \<Rightarrow>  'regval option) *
   (string \<Rightarrow> 'regval \<Rightarrow> 'regstate \<Rightarrow>  'regstate option))"

record( 'regtype, 'a) field_ref =
  
 field_name ::" string " 

     field_start ::" int " 

     field_is_inc ::" bool " 

     get_field ::" 'regtype \<Rightarrow> 'a " 

     set_field ::" 'regtype \<Rightarrow> 'a \<Rightarrow> 'regtype " 


\<comment> \<open>\<open>let name_of_reg = function
  | Register name _ _ _ _ -> name
  | UndefinedRegister _ -> failwith "name_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "name_of_reg RegisterPair"
end

let size_of_reg = function
  | Register _ size _ _ _ -> size
  | UndefinedRegister size -> size
  | RegisterPair _ _ -> failwith "size_of_reg RegisterPair"
end

let start_of_reg = function
  | Register _ _ start _ _ -> start
  | UndefinedRegister _ -> failwith "start_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "start_of_reg RegisterPair"
end

let is_inc_of_reg = function
  | Register _ _ _ is_inc _ -> is_inc
  | UndefinedRegister _ -> failwith "is_inc_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "in_inc_of_reg RegisterPair"
end

let dir_of_reg = function
  | Register _ _ _ is_inc _ -> dir_of_bool is_inc
  | UndefinedRegister _ -> failwith "dir_of_reg UndefinedRegister"
  | RegisterPair _ _ -> failwith "dir_of_reg RegisterPair"
end

let size_of_reg_nat reg = natFromInteger (size_of_reg reg)
let start_of_reg_nat reg = natFromInteger (start_of_reg reg)

val register_field_indices_aux : register -> register_field -> maybe (integer * integer)
let rec register_field_indices_aux register rfield =
  match register with
  | Register _ _ _ _ rfields -> List.lookup rfield rfields
  | RegisterPair r1 r2 ->
      let m_indices = register_field_indices_aux r1 rfield in
      if isJust m_indices then m_indices else register_field_indices_aux r2 rfield
  | UndefinedRegister _ -> Nothing
  end

val register_field_indices : register -> register_field -> integer * integer
let register_field_indices register rfield =
  match register_field_indices_aux register rfield with
  | Just indices -> indices
  | Nothing -> failwith "Invalid register/register-field combination"
  end

let register_field_indices_nat reg regfield=
  let (i,j) = register_field_indices reg regfield in
  (natFromInteger i,natFromInteger j)\<close>\<close>

\<comment> \<open>\<open>let rec external_reg_value reg_name v =
  let (internal_start, external_start, direction) =
    match reg_name with
     | Reg _ start size dir ->
        (start, (if dir = D_increasing then start else (start - (size +1))), dir)
     | Reg_slice _ reg_start dir (slice_start, _) ->
        ((if dir = D_increasing then slice_start else (reg_start - slice_start)),
         slice_start, dir)
     | Reg_field _ reg_start dir _ (slice_start, _) ->
        ((if dir = D_increasing then slice_start else (reg_start - slice_start)),
         slice_start, dir)
     | Reg_f_slice _ reg_start dir _ _ (slice_start, _) ->
        ((if dir = D_increasing then slice_start else (reg_start - slice_start)),
         slice_start, dir)
     end in
  let bits = bit_lifteds_of_bitv v in
  <| rv_bits           = bits;
     rv_dir            = direction;
     rv_start          = external_start;
     rv_start_internal = internal_start |>

val internal_reg_value : register_value -> list bitU
let internal_reg_value v =
  List.map bitU_of_bit_lifted v.rv_bits
         \<open>(integerFromNat v.rv_start_internal)
         (v.rv_dir = D_increasing)\<close>


let external_slice (d:direction) (start:nat) ((i,j):(nat*nat)) =
  match d with
  \<open>This is the case the thread/concurrecny model expects, so no change needed\<close>
  | D_increasing -> (i,j)
  | D_decreasing -> let slice_i = start - i in
                    let slice_j = (i - j) + slice_i in
                    (slice_i,slice_j)
  end \<close>\<close>

\<comment> \<open>\<open> TODO
let external_reg_whole r =
  Reg (r.name) (natFromInteger r.start) (natFromInteger r.size) (dir_of_bool r.is_inc)

let external_reg_slice r (i,j) =
  let start = natFromInteger r.start in
  let dir = dir_of_bool r.is_inc in
  Reg_slice (r.name) start dir (external_slice dir start (i,j))

let external_reg_field_whole reg rfield =
  let (m,n) = register_field_indices_nat reg rfield in
  let start = start_of_reg_nat reg in
  let dir = dir_of_reg reg in
  Reg_field (name_of_reg reg) start dir rfield (external_slice dir start (m,n))

let external_reg_field_slice reg rfield (i,j) =
  let (m,n) = register_field_indices_nat reg rfield in
  let start = start_of_reg_nat reg in
  let dir = dir_of_reg reg in
  Reg_f_slice (name_of_reg reg) start dir rfield
              (external_slice dir start (m,n))
              (external_slice dir start (i,j))\<close>\<close>

\<comment> \<open>\<open>val external_mem_value : list bitU -> memory_value
let external_mem_value v =
  byte_lifteds_of_bitv v $> List.reverse

val internal_mem_value : memory_value -> list bitU
let internal_mem_value bytes =
  List.reverse bytes $> bitv_of_byte_lifteds\<close>\<close>


\<comment> \<open>\<open>val foreach : forall 'a 'vars.
  (list 'a) -> 'vars -> ('a -> 'vars -> 'vars) -> 'vars\<close>\<close>
fun  foreach  :: " 'a list \<Rightarrow> 'vars \<Rightarrow>('a \<Rightarrow> 'vars \<Rightarrow> 'vars)\<Rightarrow> 'vars "  where 
     " foreach ([]) vars body = ( vars )"
|" foreach (x # xs) vars body = ( foreach xs (body x vars) body )"


\<comment> \<open>\<open>val index_list : integer -> integer -> integer -> list integer\<close>\<close>
function (sequential,domintros)  index_list  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>(int)list "  where 
     " index_list from1 to1 step = (
  if ((step >( 0 :: int)) \<and> (from1 \<le> to1)) \<or> ((step <( 0 :: int)) \<and> (to1 \<le> from1)) then
    from1 # index_list (from1 + step) to1 step
  else [])" 
by pat_completeness auto


\<comment> \<open>\<open>val while : forall 'vars. 'vars -> ('vars -> bool) -> ('vars -> 'vars) -> 'vars\<close>\<close>
function (sequential,domintros)  while  :: " 'vars \<Rightarrow>('vars \<Rightarrow> bool)\<Rightarrow>('vars \<Rightarrow> 'vars)\<Rightarrow> 'vars "  where 
     " while vars cond body = (
  if cond vars then while (body vars) cond body else vars )" 
by pat_completeness auto


\<comment> \<open>\<open>val until : forall 'vars. 'vars -> ('vars -> bool) -> ('vars -> 'vars) -> 'vars\<close>\<close>
function (sequential,domintros)  until  :: " 'vars \<Rightarrow>('vars \<Rightarrow> bool)\<Rightarrow>('vars \<Rightarrow> 'vars)\<Rightarrow> 'vars "  where 
     " until vars cond body = (
  (let vars = (body vars) in
  if cond vars then vars else until (body vars) cond body))" 
by pat_completeness auto



\<comment> \<open>\<open> convert numbers unsafely to naturals \<close>\<close>

record 'a ToNatural_class=
 toNatural_method ::" 'a \<Rightarrow> nat " 

\<comment> \<open>\<open> eta-expanded for Isabelle output, otherwise it breaks \<close>\<close>
definition instance_Sail2_values_ToNatural_Num_integer_dict  :: "(int)ToNatural_class "  where 
     " instance_Sail2_values_ToNatural_Num_integer_dict = ((|

  toNatural_method = (\<lambda> n .  nat (abs n))|) )"

definition instance_Sail2_values_ToNatural_Num_int_dict  :: "(int)ToNatural_class "  where 
     " instance_Sail2_values_ToNatural_Num_int_dict = ((|

  toNatural_method = (\<lambda> n .   (nat (abs n)))|) )"

definition instance_Sail2_values_ToNatural_nat_dict  :: "(nat)ToNatural_class "  where 
     " instance_Sail2_values_ToNatural_nat_dict = ((|

  toNatural_method = (\<lambda> n .   n)|) )"

definition instance_Sail2_values_ToNatural_Num_natural_dict  :: "(nat)ToNatural_class "  where 
     " instance_Sail2_values_ToNatural_Num_natural_dict = ((|

  toNatural_method = (\<lambda> n .  n)|) )"


fun toNaturalFiveTup  :: " 'a ToNatural_class \<Rightarrow> 'b ToNatural_class \<Rightarrow> 'c ToNatural_class \<Rightarrow> 'd ToNatural_class \<Rightarrow> 'e ToNatural_class \<Rightarrow> 'd*'c*'b*'a*'e \<Rightarrow> nat*nat*nat*nat*nat "  where 
     " toNaturalFiveTup dict_Sail2_values_ToNatural_a dict_Sail2_values_ToNatural_b dict_Sail2_values_ToNatural_c dict_Sail2_values_ToNatural_d dict_Sail2_values_ToNatural_e (n1,n2,n3,n4,n5) = (
  ((toNatural_method   dict_Sail2_values_ToNatural_d) n1,(toNatural_method   dict_Sail2_values_ToNatural_c) n2,(toNatural_method   dict_Sail2_values_ToNatural_b) n3,(toNatural_method   dict_Sail2_values_ToNatural_a) n4,(toNatural_method   dict_Sail2_values_ToNatural_e) n5))"


\<comment> \<open>\<open> Let the following types be generated by Sail per spec, using either bitlists
   or machine words as bitvector representation \<close>\<close>
\<comment> \<open>\<open>type regfp =
  | RFull of (string)
  | RSlice of (string * integer * integer)
  | RSliceBit of (string * integer)
  | RField of (string * string)

type niafp =
  | NIAFP_successor
  | NIAFP_concrete_address of vector bitU
  | NIAFP_indirect_address

\<open> only for MIPS \<close>
type diafp =
  | DIAFP_none
  | DIAFP_concrete of vector bitU
  | DIAFP_reg of regfp

let regfp_to_reg (reg_info : string -> maybe string -> (nat * nat * direction * (nat * nat))) = function
  | RFull name ->
     let (start,length,direction,_) = reg_info name Nothing in
     Reg name start length direction
  | RSlice (name,i,j) ->
     let i = natFromInteger i in
     let j = natFromInteger j in
     let (start,length,direction,_) = reg_info name Nothing in
     let slice = external_slice direction start (i,j) in
     Reg_slice name start direction slice
  | RSliceBit (name,i) ->
     let i = natFromInteger i in
     let (start,length,direction,_) = reg_info name Nothing in
     let slice = external_slice direction start (i,i) in
     Reg_slice name start direction slice
  | RField (name,field_name) ->
     let (start,length,direction,span) = reg_info name (Just field_name) in
     let slice = external_slice direction start span in
     Reg_field name start direction field_name slice
end

let niafp_to_nia reginfo = function
  | NIAFP_successor -> NIA_successor
  | NIAFP_concrete_address v -> NIA_concrete_address (address_of_bitv v)
  | NIAFP_indirect_address -> NIA_indirect_address
end

let diafp_to_dia reginfo = function
  | DIAFP_none -> DIA_none
  | DIAFP_concrete v -> DIA_concrete_address (address_of_bitv v)
  | DIAFP_reg r -> DIA_register (regfp_to_reg reginfo r)
end
\<close>\<close>
end
