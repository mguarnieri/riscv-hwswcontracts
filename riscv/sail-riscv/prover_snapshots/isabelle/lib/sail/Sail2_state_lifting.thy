chapter \<open>Generated by Lem from \<open>../../src/gen_lib/sail2_state_lifting.lem\<close>.\<close>

theory "Sail2_state_lifting" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail2_values"
  "Sail2_prompt_monad"
  "Sail2_prompt"
  "Sail2_state_monad"
  "Sail2_state_monad_lemmas"

begin 

\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt\<close>\<close>
\<comment> \<open>\<open>open import Sail2_state_monad\<close>\<close>
\<comment> \<open>\<open>open import {isabelle} `Sail2_state_monad_lemmas`\<close>\<close>

\<comment> \<open>\<open> Lifting from prompt monad to state monad \<close>\<close>
\<comment> \<open>\<open>val liftState : forall 'regval 'regs 'a 'e. register_accessors 'regs 'regval -> monad 'regval 'a 'e -> monadS 'regs 'a 'e\<close>\<close>
function (sequential,domintros)  liftState  :: "(string \<Rightarrow> 'regs \<Rightarrow> 'regval option)*(string \<Rightarrow> 'regval \<Rightarrow> 'regs \<Rightarrow> 'regs option)\<Rightarrow>('regval,'a,'e)monad \<Rightarrow> 'regs sequential_state \<Rightarrow>(('a,'e)result*'regs sequential_state)set "  where 
     " liftState ra (Done a) = ( returnS a )"
|" liftState ra (Read_mem rk a sz k) = ( bindS (read_mem_bytesS rk a sz)       (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Read_memt rk a sz k) = ( bindS (read_memt_bytesS rk a sz)      (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Write_mem wk a sz v k) = ( bindS (write_mem_bytesS wk a sz v)    (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Write_memt wk a sz v t k) = ( bindS (write_memt_bytesS wk a sz v t) (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Read_reg r k) = ( bindS (read_regvalS ra r)             (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Excl_res k) = ( bindS (excl_resultS () )               (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Choose _ k) = ( bindS (choose_boolS () )               (\<lambda> v .  liftState ra (k v)))"
|" liftState ra (Write_reg r v k) = ( seqS (write_regvalS ra r v)           (liftState ra k))"
|" liftState ra (Write_ea _ _ _ k) = ( liftState ra k )"
|" liftState ra (Footprint k) = ( liftState ra k )"
|" liftState ra (Barrier _ k) = ( liftState ra k )"
|" liftState ra (Print _ k) = ( liftState ra k )"
|" liftState ra (Fail descr) = ( failS descr )"
|" liftState ra (Exception e) = ( throwS e )" 
by pat_completeness auto


\<comment> \<open>\<open>val emitEventS : forall 'regval 'regs 'a 'e. Eq 'regval => register_accessors 'regs 'regval -> event 'regval -> sequential_state 'regs -> maybe (sequential_state 'regs)\<close>\<close>
fun emitEventS  :: "(string \<Rightarrow> 'regs \<Rightarrow> 'regval option)*(string \<Rightarrow> 'regval \<Rightarrow> 'regs \<Rightarrow> 'regs option)\<Rightarrow> 'regval event \<Rightarrow> 'regs sequential_state \<Rightarrow>('regs sequential_state)option "  where 
     " emitEventS ra (E_read_mem _ addr sz v) s = (
     Option.bind (get_mem_bytes addr sz s) ( \<lambda>x .  
  (case  x of (v', _) => if v' = v then Some s else None )))"
|" emitEventS ra (E_read_memt _ addr sz (v, tag)) s = (
     Option.bind (get_mem_bytes addr sz s) ( \<lambda>x .  
  (case  x of
      (v', tag') =>
  if (v' = v) \<and> (tag' = tag) then Some s else None
  )))"
|" emitEventS ra (E_write_mem _ addr sz v success) s = (
     if success then Some (put_mem_bytes addr sz v B0 s) else None )"
|" emitEventS ra (E_write_memt _ addr sz v tag success) s = (
     if success then Some (put_mem_bytes addr sz v tag s) else None )"
|" emitEventS ra (E_read_reg r v) s = (
     (let (read_reg1, _) = ra in
     Option.bind (read_reg1 r(regstate   s)) (\<lambda> v' . 
     if v' = v then Some s else None)))"
|" emitEventS ra (E_write_reg r v) s = (
     (let (_, write_reg1) = ra in
     Option.bind (write_reg1 r v(regstate   s)) (\<lambda> rs' . 
     Some ( s (| regstate := rs' |)))))"
|" emitEventS ra _ s = ( Some s )"


\<comment> \<open>\<open>val runTraceS : forall 'regval 'regs 'a 'e. Eq 'regval => register_accessors 'regs 'regval -> trace 'regval -> sequential_state 'regs -> maybe (sequential_state 'regs)\<close>\<close>
fun  runTraceS  :: "(string \<Rightarrow> 'regs \<Rightarrow> 'regval option)*(string \<Rightarrow> 'regval \<Rightarrow> 'regs \<Rightarrow> 'regs option)\<Rightarrow>('regval event)list \<Rightarrow> 'regs sequential_state \<Rightarrow>('regs sequential_state)option "  where 
     " runTraceS ra ([]) s = ( Some s )"
|" runTraceS ra (e # t') s = ( Option.bind (emitEventS ra e s) (runTraceS ra t'))"

end
