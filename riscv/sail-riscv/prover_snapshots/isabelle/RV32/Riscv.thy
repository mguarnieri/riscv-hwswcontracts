chapter \<open>Generated by Lem from \<open>generated_definitions/lem/RV32/riscv.lem\<close>.\<close>

theory "Riscv" 

imports
  Main
  "LEM.Lem_pervasives_extra"
  "Sail.Sail2_instr_kinds"
  "Sail.Sail2_values"
  "Sail.Sail2_operators_mwords"
  "Sail.Sail2_prompt_monad"
  "Sail.Sail2_prompt"
  "Sail.Sail2_string"
  "Riscv_types"
  "Riscv_extras"

begin 

\<comment> \<open>\<open>Generated by Sail from riscv.\<close>\<close>
\<comment> \<open>\<open>open import Pervasives_extra\<close>\<close>
\<comment> \<open>\<open>open import Sail2_instr_kinds\<close>\<close>
\<comment> \<open>\<open>open import Sail2_values\<close>\<close>
\<comment> \<open>\<open>open import Sail2_string\<close>\<close>
\<comment> \<open>\<open>open import Sail2_operators_mwords\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt_monad\<close>\<close>
\<comment> \<open>\<open>open import Sail2_prompt\<close>\<close>
\<comment> \<open>\<open>open import Riscv_types\<close>\<close>
\<comment> \<open>\<open>open import Riscv_extras\<close>\<close>

\<comment> \<open>\<open>val is_none : forall 'a. maybe 'a -> bool\<close>\<close>

fun is_none  :: " 'a option \<Rightarrow> bool "  where 
     " is_none (Some (_)) = ( False )"
|" is_none None = ( True )"


\<comment> \<open>\<open>val is_some : forall 'a. maybe 'a -> bool\<close>\<close>

fun is_some  :: " 'a option \<Rightarrow> bool "  where 
     " is_some (Some (_)) = ( True )"
|" is_some None = ( False )"


\<comment> \<open>\<open>val eq_unit : unit -> unit -> bool\<close>\<close>

definition eq_unit  :: " unit \<Rightarrow> unit \<Rightarrow> bool "  where 
     " eq_unit _ _ = ( True )"




\<comment> \<open>\<open>val neq_bool : bool -> bool -> bool\<close>\<close>

definition neq_bool  :: " bool \<Rightarrow> bool \<Rightarrow> bool "  where 
     " neq_bool x y = ( \<not> (((x = y))))" 
  for  x  :: " bool " 
  and  y  :: " bool "


\<comment> \<open>\<open>val __id : integer -> integer\<close>\<close>

definition id0  :: " int \<Rightarrow> int "  where 
     " id0 x = ( x )" 
  for  x  :: " int "


\<comment> \<open>\<open>val concat_str_bits : forall 'n. Size 'n => string -> mword 'n -> string\<close>\<close>

definition concat_str_bits  :: " string \<Rightarrow>('n::len)Word.word \<Rightarrow> string "  where 
     " concat_str_bits str x = ( (@) str ((string_of_bits x)))" 
  for  str  :: " string " 
  and  x  :: "('n::len)Word.word "


\<comment> \<open>\<open>val concat_str_dec : string -> ii -> string\<close>\<close>

definition concat_str_dec  :: " string \<Rightarrow> int \<Rightarrow> string "  where 
     " concat_str_dec str x = ( (@) str ((dec_str x)))" 
  for  str  :: " string " 
  and  x  :: " int "




\<comment> \<open>\<open>val sail_mask : forall 'len 'v. Size 'len, Size 'v => integer -> mword 'v -> mword 'len\<close>\<close>

definition sail_mask  :: " int \<Rightarrow>('v::len)Word.word \<Rightarrow>('len::len)Word.word "  where 
     " sail_mask len v = (
   if ((len \<le> ((int (size v))))) then (vector_truncate v len  :: ( 'len::len)Word.word)
   else (zero_extend v len  :: ( 'len::len)Word.word))" 
  for  len  :: " int " 
  and  v  :: "('v::len)Word.word "


\<comment> \<open>\<open>val sail_ones : forall 'n. Size 'n => integer -> mword 'n\<close>\<close>

definition sail_ones  :: " int \<Rightarrow>('n::len)Word.word "  where 
     " sail_ones n = ( (not_vec ((zeros n  :: ( 'n::len)Word.word))  :: ( 'n::len)Word.word))" 
  for  n  :: " int "


\<comment> \<open>\<open>val slice_mask : forall 'n. Size 'n => integer -> ii -> ii -> mword 'n\<close>\<close>

definition slice_mask  :: " int \<Rightarrow> int \<Rightarrow> int \<Rightarrow>('n::len)Word.word "  where 
     " slice_mask n i l = (
   if ((l \<ge> n)) then (shiftl ((sail_ones n  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)
   else
     (let one = ((sail_mask n (vec_of_bits [B1]  ::  1 Word.word)  :: ( 'n::len)Word.word)) in
     (shiftl ((sub_vec ((shiftl one l  :: ( 'n::len)Word.word)) one  :: ( 'n::len)Word.word)) i  :: ( 'n::len)Word.word)))" 
  for  n  :: " int " 
  and  i  :: " int " 
  and  l  :: " int "


\<comment> \<open>\<open>val read_kind_of_num : integer -> read_kind\<close>\<close>

definition read_kind_of_num  :: " int \<Rightarrow> read_kind "  where 
     " read_kind_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then Read_plain
   else if (((p00 = (( 1 :: int)::ii)))) then Read_reserve
   else if (((p00 = (( 2 :: int)::ii)))) then Read_acquire
   else if (((p00 = (( 3 :: int)::ii)))) then Read_exclusive
   else if (((p00 = (( 4 :: int)::ii)))) then Read_exclusive_acquire
   else if (((p00 = (( 5 :: int)::ii)))) then Read_stream
   else if (((p00 = (( 6 :: int)::ii)))) then Read_RISCV_acquire
   else if (((p00 = (( 7 :: int)::ii)))) then Read_RISCV_strong_acquire
   else if (((p00 = (( 8 :: int)::ii)))) then Read_RISCV_reserved
   else if (((p00 = (( 9 :: int)::ii)))) then Read_RISCV_reserved_acquire
   else if (((p00 = (( 10 :: int)::ii)))) then Read_RISCV_reserved_strong_acquire
   else Read_X86_locked))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_read_kind : read_kind -> integer\<close>\<close>

fun num_of_read_kind  :: " read_kind \<Rightarrow> int "  where 
     " num_of_read_kind Read_plain = ( (( 0 :: int)::ii))"
|" num_of_read_kind Read_reserve = ( (( 1 :: int)::ii))"
|" num_of_read_kind Read_acquire = ( (( 2 :: int)::ii))"
|" num_of_read_kind Read_exclusive = ( (( 3 :: int)::ii))"
|" num_of_read_kind Read_exclusive_acquire = ( (( 4 :: int)::ii))"
|" num_of_read_kind Read_stream = ( (( 5 :: int)::ii))"
|" num_of_read_kind Read_RISCV_acquire = ( (( 6 :: int)::ii))"
|" num_of_read_kind Read_RISCV_strong_acquire = ( (( 7 :: int)::ii))"
|" num_of_read_kind Read_RISCV_reserved = ( (( 8 :: int)::ii))"
|" num_of_read_kind Read_RISCV_reserved_acquire = ( (( 9 :: int)::ii))"
|" num_of_read_kind Read_RISCV_reserved_strong_acquire = ( (( 10 :: int)::ii))"
|" num_of_read_kind Read_X86_locked = ( (( 11 :: int)::ii))"


\<comment> \<open>\<open>val write_kind_of_num : integer -> write_kind\<close>\<close>

definition write_kind_of_num  :: " int \<Rightarrow> write_kind "  where 
     " write_kind_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then Write_plain
   else if (((p00 = (( 1 :: int)::ii)))) then Write_conditional
   else if (((p00 = (( 2 :: int)::ii)))) then Write_release
   else if (((p00 = (( 3 :: int)::ii)))) then Write_exclusive
   else if (((p00 = (( 4 :: int)::ii)))) then Write_exclusive_release
   else if (((p00 = (( 5 :: int)::ii)))) then Write_RISCV_release
   else if (((p00 = (( 6 :: int)::ii)))) then Write_RISCV_strong_release
   else if (((p00 = (( 7 :: int)::ii)))) then Write_RISCV_conditional
   else if (((p00 = (( 8 :: int)::ii)))) then Write_RISCV_conditional_release
   else if (((p00 = (( 9 :: int)::ii)))) then Write_RISCV_conditional_strong_release
   else Write_X86_locked))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_write_kind : write_kind -> integer\<close>\<close>

fun num_of_write_kind  :: " write_kind \<Rightarrow> int "  where 
     " num_of_write_kind Write_plain = ( (( 0 :: int)::ii))"
|" num_of_write_kind Write_conditional = ( (( 1 :: int)::ii))"
|" num_of_write_kind Write_release = ( (( 2 :: int)::ii))"
|" num_of_write_kind Write_exclusive = ( (( 3 :: int)::ii))"
|" num_of_write_kind Write_exclusive_release = ( (( 4 :: int)::ii))"
|" num_of_write_kind Write_RISCV_release = ( (( 5 :: int)::ii))"
|" num_of_write_kind Write_RISCV_strong_release = ( (( 6 :: int)::ii))"
|" num_of_write_kind Write_RISCV_conditional = ( (( 7 :: int)::ii))"
|" num_of_write_kind Write_RISCV_conditional_release = ( (( 8 :: int)::ii))"
|" num_of_write_kind Write_RISCV_conditional_strong_release = ( (( 9 :: int)::ii))"
|" num_of_write_kind Write_X86_locked = ( (( 10 :: int)::ii))"


\<comment> \<open>\<open>val barrier_kind_of_num : integer -> barrier_kind\<close>\<close>

definition barrier_kind_of_num  :: " int \<Rightarrow> barrier_kind "  where 
     " barrier_kind_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then Barrier_Sync
   else if (((p00 = (( 1 :: int)::ii)))) then Barrier_LwSync
   else if (((p00 = (( 2 :: int)::ii)))) then Barrier_Eieio
   else if (((p00 = (( 3 :: int)::ii)))) then Barrier_Isync
   else if (((p00 = (( 4 :: int)::ii)))) then Barrier_DMB
   else if (((p00 = (( 5 :: int)::ii)))) then Barrier_DMB_ST
   else if (((p00 = (( 6 :: int)::ii)))) then Barrier_DMB_LD
   else if (((p00 = (( 7 :: int)::ii)))) then Barrier_DSB
   else if (((p00 = (( 8 :: int)::ii)))) then Barrier_DSB_ST
   else if (((p00 = (( 9 :: int)::ii)))) then Barrier_DSB_LD
   else if (((p00 = (( 10 :: int)::ii)))) then Barrier_ISB
   else if (((p00 = (( 11 :: int)::ii)))) then Barrier_MIPS_SYNC
   else if (((p00 = (( 12 :: int)::ii)))) then Barrier_RISCV_rw_rw
   else if (((p00 = (( 13 :: int)::ii)))) then Barrier_RISCV_r_rw
   else if (((p00 = (( 14 :: int)::ii)))) then Barrier_RISCV_r_r
   else if (((p00 = (( 15 :: int)::ii)))) then Barrier_RISCV_rw_w
   else if (((p00 = (( 16 :: int)::ii)))) then Barrier_RISCV_w_w
   else if (((p00 = (( 17 :: int)::ii)))) then Barrier_RISCV_w_rw
   else if (((p00 = (( 18 :: int)::ii)))) then Barrier_RISCV_rw_r
   else if (((p00 = (( 19 :: int)::ii)))) then Barrier_RISCV_r_w
   else if (((p00 = (( 20 :: int)::ii)))) then Barrier_RISCV_w_r
   else if (((p00 = (( 21 :: int)::ii)))) then Barrier_RISCV_tso
   else if (((p00 = (( 22 :: int)::ii)))) then Barrier_RISCV_i
   else Barrier_x86_MFENCE))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_barrier_kind : barrier_kind -> integer\<close>\<close>

fun num_of_barrier_kind  :: " barrier_kind \<Rightarrow> int "  where 
     " num_of_barrier_kind Barrier_Sync = ( (( 0 :: int)::ii))"
|" num_of_barrier_kind Barrier_LwSync = ( (( 1 :: int)::ii))"
|" num_of_barrier_kind Barrier_Eieio = ( (( 2 :: int)::ii))"
|" num_of_barrier_kind Barrier_Isync = ( (( 3 :: int)::ii))"
|" num_of_barrier_kind Barrier_DMB = ( (( 4 :: int)::ii))"
|" num_of_barrier_kind Barrier_DMB_ST = ( (( 5 :: int)::ii))"
|" num_of_barrier_kind Barrier_DMB_LD = ( (( 6 :: int)::ii))"
|" num_of_barrier_kind Barrier_DSB = ( (( 7 :: int)::ii))"
|" num_of_barrier_kind Barrier_DSB_ST = ( (( 8 :: int)::ii))"
|" num_of_barrier_kind Barrier_DSB_LD = ( (( 9 :: int)::ii))"
|" num_of_barrier_kind Barrier_ISB = ( (( 10 :: int)::ii))"
|" num_of_barrier_kind Barrier_MIPS_SYNC = ( (( 11 :: int)::ii))"
|" num_of_barrier_kind Barrier_RISCV_rw_rw = ( (( 12 :: int)::ii))"
|" num_of_barrier_kind Barrier_RISCV_r_rw = ( (( 13 :: int)::ii))"
|" num_of_barrier_kind Barrier_RISCV_r_r = ( (( 14 :: int)::ii))"
|" num_of_barrier_kind Barrier_RISCV_rw_w = ( (( 15 :: int)::ii))"
|" num_of_barrier_kind Barrier_RISCV_w_w = ( (( 16 :: int)::ii))"
|" num_of_barrier_kind Barrier_RISCV_w_rw = ( (( 17 :: int)::ii))"
|" num_of_barrier_kind Barrier_RISCV_rw_r = ( (( 18 :: int)::ii))"
|" num_of_barrier_kind Barrier_RISCV_r_w = ( (( 19 :: int)::ii))"
|" num_of_barrier_kind Barrier_RISCV_w_r = ( (( 20 :: int)::ii))"
|" num_of_barrier_kind Barrier_RISCV_tso = ( (( 21 :: int)::ii))"
|" num_of_barrier_kind Barrier_RISCV_i = ( (( 22 :: int)::ii))"
|" num_of_barrier_kind Barrier_x86_MFENCE = ( (( 23 :: int)::ii))"


\<comment> \<open>\<open>val trans_kind_of_num : integer -> trans_kind\<close>\<close>

definition trans_kind_of_num  :: " int \<Rightarrow> trans_kind "  where 
     " trans_kind_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then Transaction_start
   else if (((p00 = (( 1 :: int)::ii)))) then Transaction_commit
   else Transaction_abort))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_trans_kind : trans_kind -> integer\<close>\<close>

fun num_of_trans_kind  :: " trans_kind \<Rightarrow> int "  where 
     " num_of_trans_kind Transaction_start = ( (( 0 :: int)::ii))"
|" num_of_trans_kind Transaction_commit = ( (( 1 :: int)::ii))"
|" num_of_trans_kind Transaction_abort = ( (( 2 :: int)::ii))"


\<comment> \<open>\<open>val cache_op_kind_of_num : integer -> cache_op_kind\<close>\<close>

definition cache_op_kind_of_num  :: " int \<Rightarrow> cache_op_kind "  where 
     " cache_op_kind_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then Cache_op_D_IVAC
   else if (((p00 = (( 1 :: int)::ii)))) then Cache_op_D_ISW
   else if (((p00 = (( 2 :: int)::ii)))) then Cache_op_D_CSW
   else if (((p00 = (( 3 :: int)::ii)))) then Cache_op_D_CISW
   else if (((p00 = (( 4 :: int)::ii)))) then Cache_op_D_ZVA
   else if (((p00 = (( 5 :: int)::ii)))) then Cache_op_D_CVAC
   else if (((p00 = (( 6 :: int)::ii)))) then Cache_op_D_CVAU
   else if (((p00 = (( 7 :: int)::ii)))) then Cache_op_D_CIVAC
   else if (((p00 = (( 8 :: int)::ii)))) then Cache_op_I_IALLUIS
   else if (((p00 = (( 9 :: int)::ii)))) then Cache_op_I_IALLU
   else Cache_op_I_IVAU))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_cache_op_kind : cache_op_kind -> integer\<close>\<close>

fun num_of_cache_op_kind  :: " cache_op_kind \<Rightarrow> int "  where 
     " num_of_cache_op_kind Cache_op_D_IVAC = ( (( 0 :: int)::ii))"
|" num_of_cache_op_kind Cache_op_D_ISW = ( (( 1 :: int)::ii))"
|" num_of_cache_op_kind Cache_op_D_CSW = ( (( 2 :: int)::ii))"
|" num_of_cache_op_kind Cache_op_D_CISW = ( (( 3 :: int)::ii))"
|" num_of_cache_op_kind Cache_op_D_ZVA = ( (( 4 :: int)::ii))"
|" num_of_cache_op_kind Cache_op_D_CVAC = ( (( 5 :: int)::ii))"
|" num_of_cache_op_kind Cache_op_D_CVAU = ( (( 6 :: int)::ii))"
|" num_of_cache_op_kind Cache_op_D_CIVAC = ( (( 7 :: int)::ii))"
|" num_of_cache_op_kind Cache_op_I_IALLUIS = ( (( 8 :: int)::ii))"
|" num_of_cache_op_kind Cache_op_I_IALLU = ( (( 9 :: int)::ii))"
|" num_of_cache_op_kind Cache_op_I_IVAU = ( (( 10 :: int)::ii))"






\<comment> \<open>\<open>val cast_unit_vec : bitU -> mword ty1\<close>\<close>

fun cast_unit_vec0  :: " bitU \<Rightarrow>(1)Word.word "  where 
     " cast_unit_vec0 B0 = ( (vec_of_bits [B0]  ::  1 Word.word))"
|" cast_unit_vec0 B1 = ( (vec_of_bits [B1]  ::  1 Word.word))"


\<comment> \<open>\<open>val get_config_print_instr : unit -> bool\<close>\<close>

\<comment> \<open>\<open>val get_config_print_reg : unit -> bool\<close>\<close>

\<comment> \<open>\<open>val get_config_print_mem : unit -> bool\<close>\<close>

\<comment> \<open>\<open>val get_config_print_platform : unit -> bool\<close>\<close>

definition get_config_print_instr  :: " unit \<Rightarrow> bool "  where 
     " get_config_print_instr _ = ( False )"


definition get_config_print_reg  :: " unit \<Rightarrow> bool "  where 
     " get_config_print_reg _ = ( False )"


definition get_config_print_mem  :: " unit \<Rightarrow> bool "  where 
     " get_config_print_mem _ = ( False )"


definition get_config_print_platform  :: " unit \<Rightarrow> bool "  where 
     " get_config_print_platform _ = ( False )"


\<comment> \<open>\<open>val EXTS : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> mword 'm\<close>\<close>

\<comment> \<open>\<open>val EXTZ : forall 'm 'n. Size 'm, Size 'n => integer -> mword 'n -> mword 'm\<close>\<close>

definition EXTS  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word "  where 
     " EXTS m v = ( (sign_extend v m  :: ( 'm::len)Word.word))" 
  for  m  :: " int " 
  and  v  :: "('n::len)Word.word "


definition EXTZ  :: " int \<Rightarrow>('n::len)Word.word \<Rightarrow>('m::len)Word.word "  where 
     " EXTZ m v = ( (zero_extend v m  :: ( 'm::len)Word.word))" 
  for  m  :: " int " 
  and  v  :: "('n::len)Word.word "


\<comment> \<open>\<open>val zeros_implicit : forall 'n. Size 'n => integer -> mword 'n\<close>\<close>

definition zeros_implicit  :: " int \<Rightarrow>('n::len)Word.word "  where 
     " zeros_implicit n = ( (zeros n  :: ( 'n::len)Word.word))" 
  for  n  :: " int "


\<comment> \<open>\<open>val ones : forall 'n. Size 'n => integer -> mword 'n\<close>\<close>

definition ones  :: " int \<Rightarrow>('n::len)Word.word "  where 
     " ones n = ( (sail_ones n  :: ( 'n::len)Word.word))" 
  for  n  :: " int "


\<comment> \<open>\<open>val bool_to_bits : bool -> mword ty1\<close>\<close>

definition bool_to_bits  :: " bool \<Rightarrow>(1)Word.word "  where 
     " bool_to_bits x = ( if x then (vec_of_bits [B1]  ::  1 Word.word) else (vec_of_bits [B0]  ::  1 Word.word))" 
  for  x  :: " bool "


\<comment> \<open>\<open>val bit_to_bool : bitU -> bool\<close>\<close>

fun bit_to_bool  :: " bitU \<Rightarrow> bool "  where 
     " bit_to_bool B1 = ( True )"
|" bit_to_bool B0 = ( False )"


\<comment> \<open>\<open>val to_bits : forall 'l. Size 'l => integer -> ii -> mword 'l\<close>\<close>

definition to_bits  :: " int \<Rightarrow> int \<Rightarrow>('l::len)Word.word "  where 
     " to_bits l n = ( (get_slice_int l n (( 0 :: int)::ii)  :: ( 'l::len)Word.word))" 
  for  l  :: " int " 
  and  n  :: " int "


\<comment> \<open>\<open>val zopz0zI_s : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

\<comment> \<open>\<open>val zopz0zKzJ_s : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

\<comment> \<open>\<open>val zopz0zI_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

\<comment> \<open>\<open>val zopz0zKzJ_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

\<comment> \<open>\<open>val zopz0zIzJ_u : forall 'n. Size 'n => mword 'n -> mword 'n -> bool\<close>\<close>

definition zopz0zI_s  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zI_s x y = ( ((Word.sint x)) < ((Word.sint y)))" 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


definition zopz0zKzJ_s  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zKzJ_s x y = ( ((Word.sint x)) \<ge> ((Word.sint y)))" 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


definition zopz0zI_u  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zI_u x y = ( ((Word.uint x)) < ((Word.uint y)))" 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


definition zopz0zKzJ_u  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zKzJ_u x y = ( ((Word.uint x)) \<ge> ((Word.uint y)))" 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


definition zopz0zIzJ_u  :: "('n::len)Word.word \<Rightarrow>('n::len)Word.word \<Rightarrow> bool "  where 
     " zopz0zIzJ_u x y = ( ((Word.uint x)) \<le> ((Word.uint y)))" 
  for  x  :: "('n::len)Word.word " 
  and  y  :: "('n::len)Word.word "


\<comment> \<open>\<open>val shift_right_arith64 : mword ty64 -> mword ty6 -> mword ty64\<close>\<close>

definition shift_right_arith64  :: "(64)Word.word \<Rightarrow>(6)Word.word \<Rightarrow>(64)Word.word "  where 
     " shift_right_arith64 (v :: 64 bits) (shift :: 6 bits) = (
   (let (v128 :: 128 bits) = ((EXTS (( 128 :: int)::ii) v  ::  128 Word.word)) in
   (subrange_vec_dec ((shift_bits_right v128 shift  ::  128 Word.word)) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)))" 
  for  v  :: "(64)Word.word " 
  and  shift  :: "(6)Word.word "


\<comment> \<open>\<open>val shift_right_arith32 : mword ty32 -> mword ty5 -> mword ty32\<close>\<close>

definition shift_right_arith32  :: "(32)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(32)Word.word "  where 
     " shift_right_arith32 (v :: 32 bits) (shift :: 5 bits) = (
   (let (v64 :: 64 bits) = ((EXTS (( 64 :: int)::ii) v  ::  64 Word.word)) in
   (subrange_vec_dec ((shift_bits_right v64 shift  ::  64 Word.word)) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)))" 
  for  v  :: "(32)Word.word " 
  and  shift  :: "(5)Word.word "


\<comment> \<open>\<open>val n_leading_spaces : string -> ii\<close>\<close>

function (sequential,domintros)  n_leading_spaces0  :: " string \<Rightarrow> int "  where 
     " n_leading_spaces0 s = (
   (let p00 = s in
   if (((p00 = ('''')))) then (( 0 :: int)::ii)
   else
     (let p00 = (string_take s (( 1 :: int)::ii)) in
     if (((p00 = ('' '')))) then (( 1 :: int)::ii) + ((n_leading_spaces0 ((string_drop s (( 1 :: int)::ii)))))
     else (( 0 :: int)::ii))))" 
  for  s  :: " string " 
by pat_completeness auto


\<comment> \<open>\<open>val spc_forwards : unit -> string\<close>\<close>

definition spc_forwards  :: " unit \<Rightarrow> string "  where 
     " spc_forwards _ = ( ('' ''))"


\<comment> \<open>\<open>val spc_backwards : string -> unit\<close>\<close>

definition spc_backwards  :: " string \<Rightarrow> unit "  where 
     " spc_backwards s = ( ()  )" 
  for  s  :: " string "


\<comment> \<open>\<open>val spc_matches_prefix : string -> maybe ((unit * ii))\<close>\<close>

definition spc_matches_prefix0  :: " string \<Rightarrow>(unit*int)option "  where 
     " spc_matches_prefix0 s = (
   (let n = (n_leading_spaces0 s) in
   (let p00 = n in
   if (((p00 = (( 0 :: int)::ii)))) then None
   else Some (() , n))))" 
  for  s  :: " string "


\<comment> \<open>\<open>val opt_spc_forwards : unit -> string\<close>\<close>

definition opt_spc_forwards  :: " unit \<Rightarrow> string "  where 
     " opt_spc_forwards _ = ( (''''))"


\<comment> \<open>\<open>val opt_spc_backwards : string -> unit\<close>\<close>

definition opt_spc_backwards  :: " string \<Rightarrow> unit "  where 
     " opt_spc_backwards s = ( ()  )" 
  for  s  :: " string "


\<comment> \<open>\<open>val opt_spc_matches_prefix : string -> maybe ((unit * ii))\<close>\<close>

definition opt_spc_matches_prefix0  :: " string \<Rightarrow>(unit*int)option "  where 
     " opt_spc_matches_prefix0 s = ( Some (() , n_leading_spaces0 s))" 
  for  s  :: " string "


\<comment> \<open>\<open>val def_spc_forwards : unit -> string\<close>\<close>

definition def_spc_forwards  :: " unit \<Rightarrow> string "  where 
     " def_spc_forwards _ = ( ('' ''))"


\<comment> \<open>\<open>val def_spc_backwards : string -> unit\<close>\<close>

definition def_spc_backwards  :: " string \<Rightarrow> unit "  where 
     " def_spc_backwards s = ( ()  )" 
  for  s  :: " string "


\<comment> \<open>\<open>val def_spc_matches_prefix : string -> maybe ((unit * ii))\<close>\<close>

definition def_spc_matches_prefix  :: " string \<Rightarrow>(unit*ii)option "  where 
     " def_spc_matches_prefix s = ( opt_spc_matches_prefix0 s )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_1_forwards_matches : mword ty1 -> bool\<close>\<close>

definition hex_bits_1_forwards_matches  :: "(1)Word.word \<Rightarrow> bool "  where 
     " hex_bits_1_forwards_matches bv = ( True )" 
  for  bv  :: "(1)Word.word "


\<comment> \<open>\<open>val hex_bits_1_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_1_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_1_backwards_matches s = (
      if ((case  ((hex_bits_1_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 1 Word.word * ii))option)) of
          Some ((g__39, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_1_backwards : string -> M (mword ty1)\<close>\<close>

definition hex_bits_1_backwards  :: " string \<Rightarrow>((register_value),((1)Word.word),(exception))monad "  where 
     " hex_bits_1_backwards s = (
   (case  ((hex_bits_1_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 1 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 49:2 - 51:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 49:2 - 51:3'') \<then> exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_2_forwards_matches : mword ty2 -> bool\<close>\<close>

definition hex_bits_2_forwards_matches  :: "(2)Word.word \<Rightarrow> bool "  where 
     " hex_bits_2_forwards_matches bv = ( True )" 
  for  bv  :: "(2)Word.word "


\<comment> \<open>\<open>val hex_bits_2_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_2_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_2_backwards_matches s = (
      if ((case  ((hex_bits_2_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 2 Word.word * ii))option)) of
          Some ((g__38, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_2_backwards : string -> M (mword ty2)\<close>\<close>

definition hex_bits_2_backwards  :: " string \<Rightarrow>((register_value),((2)Word.word),(exception))monad "  where 
     " hex_bits_2_backwards s = (
   (case  ((hex_bits_2_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 2 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 68:2 - 70:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 68:2 - 70:3'') \<then> exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_3_forwards_matches : mword ty3 -> bool\<close>\<close>

definition hex_bits_3_forwards_matches  :: "(3)Word.word \<Rightarrow> bool "  where 
     " hex_bits_3_forwards_matches bv = ( True )" 
  for  bv  :: "(3)Word.word "


\<comment> \<open>\<open>val hex_bits_3_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_3_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_3_backwards_matches s = (
      if ((case  ((hex_bits_3_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 3 Word.word * ii))option)) of
          Some ((g__37, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_3_backwards : string -> M (mword ty3)\<close>\<close>

definition hex_bits_3_backwards  :: " string \<Rightarrow>((register_value),((3)Word.word),(exception))monad "  where 
     " hex_bits_3_backwards s = (
   (case  ((hex_bits_3_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 3 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 87:2 - 89:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 87:2 - 89:3'') \<then> exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_4_forwards_matches : mword ty4 -> bool\<close>\<close>

definition hex_bits_4_forwards_matches  :: "(4)Word.word \<Rightarrow> bool "  where 
     " hex_bits_4_forwards_matches bv = ( True )" 
  for  bv  :: "(4)Word.word "


\<comment> \<open>\<open>val hex_bits_4_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_4_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_4_backwards_matches s = (
      if ((case  ((hex_bits_4_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 4 Word.word * ii))option)) of
          Some ((g__36, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_4_backwards : string -> M (mword ty4)\<close>\<close>

definition hex_bits_4_backwards  :: " string \<Rightarrow>((register_value),((4)Word.word),(exception))monad "  where 
     " hex_bits_4_backwards s = (
   (case  ((hex_bits_4_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 4 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 106:2 - 108:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 106:2 - 108:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_5_forwards_matches : mword ty5 -> bool\<close>\<close>

definition hex_bits_5_forwards_matches  :: "(5)Word.word \<Rightarrow> bool "  where 
     " hex_bits_5_forwards_matches bv = ( True )" 
  for  bv  :: "(5)Word.word "


\<comment> \<open>\<open>val hex_bits_5_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_5_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_5_backwards_matches s = (
      if ((case  ((hex_bits_5_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 5 Word.word * ii))option)) of
          Some ((g__35, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_5_backwards : string -> M (mword ty5)\<close>\<close>

definition hex_bits_5_backwards  :: " string \<Rightarrow>((register_value),((5)Word.word),(exception))monad "  where 
     " hex_bits_5_backwards s = (
   (case  ((hex_bits_5_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 5 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 125:2 - 127:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 125:2 - 127:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_6_forwards_matches : mword ty6 -> bool\<close>\<close>

definition hex_bits_6_forwards_matches  :: "(6)Word.word \<Rightarrow> bool "  where 
     " hex_bits_6_forwards_matches bv = ( True )" 
  for  bv  :: "(6)Word.word "


\<comment> \<open>\<open>val hex_bits_6_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_6_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_6_backwards_matches s = (
      if ((case  ((hex_bits_6_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 6 Word.word * ii))option)) of
          Some ((g__34, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_6_backwards : string -> M (mword ty6)\<close>\<close>

definition hex_bits_6_backwards  :: " string \<Rightarrow>((register_value),((6)Word.word),(exception))monad "  where 
     " hex_bits_6_backwards s = (
   (case  ((hex_bits_6_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 6 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 144:2 - 146:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 144:2 - 146:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_7_forwards_matches : mword ty7 -> bool\<close>\<close>

definition hex_bits_7_forwards_matches  :: "(7)Word.word \<Rightarrow> bool "  where 
     " hex_bits_7_forwards_matches bv = ( True )" 
  for  bv  :: "(7)Word.word "


\<comment> \<open>\<open>val hex_bits_7_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_7_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_7_backwards_matches s = (
      if ((case  ((hex_bits_7_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 7 Word.word * ii))option)) of
          Some ((g__33, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_7_backwards : string -> M (mword ty7)\<close>\<close>

definition hex_bits_7_backwards  :: " string \<Rightarrow>((register_value),((7)Word.word),(exception))monad "  where 
     " hex_bits_7_backwards s = (
   (case  ((hex_bits_7_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 7 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 163:2 - 165:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 163:2 - 165:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_8_forwards_matches : mword ty8 -> bool\<close>\<close>

definition hex_bits_8_forwards_matches  :: "(8)Word.word \<Rightarrow> bool "  where 
     " hex_bits_8_forwards_matches bv = ( True )" 
  for  bv  :: "(8)Word.word "


\<comment> \<open>\<open>val hex_bits_8_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_8_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_8_backwards_matches s = (
      if ((case  ((hex_bits_8_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 8 Word.word * ii))option)) of
          Some ((g__32, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_8_backwards : string -> M (mword ty8)\<close>\<close>

definition hex_bits_8_backwards  :: " string \<Rightarrow>((register_value),((8)Word.word),(exception))monad "  where 
     " hex_bits_8_backwards s = (
   (case  ((hex_bits_8_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 8 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 182:2 - 184:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 182:2 - 184:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_9_forwards_matches : mword ty9 -> bool\<close>\<close>

definition hex_bits_9_forwards_matches  :: "(9)Word.word \<Rightarrow> bool "  where 
     " hex_bits_9_forwards_matches bv = ( True )" 
  for  bv  :: "(9)Word.word "


\<comment> \<open>\<open>val hex_bits_9_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_9_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_9_backwards_matches s = (
      if ((case  ((hex_bits_9_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 9 Word.word * ii))option)) of
          Some ((g__31, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_9_backwards : string -> M (mword ty9)\<close>\<close>

definition hex_bits_9_backwards  :: " string \<Rightarrow>((register_value),((9)Word.word),(exception))monad "  where 
     " hex_bits_9_backwards s = (
   (case  ((hex_bits_9_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 9 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 201:2 - 203:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 201:2 - 203:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_10_forwards_matches : mword ty10 -> bool\<close>\<close>

definition hex_bits_10_forwards_matches  :: "(10)Word.word \<Rightarrow> bool "  where 
     " hex_bits_10_forwards_matches bv = ( True )" 
  for  bv  :: "(10)Word.word "


\<comment> \<open>\<open>val hex_bits_10_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_10_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_10_backwards_matches s = (
      if ((case  ((hex_bits_10_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 10 Word.word * ii))option)) of
          Some ((g__30, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_10_backwards : string -> M (mword ty10)\<close>\<close>

definition hex_bits_10_backwards  :: " string \<Rightarrow>((register_value),((10)Word.word),(exception))monad "  where 
     " hex_bits_10_backwards s = (
   (case  ((hex_bits_10_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 10 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 220:2 - 222:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 220:2 - 222:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_11_forwards_matches : mword ty11 -> bool\<close>\<close>

definition hex_bits_11_forwards_matches  :: "(11)Word.word \<Rightarrow> bool "  where 
     " hex_bits_11_forwards_matches bv = ( True )" 
  for  bv  :: "(11)Word.word "


\<comment> \<open>\<open>val hex_bits_11_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_11_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_11_backwards_matches s = (
      if ((case  ((hex_bits_11_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 11 Word.word * ii))option)) of
          Some ((g__29, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_11_backwards : string -> M (mword ty11)\<close>\<close>

definition hex_bits_11_backwards  :: " string \<Rightarrow>((register_value),((11)Word.word),(exception))monad "  where 
     " hex_bits_11_backwards s = (
   (case  ((hex_bits_11_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 11 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 239:2 - 241:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 239:2 - 241:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_12_forwards_matches : mword ty12 -> bool\<close>\<close>

definition hex_bits_12_forwards_matches  :: "(12)Word.word \<Rightarrow> bool "  where 
     " hex_bits_12_forwards_matches bv = ( True )" 
  for  bv  :: "(12)Word.word "


\<comment> \<open>\<open>val hex_bits_12_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_12_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_12_backwards_matches s = (
      if ((case  ((hex_bits_12_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 12 Word.word * ii))option)) of
          Some ((g__28, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_12_backwards : string -> M (mword ty12)\<close>\<close>

definition hex_bits_12_backwards  :: " string \<Rightarrow>((register_value),((12)Word.word),(exception))monad "  where 
     " hex_bits_12_backwards s = (
   (case  ((hex_bits_12_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 12 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 258:2 - 260:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 258:2 - 260:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_13_forwards_matches : mword ty13 -> bool\<close>\<close>

definition hex_bits_13_forwards_matches  :: "(13)Word.word \<Rightarrow> bool "  where 
     " hex_bits_13_forwards_matches bv = ( True )" 
  for  bv  :: "(13)Word.word "


\<comment> \<open>\<open>val hex_bits_13_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_13_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_13_backwards_matches s = (
      if ((case  ((hex_bits_13_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 13 Word.word * ii))option)) of
          Some ((g__27, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_13_backwards : string -> M (mword ty13)\<close>\<close>

definition hex_bits_13_backwards  :: " string \<Rightarrow>((register_value),((13)Word.word),(exception))monad "  where 
     " hex_bits_13_backwards s = (
   (case  ((hex_bits_13_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 13 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 277:2 - 279:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 277:2 - 279:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_14_forwards_matches : mword ty14 -> bool\<close>\<close>

definition hex_bits_14_forwards_matches  :: "(14)Word.word \<Rightarrow> bool "  where 
     " hex_bits_14_forwards_matches bv = ( True )" 
  for  bv  :: "(14)Word.word "


\<comment> \<open>\<open>val hex_bits_14_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_14_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_14_backwards_matches s = (
      if ((case  ((hex_bits_14_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 14 Word.word * ii))option)) of
          Some ((g__26, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_14_backwards : string -> M (mword ty14)\<close>\<close>

definition hex_bits_14_backwards  :: " string \<Rightarrow>((register_value),((14)Word.word),(exception))monad "  where 
     " hex_bits_14_backwards s = (
   (case  ((hex_bits_14_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 14 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 296:2 - 298:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 296:2 - 298:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_15_forwards_matches : mword ty15 -> bool\<close>\<close>

definition hex_bits_15_forwards_matches  :: "(15)Word.word \<Rightarrow> bool "  where 
     " hex_bits_15_forwards_matches bv = ( True )" 
  for  bv  :: "(15)Word.word "


\<comment> \<open>\<open>val hex_bits_15_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_15_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_15_backwards_matches s = (
      if ((case  ((hex_bits_15_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 15 Word.word * ii))option)) of
          Some ((g__25, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_15_backwards : string -> M (mword ty15)\<close>\<close>

definition hex_bits_15_backwards  :: " string \<Rightarrow>((register_value),((15)Word.word),(exception))monad "  where 
     " hex_bits_15_backwards s = (
   (case  ((hex_bits_15_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 15 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 315:2 - 317:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 315:2 - 317:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_16_forwards_matches : mword ty16 -> bool\<close>\<close>

definition hex_bits_16_forwards_matches  :: "(16)Word.word \<Rightarrow> bool "  where 
     " hex_bits_16_forwards_matches bv = ( True )" 
  for  bv  :: "(16)Word.word "


\<comment> \<open>\<open>val hex_bits_16_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_16_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_16_backwards_matches s = (
      if ((case  ((hex_bits_16_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 16 Word.word * ii))option)) of
          Some ((g__24, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_16_backwards : string -> M (mword ty16)\<close>\<close>

definition hex_bits_16_backwards  :: " string \<Rightarrow>((register_value),((16)Word.word),(exception))monad "  where 
     " hex_bits_16_backwards s = (
   (case  ((hex_bits_16_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 16 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 334:2 - 336:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 334:2 - 336:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_17_forwards_matches : mword ty17 -> bool\<close>\<close>

definition hex_bits_17_forwards_matches  :: "(17)Word.word \<Rightarrow> bool "  where 
     " hex_bits_17_forwards_matches bv = ( True )" 
  for  bv  :: "(17)Word.word "


\<comment> \<open>\<open>val hex_bits_17_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_17_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_17_backwards_matches s = (
      if ((case  ((hex_bits_17_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 17 Word.word * ii))option)) of
          Some ((g__23, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_17_backwards : string -> M (mword ty17)\<close>\<close>

definition hex_bits_17_backwards  :: " string \<Rightarrow>((register_value),((17)Word.word),(exception))monad "  where 
     " hex_bits_17_backwards s = (
   (case  ((hex_bits_17_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 17 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 353:2 - 355:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 353:2 - 355:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_18_forwards_matches : mword ty18 -> bool\<close>\<close>

definition hex_bits_18_forwards_matches  :: "(18)Word.word \<Rightarrow> bool "  where 
     " hex_bits_18_forwards_matches bv = ( True )" 
  for  bv  :: "(18)Word.word "


\<comment> \<open>\<open>val hex_bits_18_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_18_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_18_backwards_matches s = (
      if ((case  ((hex_bits_18_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 18 Word.word * ii))option)) of
          Some ((g__22, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_18_backwards : string -> M (mword ty18)\<close>\<close>

definition hex_bits_18_backwards  :: " string \<Rightarrow>((register_value),((18)Word.word),(exception))monad "  where 
     " hex_bits_18_backwards s = (
   (case  ((hex_bits_18_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 18 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 372:2 - 374:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 372:2 - 374:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_19_forwards_matches : mword ty19 -> bool\<close>\<close>

definition hex_bits_19_forwards_matches  :: "(19)Word.word \<Rightarrow> bool "  where 
     " hex_bits_19_forwards_matches bv = ( True )" 
  for  bv  :: "(19)Word.word "


\<comment> \<open>\<open>val hex_bits_19_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_19_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_19_backwards_matches s = (
      if ((case  ((hex_bits_19_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 19 Word.word * ii))option)) of
          Some ((g__21, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_19_backwards : string -> M (mword ty19)\<close>\<close>

definition hex_bits_19_backwards  :: " string \<Rightarrow>((register_value),((19)Word.word),(exception))monad "  where 
     " hex_bits_19_backwards s = (
   (case  ((hex_bits_19_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 19 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 391:2 - 393:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 391:2 - 393:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_20_forwards_matches : mword ty20 -> bool\<close>\<close>

definition hex_bits_20_forwards_matches  :: "(20)Word.word \<Rightarrow> bool "  where 
     " hex_bits_20_forwards_matches bv = ( True )" 
  for  bv  :: "(20)Word.word "


\<comment> \<open>\<open>val hex_bits_20_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_20_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_20_backwards_matches s = (
      if ((case  ((hex_bits_20_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 20 Word.word * ii))option)) of
          Some ((g__20, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_20_backwards : string -> M (mword ty20)\<close>\<close>

definition hex_bits_20_backwards  :: " string \<Rightarrow>((register_value),((20)Word.word),(exception))monad "  where 
     " hex_bits_20_backwards s = (
   (case  ((hex_bits_20_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 20 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 410:2 - 412:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 410:2 - 412:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_21_forwards_matches : mword ty21 -> bool\<close>\<close>

definition hex_bits_21_forwards_matches  :: "(21)Word.word \<Rightarrow> bool "  where 
     " hex_bits_21_forwards_matches bv = ( True )" 
  for  bv  :: "(21)Word.word "


\<comment> \<open>\<open>val hex_bits_21_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_21_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_21_backwards_matches s = (
      if ((case  ((hex_bits_21_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 21 Word.word * ii))option)) of
          Some ((g__19, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_21_backwards : string -> M (mword ty21)\<close>\<close>

definition hex_bits_21_backwards  :: " string \<Rightarrow>((register_value),((21)Word.word),(exception))monad "  where 
     " hex_bits_21_backwards s = (
   (case  ((hex_bits_21_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 21 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 429:2 - 431:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 429:2 - 431:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_22_forwards_matches : mword ty22 -> bool\<close>\<close>

definition hex_bits_22_forwards_matches  :: "(22)Word.word \<Rightarrow> bool "  where 
     " hex_bits_22_forwards_matches bv = ( True )" 
  for  bv  :: "(22)Word.word "


\<comment> \<open>\<open>val hex_bits_22_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_22_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_22_backwards_matches s = (
      if ((case  ((hex_bits_22_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 22 Word.word * ii))option)) of
          Some ((g__18, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_22_backwards : string -> M (mword ty22)\<close>\<close>

definition hex_bits_22_backwards  :: " string \<Rightarrow>((register_value),((22)Word.word),(exception))monad "  where 
     " hex_bits_22_backwards s = (
   (case  ((hex_bits_22_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 22 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 448:2 - 450:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 448:2 - 450:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_23_forwards_matches : mword ty23 -> bool\<close>\<close>

definition hex_bits_23_forwards_matches  :: "(23)Word.word \<Rightarrow> bool "  where 
     " hex_bits_23_forwards_matches bv = ( True )" 
  for  bv  :: "(23)Word.word "


\<comment> \<open>\<open>val hex_bits_23_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_23_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_23_backwards_matches s = (
      if ((case  ((hex_bits_23_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 23 Word.word * ii))option)) of
          Some ((g__17, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_23_backwards : string -> M (mword ty23)\<close>\<close>

definition hex_bits_23_backwards  :: " string \<Rightarrow>((register_value),((23)Word.word),(exception))monad "  where 
     " hex_bits_23_backwards s = (
   (case  ((hex_bits_23_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 23 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 467:2 - 469:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 467:2 - 469:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_24_forwards_matches : mword ty24 -> bool\<close>\<close>

definition hex_bits_24_forwards_matches  :: "(24)Word.word \<Rightarrow> bool "  where 
     " hex_bits_24_forwards_matches bv = ( True )" 
  for  bv  :: "(24)Word.word "


\<comment> \<open>\<open>val hex_bits_24_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_24_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_24_backwards_matches s = (
      if ((case  ((hex_bits_24_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 24 Word.word * ii))option)) of
          Some ((g__16, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_24_backwards : string -> M (mword ty24)\<close>\<close>

definition hex_bits_24_backwards  :: " string \<Rightarrow>((register_value),((24)Word.word),(exception))monad "  where 
     " hex_bits_24_backwards s = (
   (case  ((hex_bits_24_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 24 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 486:2 - 488:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 486:2 - 488:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_25_forwards_matches : mword ty25 -> bool\<close>\<close>

definition hex_bits_25_forwards_matches  :: "(25)Word.word \<Rightarrow> bool "  where 
     " hex_bits_25_forwards_matches bv = ( True )" 
  for  bv  :: "(25)Word.word "


\<comment> \<open>\<open>val hex_bits_25_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_25_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_25_backwards_matches s = (
      if ((case  ((hex_bits_25_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 25 Word.word * ii))option)) of
          Some ((g__15, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_25_backwards : string -> M (mword ty25)\<close>\<close>

definition hex_bits_25_backwards  :: " string \<Rightarrow>((register_value),((25)Word.word),(exception))monad "  where 
     " hex_bits_25_backwards s = (
   (case  ((hex_bits_25_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 25 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 505:2 - 507:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 505:2 - 507:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_26_forwards_matches : mword ty26 -> bool\<close>\<close>

definition hex_bits_26_forwards_matches  :: "(26)Word.word \<Rightarrow> bool "  where 
     " hex_bits_26_forwards_matches bv = ( True )" 
  for  bv  :: "(26)Word.word "


\<comment> \<open>\<open>val hex_bits_26_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_26_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_26_backwards_matches s = (
      if ((case  ((hex_bits_26_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 26 Word.word * ii))option)) of
          Some ((g__14, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_26_backwards : string -> M (mword ty26)\<close>\<close>

definition hex_bits_26_backwards  :: " string \<Rightarrow>((register_value),((26)Word.word),(exception))monad "  where 
     " hex_bits_26_backwards s = (
   (case  ((hex_bits_26_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 26 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 524:2 - 526:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 524:2 - 526:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_27_forwards_matches : mword ty27 -> bool\<close>\<close>

definition hex_bits_27_forwards_matches  :: "(27)Word.word \<Rightarrow> bool "  where 
     " hex_bits_27_forwards_matches bv = ( True )" 
  for  bv  :: "(27)Word.word "


\<comment> \<open>\<open>val hex_bits_27_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_27_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_27_backwards_matches s = (
      if ((case  ((hex_bits_27_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 27 Word.word * ii))option)) of
          Some ((g__13, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_27_backwards : string -> M (mword ty27)\<close>\<close>

definition hex_bits_27_backwards  :: " string \<Rightarrow>((register_value),((27)Word.word),(exception))monad "  where 
     " hex_bits_27_backwards s = (
   (case  ((hex_bits_27_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 27 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 543:2 - 545:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 543:2 - 545:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_28_forwards_matches : mword ty28 -> bool\<close>\<close>

definition hex_bits_28_forwards_matches  :: "(28)Word.word \<Rightarrow> bool "  where 
     " hex_bits_28_forwards_matches bv = ( True )" 
  for  bv  :: "(28)Word.word "


\<comment> \<open>\<open>val hex_bits_28_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_28_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_28_backwards_matches s = (
      if ((case  ((hex_bits_28_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 28 Word.word * ii))option)) of
          Some ((g__12, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_28_backwards : string -> M (mword ty28)\<close>\<close>

definition hex_bits_28_backwards  :: " string \<Rightarrow>((register_value),((28)Word.word),(exception))monad "  where 
     " hex_bits_28_backwards s = (
   (case  ((hex_bits_28_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 28 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 562:2 - 564:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 562:2 - 564:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_29_forwards_matches : mword ty29 -> bool\<close>\<close>

definition hex_bits_29_forwards_matches  :: "(29)Word.word \<Rightarrow> bool "  where 
     " hex_bits_29_forwards_matches bv = ( True )" 
  for  bv  :: "(29)Word.word "


\<comment> \<open>\<open>val hex_bits_29_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_29_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_29_backwards_matches s = (
      if ((case  ((hex_bits_29_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 29 Word.word * ii))option)) of
          Some ((g__11, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_29_backwards : string -> M (mword ty29)\<close>\<close>

definition hex_bits_29_backwards  :: " string \<Rightarrow>((register_value),((29)Word.word),(exception))monad "  where 
     " hex_bits_29_backwards s = (
   (case  ((hex_bits_29_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 29 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 581:2 - 583:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 581:2 - 583:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_30_forwards_matches : mword ty30 -> bool\<close>\<close>

definition hex_bits_30_forwards_matches  :: "(30)Word.word \<Rightarrow> bool "  where 
     " hex_bits_30_forwards_matches bv = ( True )" 
  for  bv  :: "(30)Word.word "


\<comment> \<open>\<open>val hex_bits_30_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_30_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_30_backwards_matches s = (
      if ((case  ((hex_bits_30_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 30 Word.word * ii))option)) of
          Some ((g__10, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_30_backwards : string -> M (mword ty30)\<close>\<close>

definition hex_bits_30_backwards  :: " string \<Rightarrow>((register_value),((30)Word.word),(exception))monad "  where 
     " hex_bits_30_backwards s = (
   (case  ((hex_bits_30_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 30 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 600:2 - 602:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 600:2 - 602:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_31_forwards_matches : mword ty31 -> bool\<close>\<close>

definition hex_bits_31_forwards_matches  :: "(31)Word.word \<Rightarrow> bool "  where 
     " hex_bits_31_forwards_matches bv = ( True )" 
  for  bv  :: "(31)Word.word "


\<comment> \<open>\<open>val hex_bits_31_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_31_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_31_backwards_matches s = (
      if ((case  ((hex_bits_31_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 31 Word.word * ii))option)) of
          Some ((g__9, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_31_backwards : string -> M (mword ty31)\<close>\<close>

definition hex_bits_31_backwards  :: " string \<Rightarrow>((register_value),((31)Word.word),(exception))monad "  where 
     " hex_bits_31_backwards s = (
   (case  ((hex_bits_31_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 31 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 619:2 - 621:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 619:2 - 621:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_32_forwards_matches : mword ty32 -> bool\<close>\<close>

definition hex_bits_32_forwards_matches  :: "(32)Word.word \<Rightarrow> bool "  where 
     " hex_bits_32_forwards_matches bv = ( True )" 
  for  bv  :: "(32)Word.word "


\<comment> \<open>\<open>val hex_bits_32_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_32_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_32_backwards_matches s = (
      if ((case  ((hex_bits_32_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 32 Word.word * ii))option)) of
          Some ((g__8, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_32_backwards : string -> M (mword ty32)\<close>\<close>

definition hex_bits_32_backwards  :: " string \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " hex_bits_32_backwards s = (
   (case  ((hex_bits_32_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 32 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 638:2 - 640:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 638:2 - 640:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_33_forwards_matches : mword ty33 -> bool\<close>\<close>

definition hex_bits_33_forwards_matches  :: "(33)Word.word \<Rightarrow> bool "  where 
     " hex_bits_33_forwards_matches bv = ( True )" 
  for  bv  :: "(33)Word.word "


\<comment> \<open>\<open>val hex_bits_33_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_33_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_33_backwards_matches s = (
      if ((case  ((hex_bits_33_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 33 Word.word * ii))option)) of
          Some ((g__7, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_33_backwards : string -> M (mword ty33)\<close>\<close>

definition hex_bits_33_backwards  :: " string \<Rightarrow>((register_value),((33)Word.word),(exception))monad "  where 
     " hex_bits_33_backwards s = (
   (case  ((hex_bits_33_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 33 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 657:2 - 659:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 657:2 - 659:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_48_forwards_matches : mword ty48 -> bool\<close>\<close>

definition hex_bits_48_forwards_matches  :: "(48)Word.word \<Rightarrow> bool "  where 
     " hex_bits_48_forwards_matches bv = ( True )" 
  for  bv  :: "(48)Word.word "


\<comment> \<open>\<open>val hex_bits_48_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_48_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_48_backwards_matches s = (
      if ((case  ((hex_bits_48_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 48 Word.word * ii))option)) of
          Some ((g__6, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_48_backwards : string -> M (mword ty48)\<close>\<close>

definition hex_bits_48_backwards  :: " string \<Rightarrow>((register_value),((48)Word.word),(exception))monad "  where 
     " hex_bits_48_backwards s = (
   (case  ((hex_bits_48_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 48 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 676:2 - 678:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 676:2 - 678:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_64_forwards_matches : mword ty64 -> bool\<close>\<close>

definition hex_bits_64_forwards_matches  :: "(64)Word.word \<Rightarrow> bool "  where 
     " hex_bits_64_forwards_matches bv = ( True )" 
  for  bv  :: "(64)Word.word "


\<comment> \<open>\<open>val hex_bits_64_backwards_matches : string -> bool\<close>\<close>

definition hex_bits_64_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " hex_bits_64_backwards_matches s = (
      if ((case  ((hex_bits_64_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 64 Word.word * ii))option)) of
          Some ((g__5, n)) => if (((n = ((string_length s))))) then True else False
        | _ => False
        )) then
        True
      else False )" 
  for  s  :: " string "


\<comment> \<open>\<open>val hex_bits_64_backwards : string -> M (mword ty64)\<close>\<close>

definition hex_bits_64_backwards  :: " string \<Rightarrow>((register_value),((64)Word.word),(exception))monad "  where 
     " hex_bits_64_backwards s = (
   (case  ((hex_bits_64_matches_prefix 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict s  ::  (( 64 Word.word * ii))option)) of
     Some ((bv, n)) =>
      if (((n = ((string_length s))))) then return bv
      else
        assert_exp False (''Pattern match failure at model/prelude_mapping.sail 695:2 - 697:3'') \<then>
        exit0 () 
   | _ =>
      assert_exp False (''Pattern match failure at model/prelude_mapping.sail 695:2 - 697:3'') \<then>
      exit0 () 
   ))" 
  for  s  :: " string "


definition default_meta  :: " unit "  where 
     " default_meta = ( ()  )"


\<comment> \<open>\<open>val __WriteRAM_Meta : mword ty32 -> integer -> unit -> M unit\<close>\<close>

definition WriteRAM_Meta  :: "(32)Word.word \<Rightarrow> int \<Rightarrow> unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " WriteRAM_Meta addr width meta = ( return ()  )" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  meta  :: " unit "


\<comment> \<open>\<open>val __ReadRAM_Meta : mword ty32 -> integer -> M unit\<close>\<close>

definition ReadRAM_Meta  :: "(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " ReadRAM_Meta addr width = ( return ()  )" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val write_ram : forall 'int8_times_n. Size 'int8_times_n => write_kind -> mword ty32 -> integer -> mword 'int8_times_n -> unit -> M bool\<close>\<close>

definition write_ram  :: " write_kind \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " write_ram wk addr width data meta = (
   write_mem instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict wk (( 32 :: int)::ii) addr width data \<bind> (\<lambda> (ret :: bool) . 
   (if ret then WriteRAM_Meta addr width meta else return () ) \<then> return ret))" 
  for  wk  :: " write_kind " 
  and  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word " 
  and  meta  :: " unit "


\<comment> \<open>\<open>val write_ram_ea : write_kind -> mword ty32 -> integer -> M unit\<close>\<close>

definition write_ram_ea  :: " write_kind \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " write_ram_ea wk addr width = ( write_mem_ea 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict wk (( 32 :: int)::ii) addr width )" 
  for  wk  :: " write_kind " 
  and  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val read_ram : forall 'int8_times_n. Size 'int8_times_n => read_kind -> mword ty32 -> integer -> M (mword 'int8_times_n)\<close>\<close>

definition read_ram  :: " read_kind \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),(('int8_times_n::len)Word.word),(exception))monad "  where 
     " read_ram rk addr width = ( (read_mem 
  instance_Sail2_values_Bitvector_Machine_word_mword_dict instance_Sail2_values_Bitvector_Machine_word_mword_dict rk (( 32 :: int)::ii) addr width  :: (( 'int8_times_n::len)Word.word) M))" 
  for  rk  :: " read_kind " 
  and  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val __TraceMemoryWrite : forall 'm 'int8_times_n. Size 'm, Size 'int8_times_n => integer -> mword 'm -> mword 'int8_times_n -> unit\<close>\<close>

\<comment> \<open>\<open>val __TraceMemoryRead : forall 'm 'int8_times_n. Size 'm, Size 'int8_times_n => integer -> mword 'm -> mword 'int8_times_n -> unit\<close>\<close>

definition xlen_val  :: " int "  where 
     " xlen_val = ( (( 32 :: int)::ii))"


definition xlen_max_unsigned  :: " int "  where 
     " xlen_max_unsigned = ( ((pow2 (( 32 :: int)::ii))) - (( 1 :: int)::ii))"


definition xlen_max_signed  :: " int "  where 
     " xlen_max_signed = ( ((pow2 (((( 32 :: int)::ii) - (( 1 :: int)::ii))))) - (( 1 :: int)::ii))"


definition xlen_min_signed  :: " int "  where 
     " xlen_min_signed = ( (( 0 :: int)::ii) - ((pow2 (((( 32 :: int)::ii) - (( 1 :: int)::ii))))))"


\<comment> \<open>\<open>val regidx_to_regno : mword ty5 -> integer\<close>\<close>

definition regidx_to_regno  :: "(5)Word.word \<Rightarrow> int "  where 
     " regidx_to_regno b = (
   (let r = (Word.uint b) in
   r))" 
  for  b  :: "(5)Word.word "


\<comment> \<open>\<open>val creg2reg_idx : mword ty3 -> mword ty5\<close>\<close>

definition creg2reg_idx  :: "(3)Word.word \<Rightarrow>(5)Word.word "  where 
     " creg2reg_idx creg = ( (concat_vec (vec_of_bits [B0,B1]  ::  2 Word.word) creg  ::  5 Word.word))" 
  for  creg  :: "(3)Word.word "


definition zreg  :: "(5)Word.word "  where 
     " zreg = ( (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))"


definition ra  :: "(5)Word.word "  where 
     " ra = ( (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word))"


definition sp  :: "(5)Word.word "  where 
     " sp = ( (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word))"


\<comment> \<open>\<open>val Architecture_of_num : integer -> Architecture\<close>\<close>

definition Architecture_of_num  :: " int \<Rightarrow> Architecture "  where 
     " Architecture_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then RV32
   else if (((p00 = (( 1 :: int)::ii)))) then RV64
   else RV128))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_Architecture : Architecture -> integer\<close>\<close>

fun num_of_Architecture  :: " Architecture \<Rightarrow> int "  where 
     " num_of_Architecture RV32 = ( (( 0 :: int)::ii))"
|" num_of_Architecture RV64 = ( (( 1 :: int)::ii))"
|" num_of_Architecture RV128 = ( (( 2 :: int)::ii))"


\<comment> \<open>\<open>val architecture : mword ty2 -> maybe Architecture\<close>\<close>

definition architecture  :: "(2)Word.word \<Rightarrow>(Architecture)option "  where 
     " architecture a = (
   (let b__0 = a in
   if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then Some RV32
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then Some RV64
   else if (((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then Some RV128
   else None))" 
  for  a  :: "(2)Word.word "


\<comment> \<open>\<open>val arch_to_bits : Architecture -> mword ty2\<close>\<close>

fun arch_to_bits  :: " Architecture \<Rightarrow>(2)Word.word "  where 
     " arch_to_bits RV32 = ( (vec_of_bits [B0,B1]  ::  2 Word.word))"
|" arch_to_bits RV64 = ( (vec_of_bits [B1,B0]  ::  2 Word.word))"
|" arch_to_bits RV128 = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


\<comment> \<open>\<open>val Privilege_of_num : integer -> Privilege\<close>\<close>

definition Privilege_of_num  :: " int \<Rightarrow> Privilege "  where 
     " Privilege_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then User
   else if (((p00 = (( 1 :: int)::ii)))) then Supervisor
   else Machine))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_Privilege : Privilege -> integer\<close>\<close>

fun num_of_Privilege  :: " Privilege \<Rightarrow> int "  where 
     " num_of_Privilege User = ( (( 0 :: int)::ii))"
|" num_of_Privilege Supervisor = ( (( 1 :: int)::ii))"
|" num_of_Privilege Machine = ( (( 2 :: int)::ii))"


\<comment> \<open>\<open>val privLevel_to_bits : Privilege -> mword ty2\<close>\<close>

fun privLevel_to_bits  :: " Privilege \<Rightarrow>(2)Word.word "  where 
     " privLevel_to_bits User = ( (vec_of_bits [B0,B0]  ::  2 Word.word))"
|" privLevel_to_bits Supervisor = ( (vec_of_bits [B0,B1]  ::  2 Word.word))"
|" privLevel_to_bits Machine = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


\<comment> \<open>\<open>val privLevel_of_bits : mword ty2 -> M Privilege\<close>\<close>

definition privLevel_of_bits  :: "(2)Word.word \<Rightarrow>((register_value),(Privilege),(exception))monad "  where 
     " privLevel_of_bits p = (
   (let b__0 = p in
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return User
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return Supervisor
   else if (((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then return Machine
   else assert_exp False (''Pattern match failure at model/riscv_types.sail 78:2 - 82:3'') \<then> exit0 () ))" 
  for  p  :: "(2)Word.word "


\<comment> \<open>\<open>val privLevel_to_str : Privilege -> string\<close>\<close>

fun privLevel_to_str  :: " Privilege \<Rightarrow> string "  where 
     " privLevel_to_str User = ( (''U''))"
|" privLevel_to_str Supervisor = ( (''S''))"
|" privLevel_to_str Machine = ( (''M''))"


\<comment> \<open>\<open>val print_insn : ast -> M string\<close>\<close>

\<comment> \<open>\<open>val Retired_of_num : integer -> Retired\<close>\<close>

definition Retired_of_num  :: " int \<Rightarrow> Retired "  where 
     " Retired_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then RETIRE_SUCCESS
   else RETIRE_FAIL))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_Retired : Retired -> integer\<close>\<close>

fun num_of_Retired  :: " Retired \<Rightarrow> int "  where 
     " num_of_Retired RETIRE_SUCCESS = ( (( 0 :: int)::ii))"
|" num_of_Retired RETIRE_FAIL = ( (( 1 :: int)::ii))"


\<comment> \<open>\<open>val AccessType_of_num : integer -> AccessType\<close>\<close>

definition AccessType_of_num  :: " int \<Rightarrow> AccessType "  where 
     " AccessType_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then Read
   else if (((p00 = (( 1 :: int)::ii)))) then Write
   else if (((p00 = (( 2 :: int)::ii)))) then ReadWrite
   else Execute))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_AccessType : AccessType -> integer\<close>\<close>

fun num_of_AccessType  :: " AccessType \<Rightarrow> int "  where 
     " num_of_AccessType Read = ( (( 0 :: int)::ii))"
|" num_of_AccessType Write = ( (( 1 :: int)::ii))"
|" num_of_AccessType ReadWrite = ( (( 2 :: int)::ii))"
|" num_of_AccessType Execute = ( (( 3 :: int)::ii))"


\<comment> \<open>\<open>val accessType_to_str : AccessType -> string\<close>\<close>

fun accessType_to_str  :: " AccessType \<Rightarrow> string "  where 
     " accessType_to_str Read = ( (''R''))"
|" accessType_to_str Write = ( (''W''))"
|" accessType_to_str ReadWrite = ( (''RW''))"
|" accessType_to_str Execute = ( (''X''))"


\<comment> \<open>\<open>val word_width_of_num : integer -> word_width\<close>\<close>

definition word_width_of_num  :: " int \<Rightarrow> word_width "  where 
     " word_width_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then BYTE
   else if (((p00 = (( 1 :: int)::ii)))) then HALF
   else if (((p00 = (( 2 :: int)::ii)))) then WORD
   else DOUBLE))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_word_width : word_width -> integer\<close>\<close>

fun num_of_word_width  :: " word_width \<Rightarrow> int "  where 
     " num_of_word_width BYTE = ( (( 0 :: int)::ii))"
|" num_of_word_width HALF = ( (( 1 :: int)::ii))"
|" num_of_word_width WORD = ( (( 2 :: int)::ii))"
|" num_of_word_width DOUBLE = ( (( 3 :: int)::ii))"


\<comment> \<open>\<open>val InterruptType_of_num : integer -> InterruptType\<close>\<close>

definition InterruptType_of_num  :: " int \<Rightarrow> InterruptType "  where 
     " InterruptType_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then I_U_Software
   else if (((p00 = (( 1 :: int)::ii)))) then I_S_Software
   else if (((p00 = (( 2 :: int)::ii)))) then I_M_Software
   else if (((p00 = (( 3 :: int)::ii)))) then I_U_Timer
   else if (((p00 = (( 4 :: int)::ii)))) then I_S_Timer
   else if (((p00 = (( 5 :: int)::ii)))) then I_M_Timer
   else if (((p00 = (( 6 :: int)::ii)))) then I_U_External
   else if (((p00 = (( 7 :: int)::ii)))) then I_S_External
   else I_M_External))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_InterruptType : InterruptType -> integer\<close>\<close>

fun num_of_InterruptType  :: " InterruptType \<Rightarrow> int "  where 
     " num_of_InterruptType I_U_Software = ( (( 0 :: int)::ii))"
|" num_of_InterruptType I_S_Software = ( (( 1 :: int)::ii))"
|" num_of_InterruptType I_M_Software = ( (( 2 :: int)::ii))"
|" num_of_InterruptType I_U_Timer = ( (( 3 :: int)::ii))"
|" num_of_InterruptType I_S_Timer = ( (( 4 :: int)::ii))"
|" num_of_InterruptType I_M_Timer = ( (( 5 :: int)::ii))"
|" num_of_InterruptType I_U_External = ( (( 6 :: int)::ii))"
|" num_of_InterruptType I_S_External = ( (( 7 :: int)::ii))"
|" num_of_InterruptType I_M_External = ( (( 8 :: int)::ii))"


\<comment> \<open>\<open>val interruptType_to_bits : InterruptType -> mword ty8\<close>\<close>

fun interruptType_to_bits  :: " InterruptType \<Rightarrow>(8)Word.word "  where 
     " interruptType_to_bits I_U_Software = ( (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))"
|" interruptType_to_bits I_S_Software = ( (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1]  ::  8 Word.word))"
|" interruptType_to_bits I_M_Software = ( (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B1]  ::  8 Word.word))"
|" interruptType_to_bits I_U_Timer = ( (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0]  ::  8 Word.word))"
|" interruptType_to_bits I_S_Timer = ( (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B1]  ::  8 Word.word))"
|" interruptType_to_bits I_M_Timer = ( (vec_of_bits [B0,B0,B0,B0,B0,B1,B1,B1]  ::  8 Word.word))"
|" interruptType_to_bits I_U_External = ( (vec_of_bits [B0,B0,B0,B0,B1,B0,B0,B0]  ::  8 Word.word))"
|" interruptType_to_bits I_S_External = ( (vec_of_bits [B0,B0,B0,B0,B1,B0,B0,B1]  ::  8 Word.word))"
|" interruptType_to_bits I_M_External = ( (vec_of_bits [B0,B0,B0,B0,B1,B0,B1,B1]  ::  8 Word.word))"


\<comment> \<open>\<open>val ExceptionType_of_num : integer -> ExceptionType\<close>\<close>

definition ExceptionType_of_num  :: " int \<Rightarrow> ExceptionType "  where 
     " ExceptionType_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then E_Fetch_Addr_Align
   else if (((p00 = (( 1 :: int)::ii)))) then E_Fetch_Access_Fault
   else if (((p00 = (( 2 :: int)::ii)))) then E_Illegal_Instr
   else if (((p00 = (( 3 :: int)::ii)))) then E_Breakpoint
   else if (((p00 = (( 4 :: int)::ii)))) then E_Load_Addr_Align
   else if (((p00 = (( 5 :: int)::ii)))) then E_Load_Access_Fault
   else if (((p00 = (( 6 :: int)::ii)))) then E_SAMO_Addr_Align
   else if (((p00 = (( 7 :: int)::ii)))) then E_SAMO_Access_Fault
   else if (((p00 = (( 8 :: int)::ii)))) then E_U_EnvCall
   else if (((p00 = (( 9 :: int)::ii)))) then E_S_EnvCall
   else if (((p00 = (( 10 :: int)::ii)))) then E_Reserved_10
   else if (((p00 = (( 11 :: int)::ii)))) then E_M_EnvCall
   else if (((p00 = (( 12 :: int)::ii)))) then E_Fetch_Page_Fault
   else if (((p00 = (( 13 :: int)::ii)))) then E_Load_Page_Fault
   else if (((p00 = (( 14 :: int)::ii)))) then E_Reserved_14
   else if (((p00 = (( 15 :: int)::ii)))) then E_SAMO_Page_Fault
   else E_CHERI))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_ExceptionType : ExceptionType -> integer\<close>\<close>

fun num_of_ExceptionType  :: " ExceptionType \<Rightarrow> int "  where 
     " num_of_ExceptionType E_Fetch_Addr_Align = ( (( 0 :: int)::ii))"
|" num_of_ExceptionType E_Fetch_Access_Fault = ( (( 1 :: int)::ii))"
|" num_of_ExceptionType E_Illegal_Instr = ( (( 2 :: int)::ii))"
|" num_of_ExceptionType E_Breakpoint = ( (( 3 :: int)::ii))"
|" num_of_ExceptionType E_Load_Addr_Align = ( (( 4 :: int)::ii))"
|" num_of_ExceptionType E_Load_Access_Fault = ( (( 5 :: int)::ii))"
|" num_of_ExceptionType E_SAMO_Addr_Align = ( (( 6 :: int)::ii))"
|" num_of_ExceptionType E_SAMO_Access_Fault = ( (( 7 :: int)::ii))"
|" num_of_ExceptionType E_U_EnvCall = ( (( 8 :: int)::ii))"
|" num_of_ExceptionType E_S_EnvCall = ( (( 9 :: int)::ii))"
|" num_of_ExceptionType E_Reserved_10 = ( (( 10 :: int)::ii))"
|" num_of_ExceptionType E_M_EnvCall = ( (( 11 :: int)::ii))"
|" num_of_ExceptionType E_Fetch_Page_Fault = ( (( 12 :: int)::ii))"
|" num_of_ExceptionType E_Load_Page_Fault = ( (( 13 :: int)::ii))"
|" num_of_ExceptionType E_Reserved_14 = ( (( 14 :: int)::ii))"
|" num_of_ExceptionType E_SAMO_Page_Fault = ( (( 15 :: int)::ii))"
|" num_of_ExceptionType E_CHERI = ( (( 16 :: int)::ii))"


\<comment> \<open>\<open>val exceptionType_to_bits : ExceptionType -> mword ty8\<close>\<close>

fun exceptionType_to_bits  :: " ExceptionType \<Rightarrow>(8)Word.word "  where 
     " exceptionType_to_bits E_Fetch_Addr_Align = ( (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))"
|" exceptionType_to_bits E_Fetch_Access_Fault = ( (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1]  ::  8 Word.word))"
|" exceptionType_to_bits E_Illegal_Instr = ( (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B0]  ::  8 Word.word))"
|" exceptionType_to_bits E_Breakpoint = ( (vec_of_bits [B0,B0,B0,B0,B0,B0,B1,B1]  ::  8 Word.word))"
|" exceptionType_to_bits E_Load_Addr_Align = ( (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0]  ::  8 Word.word))"
|" exceptionType_to_bits E_Load_Access_Fault = ( (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B1]  ::  8 Word.word))"
|" exceptionType_to_bits E_SAMO_Addr_Align = ( (vec_of_bits [B0,B0,B0,B0,B0,B1,B1,B0]  ::  8 Word.word))"
|" exceptionType_to_bits E_SAMO_Access_Fault = ( (vec_of_bits [B0,B0,B0,B0,B0,B1,B1,B1]  ::  8 Word.word))"
|" exceptionType_to_bits E_U_EnvCall = ( (vec_of_bits [B0,B0,B0,B0,B1,B0,B0,B0]  ::  8 Word.word))"
|" exceptionType_to_bits E_S_EnvCall = ( (vec_of_bits [B0,B0,B0,B0,B1,B0,B0,B1]  ::  8 Word.word))"
|" exceptionType_to_bits E_Reserved_10 = ( (vec_of_bits [B0,B0,B0,B0,B1,B0,B1,B0]  ::  8 Word.word))"
|" exceptionType_to_bits E_M_EnvCall = ( (vec_of_bits [B0,B0,B0,B0,B1,B0,B1,B1]  ::  8 Word.word))"
|" exceptionType_to_bits E_Fetch_Page_Fault = ( (vec_of_bits [B0,B0,B0,B0,B1,B1,B0,B0]  ::  8 Word.word))"
|" exceptionType_to_bits E_Load_Page_Fault = ( (vec_of_bits [B0,B0,B0,B0,B1,B1,B0,B1]  ::  8 Word.word))"
|" exceptionType_to_bits E_Reserved_14 = ( (vec_of_bits [B0,B0,B0,B0,B1,B1,B1,B0]  ::  8 Word.word))"
|" exceptionType_to_bits E_SAMO_Page_Fault = ( (vec_of_bits [B0,B0,B0,B0,B1,B1,B1,B1]  ::  8 Word.word))"
|" exceptionType_to_bits E_CHERI = ( (vec_of_bits [B0,B0,B1,B0,B0,B0,B0,B0]  ::  8 Word.word))"


\<comment> \<open>\<open>val exceptionType_to_str : ExceptionType -> string\<close>\<close>

fun exceptionType_to_str  :: " ExceptionType \<Rightarrow> string "  where 
     " exceptionType_to_str E_Fetch_Addr_Align = ( (''misaligned-fetch''))"
|" exceptionType_to_str E_Fetch_Access_Fault = ( (''fetch-access-fault''))"
|" exceptionType_to_str E_Illegal_Instr = ( (''illegal-instruction''))"
|" exceptionType_to_str E_Breakpoint = ( (''breakpoint''))"
|" exceptionType_to_str E_Load_Addr_Align = ( (''misaligned-load''))"
|" exceptionType_to_str E_Load_Access_Fault = ( (''load-access-fault''))"
|" exceptionType_to_str E_SAMO_Addr_Align = ( (''misaliged-store/amo''))"
|" exceptionType_to_str E_SAMO_Access_Fault = ( (''store/amo-access-fault''))"
|" exceptionType_to_str E_U_EnvCall = ( (''u-call''))"
|" exceptionType_to_str E_S_EnvCall = ( (''s-call''))"
|" exceptionType_to_str E_Reserved_10 = ( (''reserved-0''))"
|" exceptionType_to_str E_M_EnvCall = ( (''m-call''))"
|" exceptionType_to_str E_Fetch_Page_Fault = ( (''fetch-page-fault''))"
|" exceptionType_to_str E_Load_Page_Fault = ( (''load-page-fault''))"
|" exceptionType_to_str E_Reserved_14 = ( (''reserved-1''))"
|" exceptionType_to_str E_SAMO_Page_Fault = ( (''store/amo-page-fault''))"
|" exceptionType_to_str E_CHERI = ( (''CHERI''))"


\<comment> \<open>\<open>val not_implemented : forall 'a. string -> M 'a\<close>\<close>

definition not_implemented  :: " string \<Rightarrow>((register_value),'a,(exception))monad "  where 
     " not_implemented message = ( throw (Error_not_implemented message))" 
  for  message  :: " string "


\<comment> \<open>\<open>val internal_error : forall 'a. string -> M 'a\<close>\<close>

definition internal_error  :: " string \<Rightarrow>((register_value),'a,(exception))monad "  where 
     " internal_error s = ( assert_exp False s \<then> exit0 ()  )" 
  for  s  :: " string "


\<comment> \<open>\<open>val TrapVectorMode_of_num : integer -> TrapVectorMode\<close>\<close>

definition TrapVectorMode_of_num  :: " int \<Rightarrow> TrapVectorMode "  where 
     " TrapVectorMode_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then TV_Direct
   else if (((p00 = (( 1 :: int)::ii)))) then TV_Vector
   else TV_Reserved))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_TrapVectorMode : TrapVectorMode -> integer\<close>\<close>

fun num_of_TrapVectorMode  :: " TrapVectorMode \<Rightarrow> int "  where 
     " num_of_TrapVectorMode TV_Direct = ( (( 0 :: int)::ii))"
|" num_of_TrapVectorMode TV_Vector = ( (( 1 :: int)::ii))"
|" num_of_TrapVectorMode TV_Reserved = ( (( 2 :: int)::ii))"


\<comment> \<open>\<open>val trapVectorMode_of_bits : mword ty2 -> TrapVectorMode\<close>\<close>

definition trapVectorMode_of_bits  :: "(2)Word.word \<Rightarrow> TrapVectorMode "  where 
     " trapVectorMode_of_bits m = (
   (let b__0 = m in
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then TV_Direct
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then TV_Vector
   else TV_Reserved))" 
  for  m  :: "(2)Word.word "


\<comment> \<open>\<open>val ExtStatus_of_num : integer -> ExtStatus\<close>\<close>

definition ExtStatus_of_num  :: " int \<Rightarrow> ExtStatus "  where 
     " ExtStatus_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then Off
   else if (((p00 = (( 1 :: int)::ii)))) then Initial
   else if (((p00 = (( 2 :: int)::ii)))) then Clean
   else Dirty))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_ExtStatus : ExtStatus -> integer\<close>\<close>

fun num_of_ExtStatus  :: " ExtStatus \<Rightarrow> int "  where 
     " num_of_ExtStatus Off = ( (( 0 :: int)::ii))"
|" num_of_ExtStatus Initial = ( (( 1 :: int)::ii))"
|" num_of_ExtStatus Clean = ( (( 2 :: int)::ii))"
|" num_of_ExtStatus Dirty = ( (( 3 :: int)::ii))"


\<comment> \<open>\<open>val extStatus_to_bits : ExtStatus -> mword ty2\<close>\<close>

fun extStatus_to_bits  :: " ExtStatus \<Rightarrow>(2)Word.word "  where 
     " extStatus_to_bits Off = ( (vec_of_bits [B0,B0]  ::  2 Word.word))"
|" extStatus_to_bits Initial = ( (vec_of_bits [B0,B1]  ::  2 Word.word))"
|" extStatus_to_bits Clean = ( (vec_of_bits [B1,B0]  ::  2 Word.word))"
|" extStatus_to_bits Dirty = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


\<comment> \<open>\<open>val extStatus_of_bits : mword ty2 -> M ExtStatus\<close>\<close>

definition extStatus_of_bits  :: "(2)Word.word \<Rightarrow>((register_value),(ExtStatus),(exception))monad "  where 
     " extStatus_of_bits e = (
   (let b__0 = e in
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return Off
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return Initial
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then return Clean
   else if (((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then return Dirty
   else assert_exp False (''Pattern match failure at model/riscv_types.sail 264:2 - 269:3'') \<then> exit0 () ))" 
  for  e  :: "(2)Word.word "


\<comment> \<open>\<open>val SATPMode_of_num : integer -> SATPMode\<close>\<close>

definition SATPMode_of_num  :: " int \<Rightarrow> SATPMode "  where 
     " SATPMode_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then Sbare
   else if (((p00 = (( 1 :: int)::ii)))) then Sv32
   else if (((p00 = (( 2 :: int)::ii)))) then Sv39
   else Sv48))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_SATPMode : SATPMode -> integer\<close>\<close>

fun num_of_SATPMode  :: " SATPMode \<Rightarrow> int "  where 
     " num_of_SATPMode Sbare = ( (( 0 :: int)::ii))"
|" num_of_SATPMode Sv32 = ( (( 1 :: int)::ii))"
|" num_of_SATPMode Sv39 = ( (( 2 :: int)::ii))"
|" num_of_SATPMode Sv48 = ( (( 3 :: int)::ii))"


\<comment> \<open>\<open>val satp64Mode_of_bits : Architecture -> mword ty4 -> maybe SATPMode\<close>\<close>

definition satp64Mode_of_bits  :: " Architecture \<Rightarrow>(4)Word.word \<Rightarrow>(SATPMode)option "  where 
     " satp64Mode_of_bits (g__4 :: Architecture) (b__0 :: satp_mode) = (
      if (((b__0 = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) then Some Sbare
      else
        (case  (g__4, b__0) of
          (RV32, b__0) =>
           if (((b__0 = (vec_of_bits [B0,B0,B0,B1]  ::  4 Word.word)))) then Some Sv32
           else (case  (RV32, b__0) of   (_, _) => None )
        | (RV64, b__0) =>
           if (((b__0 = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) then Some Sv39
           else if (((b__0 = (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)))) then Some Sv48
           else (case  (RV64, b__0) of   (_, _) => None )
        | (_, _) => None
        ))" 
  for  g__4  :: " Architecture " 
  and  b__0  :: "(4)Word.word "


\<comment> \<open>\<open>val uop_of_num : integer -> uop\<close>\<close>

definition uop_of_num  :: " int \<Rightarrow> uop "  where 
     " uop_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then RISCV_LUI
   else RISCV_AUIPC))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_uop : uop -> integer\<close>\<close>

fun num_of_uop  :: " uop \<Rightarrow> int "  where 
     " num_of_uop RISCV_LUI = ( (( 0 :: int)::ii))"
|" num_of_uop RISCV_AUIPC = ( (( 1 :: int)::ii))"


\<comment> \<open>\<open>val bop_of_num : integer -> bop\<close>\<close>

definition bop_of_num  :: " int \<Rightarrow> bop "  where 
     " bop_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then RISCV_BEQ
   else if (((p00 = (( 1 :: int)::ii)))) then RISCV_BNE
   else if (((p00 = (( 2 :: int)::ii)))) then RISCV_BLT
   else if (((p00 = (( 3 :: int)::ii)))) then RISCV_BGE
   else if (((p00 = (( 4 :: int)::ii)))) then RISCV_BLTU
   else RISCV_BGEU))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_bop : bop -> integer\<close>\<close>

fun num_of_bop  :: " bop \<Rightarrow> int "  where 
     " num_of_bop RISCV_BEQ = ( (( 0 :: int)::ii))"
|" num_of_bop RISCV_BNE = ( (( 1 :: int)::ii))"
|" num_of_bop RISCV_BLT = ( (( 2 :: int)::ii))"
|" num_of_bop RISCV_BGE = ( (( 3 :: int)::ii))"
|" num_of_bop RISCV_BLTU = ( (( 4 :: int)::ii))"
|" num_of_bop RISCV_BGEU = ( (( 5 :: int)::ii))"


\<comment> \<open>\<open>val iop_of_num : integer -> iop\<close>\<close>

definition iop_of_num  :: " int \<Rightarrow> iop "  where 
     " iop_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then RISCV_ADDI
   else if (((p00 = (( 1 :: int)::ii)))) then RISCV_SLTI
   else if (((p00 = (( 2 :: int)::ii)))) then RISCV_SLTIU
   else if (((p00 = (( 3 :: int)::ii)))) then RISCV_XORI
   else if (((p00 = (( 4 :: int)::ii)))) then RISCV_ORI
   else RISCV_ANDI))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_iop : iop -> integer\<close>\<close>

fun num_of_iop  :: " iop \<Rightarrow> int "  where 
     " num_of_iop RISCV_ADDI = ( (( 0 :: int)::ii))"
|" num_of_iop RISCV_SLTI = ( (( 1 :: int)::ii))"
|" num_of_iop RISCV_SLTIU = ( (( 2 :: int)::ii))"
|" num_of_iop RISCV_XORI = ( (( 3 :: int)::ii))"
|" num_of_iop RISCV_ORI = ( (( 4 :: int)::ii))"
|" num_of_iop RISCV_ANDI = ( (( 5 :: int)::ii))"


\<comment> \<open>\<open>val sop_of_num : integer -> sop\<close>\<close>

definition sop_of_num  :: " int \<Rightarrow> sop "  where 
     " sop_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then RISCV_SLLI
   else if (((p00 = (( 1 :: int)::ii)))) then RISCV_SRLI
   else RISCV_SRAI))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_sop : sop -> integer\<close>\<close>

fun num_of_sop  :: " sop \<Rightarrow> int "  where 
     " num_of_sop RISCV_SLLI = ( (( 0 :: int)::ii))"
|" num_of_sop RISCV_SRLI = ( (( 1 :: int)::ii))"
|" num_of_sop RISCV_SRAI = ( (( 2 :: int)::ii))"


\<comment> \<open>\<open>val rop_of_num : integer -> rop\<close>\<close>

definition rop_of_num  :: " int \<Rightarrow> rop "  where 
     " rop_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then RISCV_ADD
   else if (((p00 = (( 1 :: int)::ii)))) then RISCV_SUB
   else if (((p00 = (( 2 :: int)::ii)))) then RISCV_SLL
   else if (((p00 = (( 3 :: int)::ii)))) then RISCV_SLT
   else if (((p00 = (( 4 :: int)::ii)))) then RISCV_SLTU
   else if (((p00 = (( 5 :: int)::ii)))) then RISCV_XOR
   else if (((p00 = (( 6 :: int)::ii)))) then RISCV_SRL
   else if (((p00 = (( 7 :: int)::ii)))) then RISCV_SRA
   else if (((p00 = (( 8 :: int)::ii)))) then RISCV_OR
   else RISCV_AND))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_rop : rop -> integer\<close>\<close>

fun num_of_rop  :: " rop \<Rightarrow> int "  where 
     " num_of_rop RISCV_ADD = ( (( 0 :: int)::ii))"
|" num_of_rop RISCV_SUB = ( (( 1 :: int)::ii))"
|" num_of_rop RISCV_SLL = ( (( 2 :: int)::ii))"
|" num_of_rop RISCV_SLT = ( (( 3 :: int)::ii))"
|" num_of_rop RISCV_SLTU = ( (( 4 :: int)::ii))"
|" num_of_rop RISCV_XOR = ( (( 5 :: int)::ii))"
|" num_of_rop RISCV_SRL = ( (( 6 :: int)::ii))"
|" num_of_rop RISCV_SRA = ( (( 7 :: int)::ii))"
|" num_of_rop RISCV_OR = ( (( 8 :: int)::ii))"
|" num_of_rop RISCV_AND = ( (( 9 :: int)::ii))"


\<comment> \<open>\<open>val ropw_of_num : integer -> ropw\<close>\<close>

definition ropw_of_num  :: " int \<Rightarrow> ropw "  where 
     " ropw_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then RISCV_ADDW
   else if (((p00 = (( 1 :: int)::ii)))) then RISCV_SUBW
   else if (((p00 = (( 2 :: int)::ii)))) then RISCV_SLLW
   else if (((p00 = (( 3 :: int)::ii)))) then RISCV_SRLW
   else RISCV_SRAW))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_ropw : ropw -> integer\<close>\<close>

fun num_of_ropw  :: " ropw \<Rightarrow> int "  where 
     " num_of_ropw RISCV_ADDW = ( (( 0 :: int)::ii))"
|" num_of_ropw RISCV_SUBW = ( (( 1 :: int)::ii))"
|" num_of_ropw RISCV_SLLW = ( (( 2 :: int)::ii))"
|" num_of_ropw RISCV_SRLW = ( (( 3 :: int)::ii))"
|" num_of_ropw RISCV_SRAW = ( (( 4 :: int)::ii))"


\<comment> \<open>\<open>val sopw_of_num : integer -> sopw\<close>\<close>

definition sopw_of_num  :: " int \<Rightarrow> sopw "  where 
     " sopw_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then RISCV_SLLIW
   else if (((p00 = (( 1 :: int)::ii)))) then RISCV_SRLIW
   else RISCV_SRAIW))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_sopw : sopw -> integer\<close>\<close>

fun num_of_sopw  :: " sopw \<Rightarrow> int "  where 
     " num_of_sopw RISCV_SLLIW = ( (( 0 :: int)::ii))"
|" num_of_sopw RISCV_SRLIW = ( (( 1 :: int)::ii))"
|" num_of_sopw RISCV_SRAIW = ( (( 2 :: int)::ii))"


\<comment> \<open>\<open>val amoop_of_num : integer -> amoop\<close>\<close>

definition amoop_of_num  :: " int \<Rightarrow> amoop "  where 
     " amoop_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then AMOSWAP
   else if (((p00 = (( 1 :: int)::ii)))) then AMOADD
   else if (((p00 = (( 2 :: int)::ii)))) then AMOXOR
   else if (((p00 = (( 3 :: int)::ii)))) then AMOAND
   else if (((p00 = (( 4 :: int)::ii)))) then AMOOR
   else if (((p00 = (( 5 :: int)::ii)))) then AMOMIN
   else if (((p00 = (( 6 :: int)::ii)))) then AMOMAX
   else if (((p00 = (( 7 :: int)::ii)))) then AMOMINU
   else AMOMAXU))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_amoop : amoop -> integer\<close>\<close>

fun num_of_amoop  :: " amoop \<Rightarrow> int "  where 
     " num_of_amoop AMOSWAP = ( (( 0 :: int)::ii))"
|" num_of_amoop AMOADD = ( (( 1 :: int)::ii))"
|" num_of_amoop AMOXOR = ( (( 2 :: int)::ii))"
|" num_of_amoop AMOAND = ( (( 3 :: int)::ii))"
|" num_of_amoop AMOOR = ( (( 4 :: int)::ii))"
|" num_of_amoop AMOMIN = ( (( 5 :: int)::ii))"
|" num_of_amoop AMOMAX = ( (( 6 :: int)::ii))"
|" num_of_amoop AMOMINU = ( (( 7 :: int)::ii))"
|" num_of_amoop AMOMAXU = ( (( 8 :: int)::ii))"


\<comment> \<open>\<open>val csrop_of_num : integer -> csrop\<close>\<close>

definition csrop_of_num  :: " int \<Rightarrow> csrop "  where 
     " csrop_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then CSRRW
   else if (((p00 = (( 1 :: int)::ii)))) then CSRRS
   else CSRRC))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_csrop : csrop -> integer\<close>\<close>

fun num_of_csrop  :: " csrop \<Rightarrow> int "  where 
     " num_of_csrop CSRRW = ( (( 0 :: int)::ii))"
|" num_of_csrop CSRRS = ( (( 1 :: int)::ii))"
|" num_of_csrop CSRRC = ( (( 2 :: int)::ii))"


\<comment> \<open>\<open>val sep_forwards : unit -> string\<close>\<close>

definition sep_forwards  :: " unit \<Rightarrow> string "  where 
     " sep_forwards _ = (
      string_append ((opt_spc_forwards () ))
        ((string_append ('','') ((string_append ((def_spc_forwards () )) (''''))))))"


\<comment> \<open>\<open>val sep_backwards : string -> M unit\<close>\<close>

\<comment> \<open>\<open>val _s0_ : string -> maybe unit\<close>\<close>

definition s0  :: " string \<Rightarrow>(unit)option "  where 
     " s0 s20 = (
      (case  ((opt_spc_matches_prefix0 s20)) of
        Some ((_, s30)) =>
         (let s41 = (string_drop s20 s30) in
         if ((string_startswith s41 ('',''))) then  
  (case  ((string_drop s41 ((string_length ('',''))))) of
        s50 =>
  (case  ((def_spc_matches_prefix s50)) of
        Some ((_, s61)) =>
  (let p00 = (string_drop s50 s61) in
  if (((p00 = ('''')))) then Some ()  else None)
    | _ => None
  )
  )
         else None)
      | _ => None
      ))" 
  for  s20  :: " string "


definition sep_backwards  :: " string \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " sep_backwards arg1 = (
   (let s70 = arg1 in
   if ((case  ((s0 s70)) of   Some (_) => True | _ => False )) then  
  (case  s0 s70 of (Some (_)) => return ()  )
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val sep_forwards_matches : unit -> bool\<close>\<close>

definition sep_forwards_matches  :: " unit \<Rightarrow> bool "  where 
     " sep_forwards_matches _ = ( True )"


\<comment> \<open>\<open>val sep_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val _s8_ : string -> maybe unit\<close>\<close>

definition s8  :: " string \<Rightarrow>(unit)option "  where 
     " s8 s101 = (
      (case  ((opt_spc_matches_prefix0 s101)) of
        Some ((_, s110)) =>
         (let s121 = (string_drop s101 s110) in
         if ((string_startswith s121 ('',''))) then  
  (case  ((string_drop s121 ((string_length ('',''))))) of
        s130 =>
  (case  ((def_spc_matches_prefix s130)) of
        Some ((_, s141)) =>
  (let p00 = (string_drop s130 s141) in
  if (((p00 = ('''')))) then Some ()  else None)
    | _ => None
  )
  )
         else None)
      | _ => None
      ))" 
  for  s101  :: " string "


definition sep_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " sep_backwards_matches arg1 = (
   (let s150 = arg1 in
   if ((case  ((s8 s150)) of   Some (_) => True | _ => False )) then  
  (case  s8 s150 of (Some (_)) => True )
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val sep_matches_prefix : string -> maybe ((unit * ii))\<close>\<close>

\<comment> \<open>\<open>val _s16_ : string -> maybe string\<close>\<close>

definition s16  :: " string \<Rightarrow>(string)option "  where 
     " s16 s181 = (
      (case  ((opt_spc_matches_prefix0 s181)) of
        Some ((_, s190)) =>
         (let s201 = (string_drop s181 s190) in
         if ((string_startswith s201 ('',''))) then  
  (case  ((string_drop s201 ((string_length ('',''))))) of
        s210 =>
  (case  ((def_spc_matches_prefix s210)) of
        Some ((_, s221)) =>
  (case  ((string_drop s210 s221)) of   s1 => Some s1 )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))" 
  for  s181  :: " string "


definition sep_matches_prefix  :: " string \<Rightarrow>(unit*int)option "  where 
     " sep_matches_prefix arg1 = (
   (let s230 = arg1 in
   if ((case  ((s16 s230)) of   Some (s1) => True | _ => False )) then  
  (case  s16 s230 of
      (Some (s1)) =>
  Some (() , ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bool_bits_forwards : bool -> mword ty1\<close>\<close>

fun bool_bits_forwards  :: " bool \<Rightarrow>(1)Word.word "  where 
     " bool_bits_forwards True = ( (vec_of_bits [B1]  ::  1 Word.word))"
|" bool_bits_forwards False = ( (vec_of_bits [B0]  ::  1 Word.word))"


\<comment> \<open>\<open>val bool_bits_backwards : mword ty1 -> M bool\<close>\<close>

definition bool_bits_backwards  :: "(1)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " bool_bits_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then return True
   else if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bool_bits_forwards_matches : bool -> bool\<close>\<close>

fun bool_bits_forwards_matches  :: " bool \<Rightarrow> bool "  where 
     " bool_bits_forwards_matches True = ( True )"
|" bool_bits_forwards_matches False = ( True )"


\<comment> \<open>\<open>val bool_bits_backwards_matches : mword ty1 -> bool\<close>\<close>

definition bool_bits_backwards_matches  :: "(1)Word.word \<Rightarrow> bool "  where 
     " bool_bits_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then True
   else False))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bool_not_bits_forwards : bool -> mword ty1\<close>\<close>

fun bool_not_bits_forwards  :: " bool \<Rightarrow>(1)Word.word "  where 
     " bool_not_bits_forwards True = ( (vec_of_bits [B0]  ::  1 Word.word))"
|" bool_not_bits_forwards False = ( (vec_of_bits [B1]  ::  1 Word.word))"


\<comment> \<open>\<open>val bool_not_bits_backwards : mword ty1 -> M bool\<close>\<close>

definition bool_not_bits_backwards  :: "(1)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " bool_not_bits_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then return True
   else if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bool_not_bits_forwards_matches : bool -> bool\<close>\<close>

fun bool_not_bits_forwards_matches  :: " bool \<Rightarrow> bool "  where 
     " bool_not_bits_forwards_matches True = ( True )"
|" bool_not_bits_forwards_matches False = ( True )"


\<comment> \<open>\<open>val bool_not_bits_backwards_matches : mword ty1 -> bool\<close>\<close>

definition bool_not_bits_backwards_matches  :: "(1)Word.word \<Rightarrow> bool "  where 
     " bool_not_bits_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then True
   else False))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val size_bits_forwards : word_width -> mword ty2\<close>\<close>

fun size_bits_forwards  :: " word_width \<Rightarrow>(2)Word.word "  where 
     " size_bits_forwards BYTE = ( (vec_of_bits [B0,B0]  ::  2 Word.word))"
|" size_bits_forwards HALF = ( (vec_of_bits [B0,B1]  ::  2 Word.word))"
|" size_bits_forwards WORD = ( (vec_of_bits [B1,B0]  ::  2 Word.word))"
|" size_bits_forwards DOUBLE = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


\<comment> \<open>\<open>val size_bits_backwards : mword ty2 -> M word_width\<close>\<close>

definition size_bits_backwards  :: "(2)Word.word \<Rightarrow>((register_value),(word_width),(exception))monad "  where 
     " size_bits_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return BYTE
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return HALF
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then return WORD
   else if (((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then return DOUBLE
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(2)Word.word "


\<comment> \<open>\<open>val size_bits_forwards_matches : word_width -> bool\<close>\<close>

fun size_bits_forwards_matches  :: " word_width \<Rightarrow> bool "  where 
     " size_bits_forwards_matches BYTE = ( True )"
|" size_bits_forwards_matches HALF = ( True )"
|" size_bits_forwards_matches WORD = ( True )"
|" size_bits_forwards_matches DOUBLE = ( True )"


\<comment> \<open>\<open>val size_bits_backwards_matches : mword ty2 -> bool\<close>\<close>

definition size_bits_backwards_matches  :: "(2)Word.word \<Rightarrow> bool "  where 
     " size_bits_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then True
   else False))" 
  for  arg1  :: "(2)Word.word "


\<comment> \<open>\<open>val size_mnemonic_forwards : word_width -> string\<close>\<close>

fun size_mnemonic_forwards  :: " word_width \<Rightarrow> string "  where 
     " size_mnemonic_forwards BYTE = ( (''b''))"
|" size_mnemonic_forwards HALF = ( (''h''))"
|" size_mnemonic_forwards WORD = ( (''w''))"
|" size_mnemonic_forwards DOUBLE = ( (''d''))"


\<comment> \<open>\<open>val size_mnemonic_backwards : string -> M word_width\<close>\<close>

definition size_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(word_width),(exception))monad "  where 
     " size_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''b'')))) then return BYTE
   else if (((p00 = (''h'')))) then return HALF
   else if (((p00 = (''w'')))) then return WORD
   else if (((p00 = (''d'')))) then return DOUBLE
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val size_mnemonic_forwards_matches : word_width -> bool\<close>\<close>

fun size_mnemonic_forwards_matches  :: " word_width \<Rightarrow> bool "  where 
     " size_mnemonic_forwards_matches BYTE = ( True )"
|" size_mnemonic_forwards_matches HALF = ( True )"
|" size_mnemonic_forwards_matches WORD = ( True )"
|" size_mnemonic_forwards_matches DOUBLE = ( True )"


\<comment> \<open>\<open>val size_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition size_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " size_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''b'')))) then True
   else if (((p00 = (''h'')))) then True
   else if (((p00 = (''w'')))) then True
   else if (((p00 = (''d'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val size_mnemonic_matches_prefix : string -> maybe ((word_width * ii))\<close>\<close>

\<comment> \<open>\<open>val _s36_ : string -> maybe string\<close>\<close>

definition s36  :: " string \<Rightarrow>(string)option "  where 
     " s36 s370 = (
   (let s381 = s370 in
   if ((string_startswith s381 (''d''))) then  
  (case  ((string_drop s381 ((string_length (''d''))))) of   s1 => Some s1 )
   else None))" 
  for  s370  :: " string "


\<comment> \<open>\<open>val _s32_ : string -> maybe string\<close>\<close>

definition s32  :: " string \<Rightarrow>(string)option "  where 
     " s32 s330 = (
   (let s341 = s330 in
   if ((string_startswith s341 (''w''))) then  
  (case  ((string_drop s341 ((string_length (''w''))))) of   s1 => Some s1 )
   else None))" 
  for  s330  :: " string "


\<comment> \<open>\<open>val _s28_ : string -> maybe string\<close>\<close>

definition s28  :: " string \<Rightarrow>(string)option "  where 
     " s28 s290 = (
   (let s301 = s290 in
   if ((string_startswith s301 (''h''))) then  
  (case  ((string_drop s301 ((string_length (''h''))))) of   s1 => Some s1 )
   else None))" 
  for  s290  :: " string "


\<comment> \<open>\<open>val _s24_ : string -> maybe string\<close>\<close>

definition s24  :: " string \<Rightarrow>(string)option "  where 
     " s24 s250 = (
   (let s261 = s250 in
   if ((string_startswith s261 (''b''))) then  
  (case  ((string_drop s261 ((string_length (''b''))))) of   s1 => Some s1 )
   else None))" 
  for  s250  :: " string "


definition size_mnemonic_matches_prefix  :: " string \<Rightarrow>(word_width*int)option "  where 
     " size_mnemonic_matches_prefix arg1 = (
   (let s270 = arg1 in
   if ((case  ((s24 s270)) of   Some (s1) => True | _ => False )) then  
  (case  s24 s270 of
      (Some (s1)) =>
  Some (BYTE, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s28 s270)) of   Some (s1) => True | _ => False )) then  
  (case  s28 s270 of
      (Some (s1)) =>
  Some (HALF, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s32 s270)) of   Some (s1) => True | _ => False )) then  
  (case  s32 s270 of
      (Some (s1)) =>
  Some (WORD, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s36 s270)) of   Some (s1) => True | _ => False )) then  
  (case  s36 s270 of
      (Some (s1)) =>
  Some (DOUBLE, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val word_width_bytes : word_width -> integer\<close>\<close>

fun word_width_bytes  :: " word_width \<Rightarrow> int "  where 
     " word_width_bytes BYTE = ( (( 1 :: int)::ii))"
|" word_width_bytes HALF = ( (( 2 :: int)::ii))"
|" word_width_bytes WORD = ( (( 4 :: int)::ii))"
|" word_width_bytes DOUBLE = ( (( 8 :: int)::ii))"


definition zero_reg  :: "(32)Word.word "  where 
     " zero_reg = ( (EXTZ (( 32 :: int)::ii) (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)  ::  32 Word.word))"


\<comment> \<open>\<open>val RegStr : mword ty32 -> string\<close>\<close>

definition RegStr  :: "(32)Word.word \<Rightarrow> string "  where 
     " RegStr r = ( string_of_bits r )" 
  for  r  :: "(32)Word.word "


\<comment> \<open>\<open>val regval_from_reg : mword ty32 -> mword ty32\<close>\<close>

definition regval_from_reg  :: "(32)Word.word \<Rightarrow>(32)Word.word "  where 
     " regval_from_reg r = ( r )" 
  for  r  :: "(32)Word.word "


\<comment> \<open>\<open>val regval_into_reg : mword ty32 -> mword ty32\<close>\<close>

definition regval_into_reg  :: "(32)Word.word \<Rightarrow>(32)Word.word "  where 
     " regval_into_reg v = ( v )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val rX : integer -> M (mword ty32)\<close>\<close>

definition rX  :: " int \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " rX r = (
   (let p00 = r in
   (if (((p00 = (( 0 :: int)::ii)))) then return zero_reg
    else if (((p00 = (( 1 :: int)::ii)))) then (read_reg x1_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 2 :: int)::ii)))) then (read_reg x2_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 3 :: int)::ii)))) then (read_reg x3_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 4 :: int)::ii)))) then (read_reg x4_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 5 :: int)::ii)))) then (read_reg x5_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 6 :: int)::ii)))) then (read_reg x6_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 7 :: int)::ii)))) then (read_reg x7_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 8 :: int)::ii)))) then (read_reg x8_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 9 :: int)::ii)))) then (read_reg x9_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 10 :: int)::ii)))) then (read_reg x10_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 11 :: int)::ii)))) then (read_reg x11_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 12 :: int)::ii)))) then (read_reg x12_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 13 :: int)::ii)))) then (read_reg x13_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 14 :: int)::ii)))) then (read_reg x14_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 15 :: int)::ii)))) then (read_reg x15_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 16 :: int)::ii)))) then (read_reg x16_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 17 :: int)::ii)))) then (read_reg x17_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 18 :: int)::ii)))) then (read_reg x18_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 19 :: int)::ii)))) then (read_reg x19_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 20 :: int)::ii)))) then (read_reg x20_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 21 :: int)::ii)))) then (read_reg x21_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 22 :: int)::ii)))) then (read_reg x22_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 23 :: int)::ii)))) then (read_reg x23_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 24 :: int)::ii)))) then (read_reg x24_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 25 :: int)::ii)))) then (read_reg x25_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 26 :: int)::ii)))) then (read_reg x26_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 27 :: int)::ii)))) then (read_reg x27_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 28 :: int)::ii)))) then (read_reg x28_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 29 :: int)::ii)))) then (read_reg x29_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 30 :: int)::ii)))) then (read_reg x30_ref  :: ( 32 Word.word) M)
    else if (((p00 = (( 31 :: int)::ii)))) then (read_reg x31_ref  :: ( 32 Word.word) M)
    else assert_exp False (''invalid register number'') \<then> exit0 () ) \<bind> (\<lambda> (v :: regtype) . 
   return ((regval_from_reg v  ::  32 Word.word)))))" 
  for  r  :: " int "


\<comment> \<open>\<open>val rvfi_wX : integer -> mword ty32 -> unit\<close>\<close>

definition rvfi_wX  :: " int \<Rightarrow>(32)Word.word \<Rightarrow> unit "  where 
     " rvfi_wX r v = ( ()  )" 
  for  r  :: " int " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val wX : integer -> mword ty32 -> M unit\<close>\<close>

definition wX  :: " int \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " wX r in_v = (
   (let v = ((regval_into_reg in_v  ::  32 Word.word)) in
   (let p00 = r in
   (if (((p00 = (( 0 :: int)::ii)))) then return () 
    else if (((p00 = (( 1 :: int)::ii)))) then write_reg x1_ref v
    else if (((p00 = (( 2 :: int)::ii)))) then write_reg x2_ref v
    else if (((p00 = (( 3 :: int)::ii)))) then write_reg x3_ref v
    else if (((p00 = (( 4 :: int)::ii)))) then write_reg x4_ref v
    else if (((p00 = (( 5 :: int)::ii)))) then write_reg x5_ref v
    else if (((p00 = (( 6 :: int)::ii)))) then write_reg x6_ref v
    else if (((p00 = (( 7 :: int)::ii)))) then write_reg x7_ref v
    else if (((p00 = (( 8 :: int)::ii)))) then write_reg x8_ref v
    else if (((p00 = (( 9 :: int)::ii)))) then write_reg x9_ref v
    else if (((p00 = (( 10 :: int)::ii)))) then write_reg x10_ref v
    else if (((p00 = (( 11 :: int)::ii)))) then write_reg x11_ref v
    else if (((p00 = (( 12 :: int)::ii)))) then write_reg x12_ref v
    else if (((p00 = (( 13 :: int)::ii)))) then write_reg x13_ref v
    else if (((p00 = (( 14 :: int)::ii)))) then write_reg x14_ref v
    else if (((p00 = (( 15 :: int)::ii)))) then write_reg x15_ref v
    else if (((p00 = (( 16 :: int)::ii)))) then write_reg x16_ref v
    else if (((p00 = (( 17 :: int)::ii)))) then write_reg x17_ref v
    else if (((p00 = (( 18 :: int)::ii)))) then write_reg x18_ref v
    else if (((p00 = (( 19 :: int)::ii)))) then write_reg x19_ref v
    else if (((p00 = (( 20 :: int)::ii)))) then write_reg x20_ref v
    else if (((p00 = (( 21 :: int)::ii)))) then write_reg x21_ref v
    else if (((p00 = (( 22 :: int)::ii)))) then write_reg x22_ref v
    else if (((p00 = (( 23 :: int)::ii)))) then write_reg x23_ref v
    else if (((p00 = (( 24 :: int)::ii)))) then write_reg x24_ref v
    else if (((p00 = (( 25 :: int)::ii)))) then write_reg x25_ref v
    else if (((p00 = (( 26 :: int)::ii)))) then write_reg x26_ref v
    else if (((p00 = (( 27 :: int)::ii)))) then write_reg x27_ref v
    else if (((p00 = (( 28 :: int)::ii)))) then write_reg x28_ref v
    else if (((p00 = (( 29 :: int)::ii)))) then write_reg x29_ref v
    else if (((p00 = (( 30 :: int)::ii)))) then write_reg x30_ref v
    else if (((p00 = (( 31 :: int)::ii)))) then write_reg x31_ref v
    else assert_exp False (''invalid register number'') \<then> exit0 () ) \<then>
   return (if (((r \<noteq> (( 0 :: int)::ii)))) then
             (let (_ :: unit) = (rvfi_wX r in_v) in
             if ((get_config_print_reg () )) then
               print_dbg
                 (((@) (''x'')
                     (((@) ((stringFromInteger r)) (((@) ('' <- '') ((RegStr v))))))))
             else () )
           else () ))))" 
  for  r  :: " int " 
  and  in_v  :: "(32)Word.word "


\<comment> \<open>\<open>val reg_name_abi : mword ty5 -> M string\<close>\<close>

definition reg_name_abi  :: "(5)Word.word \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " reg_name_abi r = (
   (let b__0 = r in
   if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))
   then
     return (''zero'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word)))))) then
     return (''ra'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))) then
     return (''sp'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)))))) then
     return (''gp'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     return (''tp'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B0,B1]  ::  5 Word.word)))))) then
     return (''t0'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B1,B0]  ::  5 Word.word)))))) then
     return (''t1'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B1,B1]  ::  5 Word.word)))))) then
     return (''t2'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     return (''fp'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B0,B1]  ::  5 Word.word)))))) then
     return (''s1'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B1,B0]  ::  5 Word.word)))))) then
     return (''a0'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B1,B1]  ::  5 Word.word)))))) then
     return (''a1'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     return (''a2'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B0,B1]  ::  5 Word.word)))))) then
     return (''a3'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B1,B0]  ::  5 Word.word)))))) then
     return (''a4'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B1,B1]  ::  5 Word.word)))))) then
     return (''a5'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))))) then
     return (''a6'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B0,B1]  ::  5 Word.word)))))) then
     return (''a7'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B1,B0]  ::  5 Word.word)))))) then
     return (''s2'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B1,B1]  ::  5 Word.word)))))) then
     return (''s3'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     return (''s4'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B0,B1]  ::  5 Word.word)))))) then
     return (''s5'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B1,B0]  ::  5 Word.word)))))) then
     return (''s6'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B1,B1]  ::  5 Word.word)))))) then
     return (''s7'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     return (''s8'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B0,B1]  ::  5 Word.word)))))) then
     return (''s9'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B1,B0]  ::  5 Word.word)))))) then
     return (''s10'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B1,B1]  ::  5 Word.word)))))) then
     return (''s11'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     return (''t3'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B0,B1]  ::  5 Word.word)))))) then
     return (''t4'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B1,B0]  ::  5 Word.word)))))) then
     return (''t5'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word)))))) then
     return (''t6'')
   else assert_exp False (''Pattern match failure at model/riscv_regs.sail 149:2 - 182:3'') \<then> exit0 () ))" 
  for  r  :: "(5)Word.word "


\<comment> \<open>\<open>val reg_name_forwards : mword ty5 -> M string\<close>\<close>

definition reg_name_forwards  :: "(5)Word.word \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " reg_name_forwards arg1 = (
   (let b__0 = arg1 in
   if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))
   then
     return (''zero'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word)))))) then
     return (''ra'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))) then
     return (''sp'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)))))) then
     return (''gp'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     return (''tp'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B0,B1]  ::  5 Word.word)))))) then
     return (''t0'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B1,B0]  ::  5 Word.word)))))) then
     return (''t1'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B1,B1]  ::  5 Word.word)))))) then
     return (''t2'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     return (''fp'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B0,B1]  ::  5 Word.word)))))) then
     return (''s1'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B1,B0]  ::  5 Word.word)))))) then
     return (''a0'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B1,B1]  ::  5 Word.word)))))) then
     return (''a1'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     return (''a2'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B0,B1]  ::  5 Word.word)))))) then
     return (''a3'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B1,B0]  ::  5 Word.word)))))) then
     return (''a4'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B1,B1]  ::  5 Word.word)))))) then
     return (''a5'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))))) then
     return (''a6'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B0,B1]  ::  5 Word.word)))))) then
     return (''a7'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B1,B0]  ::  5 Word.word)))))) then
     return (''s2'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B1,B1]  ::  5 Word.word)))))) then
     return (''s3'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     return (''s4'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B0,B1]  ::  5 Word.word)))))) then
     return (''s5'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B1,B0]  ::  5 Word.word)))))) then
     return (''s6'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B1,B1]  ::  5 Word.word)))))) then
     return (''s7'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     return (''s8'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B0,B1]  ::  5 Word.word)))))) then
     return (''s9'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B1,B0]  ::  5 Word.word)))))) then
     return (''s10'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B1,B1]  ::  5 Word.word)))))) then
     return (''s11'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     return (''t3'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B0,B1]  ::  5 Word.word)))))) then
     return (''t4'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B1,B0]  ::  5 Word.word)))))) then
     return (''t5'')
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word)))))) then
     return (''t6'')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(5)Word.word "


\<comment> \<open>\<open>val reg_name_backwards : string -> M (mword ty5)\<close>\<close>

definition reg_name_backwards  :: " string \<Rightarrow>((register_value),((5)Word.word),(exception))monad "  where 
     " reg_name_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''zero'')))) then return (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
   else if (((p00 = (''ra'')))) then return (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word)
   else if (((p00 = (''sp'')))) then return (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)
   else if (((p00 = (''gp'')))) then return (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)
   else if (((p00 = (''tp'')))) then return (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)
   else if (((p00 = (''t0'')))) then return (vec_of_bits [B0,B0,B1,B0,B1]  ::  5 Word.word)
   else if (((p00 = (''t1'')))) then return (vec_of_bits [B0,B0,B1,B1,B0]  ::  5 Word.word)
   else if (((p00 = (''t2'')))) then return (vec_of_bits [B0,B0,B1,B1,B1]  ::  5 Word.word)
   else if (((p00 = (''fp'')))) then return (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)
   else if (((p00 = (''s1'')))) then return (vec_of_bits [B0,B1,B0,B0,B1]  ::  5 Word.word)
   else if (((p00 = (''a0'')))) then return (vec_of_bits [B0,B1,B0,B1,B0]  ::  5 Word.word)
   else if (((p00 = (''a1'')))) then return (vec_of_bits [B0,B1,B0,B1,B1]  ::  5 Word.word)
   else if (((p00 = (''a2'')))) then return (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)
   else if (((p00 = (''a3'')))) then return (vec_of_bits [B0,B1,B1,B0,B1]  ::  5 Word.word)
   else if (((p00 = (''a4'')))) then return (vec_of_bits [B0,B1,B1,B1,B0]  ::  5 Word.word)
   else if (((p00 = (''a5'')))) then return (vec_of_bits [B0,B1,B1,B1,B1]  ::  5 Word.word)
   else if (((p00 = (''a6'')))) then return (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)
   else if (((p00 = (''a7'')))) then return (vec_of_bits [B1,B0,B0,B0,B1]  ::  5 Word.word)
   else if (((p00 = (''s2'')))) then return (vec_of_bits [B1,B0,B0,B1,B0]  ::  5 Word.word)
   else if (((p00 = (''s3'')))) then return (vec_of_bits [B1,B0,B0,B1,B1]  ::  5 Word.word)
   else if (((p00 = (''s4'')))) then return (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)
   else if (((p00 = (''s5'')))) then return (vec_of_bits [B1,B0,B1,B0,B1]  ::  5 Word.word)
   else if (((p00 = (''s6'')))) then return (vec_of_bits [B1,B0,B1,B1,B0]  ::  5 Word.word)
   else if (((p00 = (''s7'')))) then return (vec_of_bits [B1,B0,B1,B1,B1]  ::  5 Word.word)
   else if (((p00 = (''s8'')))) then return (vec_of_bits [B1,B1,B0,B0,B0]  ::  5 Word.word)
   else if (((p00 = (''s9'')))) then return (vec_of_bits [B1,B1,B0,B0,B1]  ::  5 Word.word)
   else if (((p00 = (''s10'')))) then return (vec_of_bits [B1,B1,B0,B1,B0]  ::  5 Word.word)
   else if (((p00 = (''s11'')))) then return (vec_of_bits [B1,B1,B0,B1,B1]  ::  5 Word.word)
   else if (((p00 = (''t3'')))) then return (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word)
   else if (((p00 = (''t4'')))) then return (vec_of_bits [B1,B1,B1,B0,B1]  ::  5 Word.word)
   else if (((p00 = (''t5'')))) then return (vec_of_bits [B1,B1,B1,B1,B0]  ::  5 Word.word)
   else if (((p00 = (''t6'')))) then return (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val reg_name_forwards_matches : mword ty5 -> bool\<close>\<close>

definition reg_name_forwards_matches  :: "(5)Word.word \<Rightarrow> bool "  where 
     " reg_name_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))))))
   then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B0,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B1,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B1,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B0,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B1,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B1,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B0,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B1,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B1,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B0,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B1,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B1,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B0,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B1,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B1,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B0,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B1,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B1,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B0,B1]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B1,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B1,B1]  ::  5 Word.word)))))) then
     True
   else False))" 
  for  arg1  :: "(5)Word.word "


\<comment> \<open>\<open>val reg_name_backwards_matches : string -> bool\<close>\<close>

definition reg_name_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " reg_name_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''zero'')))) then True
   else if (((p00 = (''ra'')))) then True
   else if (((p00 = (''sp'')))) then True
   else if (((p00 = (''gp'')))) then True
   else if (((p00 = (''tp'')))) then True
   else if (((p00 = (''t0'')))) then True
   else if (((p00 = (''t1'')))) then True
   else if (((p00 = (''t2'')))) then True
   else if (((p00 = (''fp'')))) then True
   else if (((p00 = (''s1'')))) then True
   else if (((p00 = (''a0'')))) then True
   else if (((p00 = (''a1'')))) then True
   else if (((p00 = (''a2'')))) then True
   else if (((p00 = (''a3'')))) then True
   else if (((p00 = (''a4'')))) then True
   else if (((p00 = (''a5'')))) then True
   else if (((p00 = (''a6'')))) then True
   else if (((p00 = (''a7'')))) then True
   else if (((p00 = (''s2'')))) then True
   else if (((p00 = (''s3'')))) then True
   else if (((p00 = (''s4'')))) then True
   else if (((p00 = (''s5'')))) then True
   else if (((p00 = (''s6'')))) then True
   else if (((p00 = (''s7'')))) then True
   else if (((p00 = (''s8'')))) then True
   else if (((p00 = (''s9'')))) then True
   else if (((p00 = (''s10'')))) then True
   else if (((p00 = (''s11'')))) then True
   else if (((p00 = (''t3'')))) then True
   else if (((p00 = (''t4'')))) then True
   else if (((p00 = (''t5'')))) then True
   else if (((p00 = (''t6'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val reg_name_matches_prefix : string -> maybe ((mword ty5 * ii))\<close>\<close>

\<comment> \<open>\<open>val _s164_ : string -> maybe string\<close>\<close>

definition s164  :: " string \<Rightarrow>(string)option "  where 
     " s164 s1650 = (
   (let s1660 = s1650 in
   if ((string_startswith s1660 (''t6''))) then  
  (case  ((string_drop s1660 ((string_length (''t6''))))) of   s1 => Some s1 )
   else None))" 
  for  s1650  :: " string "


\<comment> \<open>\<open>val _s160_ : string -> maybe string\<close>\<close>

definition s160  :: " string \<Rightarrow>(string)option "  where 
     " s160 s1610 = (
   (let s1620 = s1610 in
   if ((string_startswith s1620 (''t5''))) then  
  (case  ((string_drop s1620 ((string_length (''t5''))))) of   s1 => Some s1 )
   else None))" 
  for  s1610  :: " string "


\<comment> \<open>\<open>val _s156_ : string -> maybe string\<close>\<close>

definition s156  :: " string \<Rightarrow>(string)option "  where 
     " s156 s1570 = (
   (let s1581 = s1570 in
   if ((string_startswith s1581 (''t4''))) then  
  (case  ((string_drop s1581 ((string_length (''t4''))))) of   s1 => Some s1 )
   else None))" 
  for  s1570  :: " string "


\<comment> \<open>\<open>val _s152_ : string -> maybe string\<close>\<close>

definition s152  :: " string \<Rightarrow>(string)option "  where 
     " s152 s1530 = (
   (let s1540 = s1530 in
   if ((string_startswith s1540 (''t3''))) then  
  (case  ((string_drop s1540 ((string_length (''t3''))))) of   s1 => Some s1 )
   else None))" 
  for  s1530  :: " string "


\<comment> \<open>\<open>val _s148_ : string -> maybe string\<close>\<close>

definition s148  :: " string \<Rightarrow>(string)option "  where 
     " s148 s1490 = (
   (let s1500 = s1490 in
   if ((string_startswith s1500 (''s11''))) then  
  (case  ((string_drop s1500 ((string_length (''s11''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s1490  :: " string "


\<comment> \<open>\<open>val _s144_ : string -> maybe string\<close>\<close>

definition s144  :: " string \<Rightarrow>(string)option "  where 
     " s144 s1450 = (
   (let s1460 = s1450 in
   if ((string_startswith s1460 (''s10''))) then  
  (case  ((string_drop s1460 ((string_length (''s10''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s1450  :: " string "


\<comment> \<open>\<open>val _s140_ : string -> maybe string\<close>\<close>

definition s140  :: " string \<Rightarrow>(string)option "  where 
     " s140 s1410 = (
   (let s1420 = s1410 in
   if ((string_startswith s1420 (''s9''))) then  
  (case  ((string_drop s1420 ((string_length (''s9''))))) of   s1 => Some s1 )
   else None))" 
  for  s1410  :: " string "


\<comment> \<open>\<open>val _s136_ : string -> maybe string\<close>\<close>

definition s136  :: " string \<Rightarrow>(string)option "  where 
     " s136 s1370 = (
   (let s1380 = s1370 in
   if ((string_startswith s1380 (''s8''))) then  
  (case  ((string_drop s1380 ((string_length (''s8''))))) of   s1 => Some s1 )
   else None))" 
  for  s1370  :: " string "


\<comment> \<open>\<open>val _s132_ : string -> maybe string\<close>\<close>

definition s132  :: " string \<Rightarrow>(string)option "  where 
     " s132 s1330 = (
   (let s1340 = s1330 in
   if ((string_startswith s1340 (''s7''))) then  
  (case  ((string_drop s1340 ((string_length (''s7''))))) of   s1 => Some s1 )
   else None))" 
  for  s1330  :: " string "


\<comment> \<open>\<open>val _s128_ : string -> maybe string\<close>\<close>

definition s128  :: " string \<Rightarrow>(string)option "  where 
     " s128 s1290 = (
   (let s1300 = s1290 in
   if ((string_startswith s1300 (''s6''))) then  
  (case  ((string_drop s1300 ((string_length (''s6''))))) of   s1 => Some s1 )
   else None))" 
  for  s1290  :: " string "


\<comment> \<open>\<open>val _s124_ : string -> maybe string\<close>\<close>

definition s124  :: " string \<Rightarrow>(string)option "  where 
     " s124 s1250 = (
   (let s1260 = s1250 in
   if ((string_startswith s1260 (''s5''))) then  
  (case  ((string_drop s1260 ((string_length (''s5''))))) of   s1 => Some s1 )
   else None))" 
  for  s1250  :: " string "


\<comment> \<open>\<open>val _s120_ : string -> maybe string\<close>\<close>

definition s120  :: " string \<Rightarrow>(string)option "  where 
     " s120 s1210 = (
   (let s1220 = s1210 in
   if ((string_startswith s1220 (''s4''))) then  
  (case  ((string_drop s1220 ((string_length (''s4''))))) of   s1 => Some s1 )
   else None))" 
  for  s1210  :: " string "


\<comment> \<open>\<open>val _s116_ : string -> maybe string\<close>\<close>

definition s116  :: " string \<Rightarrow>(string)option "  where 
     " s116 s1170 = (
   (let s1180 = s1170 in
   if ((string_startswith s1180 (''s3''))) then  
  (case  ((string_drop s1180 ((string_length (''s3''))))) of   s1 => Some s1 )
   else None))" 
  for  s1170  :: " string "


\<comment> \<open>\<open>val _s112_ : string -> maybe string\<close>\<close>

definition s112  :: " string \<Rightarrow>(string)option "  where 
     " s112 s1130 = (
   (let s1140 = s1130 in
   if ((string_startswith s1140 (''s2''))) then  
  (case  ((string_drop s1140 ((string_length (''s2''))))) of   s1 => Some s1 )
   else None))" 
  for  s1130  :: " string "


\<comment> \<open>\<open>val _s108_ : string -> maybe string\<close>\<close>

definition s108  :: " string \<Rightarrow>(string)option "  where 
     " s108 s1090 = (
   (let s1100 = s1090 in
   if ((string_startswith s1100 (''a7''))) then  
  (case  ((string_drop s1100 ((string_length (''a7''))))) of   s1 => Some s1 )
   else None))" 
  for  s1090  :: " string "


\<comment> \<open>\<open>val _s104_ : string -> maybe string\<close>\<close>

definition s104  :: " string \<Rightarrow>(string)option "  where 
     " s104 s1050 = (
   (let s1060 = s1050 in
   if ((string_startswith s1060 (''a6''))) then  
  (case  ((string_drop s1060 ((string_length (''a6''))))) of   s1 => Some s1 )
   else None))" 
  for  s1050  :: " string "


\<comment> \<open>\<open>val _s100_ : string -> maybe string\<close>\<close>

definition s100  :: " string \<Rightarrow>(string)option "  where 
     " s100 s1010 = (
   (let s1020 = s1010 in
   if ((string_startswith s1020 (''a5''))) then  
  (case  ((string_drop s1020 ((string_length (''a5''))))) of   s1 => Some s1 )
   else None))" 
  for  s1010  :: " string "


\<comment> \<open>\<open>val _s96_ : string -> maybe string\<close>\<close>

definition s96  :: " string \<Rightarrow>(string)option "  where 
     " s96 s970 = (
   (let s981 = s970 in
   if ((string_startswith s981 (''a4''))) then  
  (case  ((string_drop s981 ((string_length (''a4''))))) of   s1 => Some s1 )
   else None))" 
  for  s970  :: " string "


\<comment> \<open>\<open>val _s92_ : string -> maybe string\<close>\<close>

definition s92  :: " string \<Rightarrow>(string)option "  where 
     " s92 s930 = (
   (let s940 = s930 in
   if ((string_startswith s940 (''a3''))) then  
  (case  ((string_drop s940 ((string_length (''a3''))))) of   s1 => Some s1 )
   else None))" 
  for  s930  :: " string "


\<comment> \<open>\<open>val _s88_ : string -> maybe string\<close>\<close>

definition s88  :: " string \<Rightarrow>(string)option "  where 
     " s88 s890 = (
   (let s900 = s890 in
   if ((string_startswith s900 (''a2''))) then  
  (case  ((string_drop s900 ((string_length (''a2''))))) of   s1 => Some s1 )
   else None))" 
  for  s890  :: " string "


\<comment> \<open>\<open>val _s84_ : string -> maybe string\<close>\<close>

definition s84  :: " string \<Rightarrow>(string)option "  where 
     " s84 s850 = (
   (let s860 = s850 in
   if ((string_startswith s860 (''a1''))) then  
  (case  ((string_drop s860 ((string_length (''a1''))))) of   s1 => Some s1 )
   else None))" 
  for  s850  :: " string "


\<comment> \<open>\<open>val _s80_ : string -> maybe string\<close>\<close>

definition s80  :: " string \<Rightarrow>(string)option "  where 
     " s80 s810 = (
   (let s820 = s810 in
   if ((string_startswith s820 (''a0''))) then  
  (case  ((string_drop s820 ((string_length (''a0''))))) of   s1 => Some s1 )
   else None))" 
  for  s810  :: " string "


\<comment> \<open>\<open>val _s76_ : string -> maybe string\<close>\<close>

definition s76  :: " string \<Rightarrow>(string)option "  where 
     " s76 s770 = (
   (let s780 = s770 in
   if ((string_startswith s780 (''s1''))) then  
  (case  ((string_drop s780 ((string_length (''s1''))))) of   s1 => Some s1 )
   else None))" 
  for  s770  :: " string "


\<comment> \<open>\<open>val _s72_ : string -> maybe string\<close>\<close>

definition s72  :: " string \<Rightarrow>(string)option "  where 
     " s72 s730 = (
   (let s740 = s730 in
   if ((string_startswith s740 (''fp''))) then  
  (case  ((string_drop s740 ((string_length (''fp''))))) of   s1 => Some s1 )
   else None))" 
  for  s730  :: " string "


\<comment> \<open>\<open>val _s68_ : string -> maybe string\<close>\<close>

definition s68  :: " string \<Rightarrow>(string)option "  where 
     " s68 s690 = (
   (let s701 = s690 in
   if ((string_startswith s701 (''t2''))) then  
  (case  ((string_drop s701 ((string_length (''t2''))))) of   s1 => Some s1 )
   else None))" 
  for  s690  :: " string "


\<comment> \<open>\<open>val _s64_ : string -> maybe string\<close>\<close>

definition s64  :: " string \<Rightarrow>(string)option "  where 
     " s64 s650 = (
   (let s661 = s650 in
   if ((string_startswith s661 (''t1''))) then  
  (case  ((string_drop s661 ((string_length (''t1''))))) of   s1 => Some s1 )
   else None))" 
  for  s650  :: " string "


\<comment> \<open>\<open>val _s60_ : string -> maybe string\<close>\<close>

definition s60  :: " string \<Rightarrow>(string)option "  where 
     " s60 s610 = (
   (let s621 = s610 in
   if ((string_startswith s621 (''t0''))) then  
  (case  ((string_drop s621 ((string_length (''t0''))))) of   s1 => Some s1 )
   else None))" 
  for  s610  :: " string "


\<comment> \<open>\<open>val _s56_ : string -> maybe string\<close>\<close>

definition s56  :: " string \<Rightarrow>(string)option "  where 
     " s56 s570 = (
   (let s581 = s570 in
   if ((string_startswith s581 (''tp''))) then  
  (case  ((string_drop s581 ((string_length (''tp''))))) of   s1 => Some s1 )
   else None))" 
  for  s570  :: " string "


\<comment> \<open>\<open>val _s52_ : string -> maybe string\<close>\<close>

definition s52  :: " string \<Rightarrow>(string)option "  where 
     " s52 s530 = (
   (let s541 = s530 in
   if ((string_startswith s541 (''gp''))) then  
  (case  ((string_drop s541 ((string_length (''gp''))))) of   s1 => Some s1 )
   else None))" 
  for  s530  :: " string "


\<comment> \<open>\<open>val _s48_ : string -> maybe string\<close>\<close>

definition s48  :: " string \<Rightarrow>(string)option "  where 
     " s48 s490 = (
   (let s501 = s490 in
   if ((string_startswith s501 (''sp''))) then  
  (case  ((string_drop s501 ((string_length (''sp''))))) of   s1 => Some s1 )
   else None))" 
  for  s490  :: " string "


\<comment> \<open>\<open>val _s44_ : string -> maybe string\<close>\<close>

definition s44  :: " string \<Rightarrow>(string)option "  where 
     " s44 s450 = (
   (let s461 = s450 in
   if ((string_startswith s461 (''ra''))) then  
  (case  ((string_drop s461 ((string_length (''ra''))))) of   s1 => Some s1 )
   else None))" 
  for  s450  :: " string "


\<comment> \<open>\<open>val _s40_ : string -> maybe string\<close>\<close>

definition s40  :: " string \<Rightarrow>(string)option "  where 
     " s40 s410 = (
   (let s421 = s410 in
   if ((string_startswith s421 (''zero''))) then  
  (case  ((string_drop s421 ((string_length (''zero''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s410  :: " string "


definition reg_name_matches_prefix  :: " string \<Rightarrow>((5)Word.word*int)option "  where 
     " reg_name_matches_prefix arg1 = (
   (let s430 = arg1 in
   if ((case  ((s40 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s40 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s44 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s44 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s48 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s48 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s52 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s52 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s56 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s56 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B0,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s60 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s60 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B0,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s64 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s64 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s68 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s68 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s72 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s72 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B0,B0,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s76 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s76 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B0,B0,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s80 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s80 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B0,B1,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s84 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s84 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B0,B1,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s88 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s88 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B1,B0,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s92 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s92 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B1,B0,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s96 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s96 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B1,B1,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s100 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s100 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B1,B1,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s104 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s104 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B0,B0,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s108 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s108 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B0,B0,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s112 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s112 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B0,B1,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s116 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s116 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B0,B1,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s120 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s120 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B1,B0,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s124 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s124 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B1,B0,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s128 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s128 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B1,B1,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s132 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s132 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B1,B1,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s136 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s136 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B0,B0,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s140 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s140 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B0,B0,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s144 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s144 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B0,B1,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s148 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s148 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B0,B1,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s152 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s152 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B1,B0,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s156 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s156 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B1,B0,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s160 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s160 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B1,B1,B0] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s164 s430)) of   Some (s1) => True | _ => False )) then  
  (case  s164 s430 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B1,B1,B1] :: 5 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val creg_name_forwards : mword ty3 -> M string\<close>\<close>

definition creg_name_forwards  :: "(3)Word.word \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " creg_name_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then return (''s0'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then return (''s1'')
   else if (((b__0 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then return (''a0'')
   else if (((b__0 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then return (''a1'')
   else if (((b__0 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then return (''a2'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then return (''a3'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then return (''a4'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) then return (''a5'')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val creg_name_backwards : string -> M (mword ty3)\<close>\<close>

definition creg_name_backwards  :: " string \<Rightarrow>((register_value),((3)Word.word),(exception))monad "  where 
     " creg_name_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''s0'')))) then return (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
   else if (((p00 = (''s1'')))) then return (vec_of_bits [B0,B0,B1]  ::  3 Word.word)
   else if (((p00 = (''a0'')))) then return (vec_of_bits [B0,B1,B0]  ::  3 Word.word)
   else if (((p00 = (''a1'')))) then return (vec_of_bits [B0,B1,B1]  ::  3 Word.word)
   else if (((p00 = (''a2'')))) then return (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
   else if (((p00 = (''a3'')))) then return (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
   else if (((p00 = (''a4'')))) then return (vec_of_bits [B1,B1,B0]  ::  3 Word.word)
   else if (((p00 = (''a5'')))) then return (vec_of_bits [B1,B1,B1]  ::  3 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val creg_name_forwards_matches : mword ty3 -> bool\<close>\<close>

definition creg_name_forwards_matches  :: "(3)Word.word \<Rightarrow> bool "  where 
     " creg_name_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) then True
   else False))" 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val creg_name_backwards_matches : string -> bool\<close>\<close>

definition creg_name_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " creg_name_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''s0'')))) then True
   else if (((p00 = (''s1'')))) then True
   else if (((p00 = (''a0'')))) then True
   else if (((p00 = (''a1'')))) then True
   else if (((p00 = (''a2'')))) then True
   else if (((p00 = (''a3'')))) then True
   else if (((p00 = (''a4'')))) then True
   else if (((p00 = (''a5'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val creg_name_matches_prefix : string -> maybe ((mword ty3 * ii))\<close>\<close>

\<comment> \<open>\<open>val _s196_ : string -> maybe string\<close>\<close>

definition s196  :: " string \<Rightarrow>(string)option "  where 
     " s196 s1970 = (
   (let s1980 = s1970 in
   if ((string_startswith s1980 (''a5''))) then  
  (case  ((string_drop s1980 ((string_length (''a5''))))) of   s1 => Some s1 )
   else None))" 
  for  s1970  :: " string "


\<comment> \<open>\<open>val _s192_ : string -> maybe string\<close>\<close>

definition s192  :: " string \<Rightarrow>(string)option "  where 
     " s192 s1930 = (
   (let s1940 = s1930 in
   if ((string_startswith s1940 (''a4''))) then  
  (case  ((string_drop s1940 ((string_length (''a4''))))) of   s1 => Some s1 )
   else None))" 
  for  s1930  :: " string "


\<comment> \<open>\<open>val _s188_ : string -> maybe string\<close>\<close>

definition s188  :: " string \<Rightarrow>(string)option "  where 
     " s188 s1890 = (
   (let s1900 = s1890 in
   if ((string_startswith s1900 (''a3''))) then  
  (case  ((string_drop s1900 ((string_length (''a3''))))) of   s1 => Some s1 )
   else None))" 
  for  s1890  :: " string "


\<comment> \<open>\<open>val _s184_ : string -> maybe string\<close>\<close>

definition s184  :: " string \<Rightarrow>(string)option "  where 
     " s184 s1850 = (
   (let s1860 = s1850 in
   if ((string_startswith s1860 (''a2''))) then  
  (case  ((string_drop s1860 ((string_length (''a2''))))) of   s1 => Some s1 )
   else None))" 
  for  s1850  :: " string "


\<comment> \<open>\<open>val _s180_ : string -> maybe string\<close>\<close>

definition s180  :: " string \<Rightarrow>(string)option "  where 
     " s180 s1810 = (
   (let s1820 = s1810 in
   if ((string_startswith s1820 (''a1''))) then  
  (case  ((string_drop s1820 ((string_length (''a1''))))) of   s1 => Some s1 )
   else None))" 
  for  s1810  :: " string "


\<comment> \<open>\<open>val _s176_ : string -> maybe string\<close>\<close>

definition s176  :: " string \<Rightarrow>(string)option "  where 
     " s176 s1770 = (
   (let s1780 = s1770 in
   if ((string_startswith s1780 (''a0''))) then  
  (case  ((string_drop s1780 ((string_length (''a0''))))) of   s1 => Some s1 )
   else None))" 
  for  s1770  :: " string "


\<comment> \<open>\<open>val _s172_ : string -> maybe string\<close>\<close>

definition s172  :: " string \<Rightarrow>(string)option "  where 
     " s172 s1730 = (
   (let s1740 = s1730 in
   if ((string_startswith s1740 (''s1''))) then  
  (case  ((string_drop s1740 ((string_length (''s1''))))) of   s1 => Some s1 )
   else None))" 
  for  s1730  :: " string "


\<comment> \<open>\<open>val _s168_ : string -> maybe string\<close>\<close>

definition s168  :: " string \<Rightarrow>(string)option "  where 
     " s168 s1690 = (
   (let s1700 = s1690 in
   if ((string_startswith s1700 (''s0''))) then  
  (case  ((string_drop s1700 ((string_length (''s0''))))) of   s1 => Some s1 )
   else None))" 
  for  s1690  :: " string "


definition creg_name_matches_prefix  :: " string \<Rightarrow>((3)Word.word*int)option "  where 
     " creg_name_matches_prefix arg1 = (
   (let s1711 = arg1 in
   if ((case  ((s168 s1711)) of   Some (s1) => True | _ => False )) then  
  (case  s168 s1711 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0] :: 3 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s172 s1711)) of   Some (s1) => True | _ => False )) then  
  (case  s172 s1711 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1] :: 3 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s176 s1711)) of   Some (s1) => True | _ => False )) then  
  (case  s176 s1711 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B0] :: 3 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s180 s1711)) of   Some (s1) => True | _ => False )) then  
  (case  s180 s1711 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B1] :: 3 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s184 s1711)) of   Some (s1) => True | _ => False )) then  
  (case  s184 s1711 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B0] :: 3 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s188 s1711)) of   Some (s1) => True | _ => False )) then  
  (case  s188 s1711 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B1] :: 3 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s192 s1711)) of   Some (s1) => True | _ => False )) then  
  (case  s192 s1711 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B0] :: 3 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s196 s1711)) of   Some (s1) => True | _ => False )) then  
  (case  s196 s1711 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B1] :: 3 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val init_base_regs : unit -> M unit\<close>\<close>

definition init_base_regs  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " init_base_regs _ = (
   (((((((((((((((((((((((((((((write_reg x1_ref zero_reg \<then>
   write_reg x2_ref zero_reg) \<then>
   write_reg x3_ref zero_reg) \<then>
   write_reg x4_ref zero_reg) \<then>
   write_reg x5_ref zero_reg) \<then>
   write_reg x6_ref zero_reg) \<then>
   write_reg x7_ref zero_reg) \<then>
   write_reg x8_ref zero_reg) \<then>
   write_reg x9_ref zero_reg) \<then>
   write_reg x10_ref zero_reg) \<then>
   write_reg x11_ref zero_reg) \<then>
   write_reg x12_ref zero_reg) \<then>
   write_reg x13_ref zero_reg) \<then>
   write_reg x14_ref zero_reg) \<then>
   write_reg x15_ref zero_reg) \<then>
   write_reg x16_ref zero_reg) \<then>
   write_reg x17_ref zero_reg) \<then>
   write_reg x18_ref zero_reg) \<then>
   write_reg x19_ref zero_reg) \<then>
   write_reg x20_ref zero_reg) \<then>
   write_reg x21_ref zero_reg) \<then>
   write_reg x22_ref zero_reg) \<then>
   write_reg x23_ref zero_reg) \<then>
   write_reg x24_ref zero_reg) \<then>
   write_reg x25_ref zero_reg) \<then>
   write_reg x26_ref zero_reg) \<then>
   write_reg x27_ref zero_reg) \<then>
   write_reg x28_ref zero_reg) \<then>
   write_reg x29_ref zero_reg) \<then> write_reg x30_ref zero_reg) \<then> write_reg x31_ref zero_reg )"


\<comment> \<open>\<open>
  Retrieves the architectural PC value. This is not necessarily the value
  found in the PC register as extensions may choose to override this function.
  The value in the PC register is the absolute virtual address of the instruction
  to fetch.
 \<close>\<close>
\<comment> \<open>\<open>val get_arch_pc : unit -> M (mword ty32)\<close>\<close>

definition get_arch_pc  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " get_arch_pc _ = ( (read_reg PC_ref  :: ( 32 Word.word) M))"


\<comment> \<open>\<open>val get_next_pc : unit -> M (mword ty32)\<close>\<close>

definition get_next_pc  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " get_next_pc _ = ( (read_reg nextPC_ref  :: ( 32 Word.word) M))"


\<comment> \<open>\<open>val set_next_pc : mword ty32 -> M unit\<close>\<close>

definition set_next_pc  :: "(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_next_pc pc = ( write_reg nextPC_ref pc )" 
  for  pc  :: "(32)Word.word "


\<comment> \<open>\<open>val tick_pc : unit -> M unit\<close>\<close>

definition tick_pc  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " tick_pc _ = (
   (read_reg nextPC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) .  write_reg PC_ref w__0))"


\<comment> \<open>\<open>val Mk_Misa : mword ty32 -> Misa\<close>\<close>

definition Mk_Misa  :: "(32)Word.word \<Rightarrow> Misa "  where 
     " Mk_Misa v = ( (| Misa_Misa_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Misa_bits : Misa -> mword ty32\<close>\<close>

definition get_Misa_bits  :: " Misa \<Rightarrow>(32)Word.word "  where 
     " get_Misa_bits v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_bits : register_ref regstate register_value Misa -> mword ty32 -> M unit\<close>\<close>

definition set_Misa_bits  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Misa_bits : Misa -> mword ty32 -> Misa\<close>\<close>

definition update_Misa_bits  :: " Misa \<Rightarrow>(32)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_bits v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_SV48_PTE_bits : SV48_PTE -> mword ty64 -> SV48_PTE\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_PTE_bits : SV48_PTE -> mword ty64\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_PTE_bits : register_ref regstate register_value SV48_PTE -> mword ty64 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_MXL : Misa -> mword ty2\<close>\<close>

definition get_Misa_MXL  :: " Misa \<Rightarrow>(2)Word.word "  where 
     " get_Misa_MXL v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 31 :: int)::ii) (( 30 :: int)::ii)  ::  2 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_MXL : register_ref regstate register_value Misa -> mword ty2 -> M unit\<close>\<close>

definition set_Misa_MXL  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_MXL r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 31 :: int)::ii) (( 30 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Misa_MXL : Misa -> mword ty2 -> Misa\<close>\<close>

definition update_Misa_MXL  :: " Misa \<Rightarrow>(2)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_MXL v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 31 :: int)::ii) (( 30 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _get_Misa_Z : Misa -> mword ty1\<close>\<close>

definition get_Misa_Z  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_Z v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_Z : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_Z  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_Z r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 25 :: int)::ii) (( 25 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_Z : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_Z  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_Z v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 25 :: int)::ii) (( 25 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_Y : Misa -> mword ty1\<close>\<close>

definition get_Misa_Y  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_Y v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 24 :: int)::ii) (( 24 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_Y : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_Y  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_Y r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 24 :: int)::ii) (( 24 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_Y : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_Y  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_Y v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 24 :: int)::ii) (( 24 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_X : Misa -> mword ty1\<close>\<close>

definition get_Misa_X  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_X v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 23 :: int)::ii) (( 23 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_X : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_X  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_X r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 23 :: int)::ii) (( 23 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_X : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_X  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_X v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 23 :: int)::ii) (( 23 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_X : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_X : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_X : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_W : Misa -> mword ty1\<close>\<close>

definition get_Misa_W  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_W v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 22 :: int)::ii) (( 22 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_W : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_W  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_W r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 22 :: int)::ii) (( 22 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_W : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_W  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_W v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 22 :: int)::ii) (( 22 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_W : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_W : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_W : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_V : Misa -> mword ty1\<close>\<close>

definition get_Misa_V  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_V v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_V : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_V  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_V r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 21 :: int)::ii) (( 21 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_V : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_V  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_V v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 21 :: int)::ii) (( 21 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_V : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_V : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_V : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_U : Misa -> mword ty1\<close>\<close>

definition get_Misa_U  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_U v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_U : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_U  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_U r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 20 :: int)::ii) (( 20 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_U : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_U  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_U v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 20 :: int)::ii) (( 20 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_U : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_U : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_U : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_T : Misa -> mword ty1\<close>\<close>

definition get_Misa_T  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_T v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 19 :: int)::ii) (( 19 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_T : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_T  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_T r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 19 :: int)::ii) (( 19 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_T : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_T  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_T v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 19 :: int)::ii) (( 19 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_S : Misa -> mword ty1\<close>\<close>

definition get_Misa_S  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_S v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 18 :: int)::ii) (( 18 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_S : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_S  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_S r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 18 :: int)::ii) (( 18 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_S : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_S  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_S v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 18 :: int)::ii) (( 18 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_R : Misa -> mword ty1\<close>\<close>

definition get_Misa_R  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_R v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 17 :: int)::ii) (( 17 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_R : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_R  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_R r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 17 :: int)::ii) (( 17 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_R : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_R  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_R v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 17 :: int)::ii) (( 17 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_R : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_R : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_R : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_Q : Misa -> mword ty1\<close>\<close>

definition get_Misa_Q  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_Q v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 16 :: int)::ii) (( 16 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_Q : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_Q  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_Q r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 16 :: int)::ii) (( 16 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_Q : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_Q  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_Q v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 16 :: int)::ii) (( 16 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_P : Misa -> mword ty1\<close>\<close>

definition get_Misa_P  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_P v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 15 :: int)::ii) (( 15 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_P : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_P  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_P r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 15 :: int)::ii) (( 15 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_P : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_P  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_P v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 15 :: int)::ii) (( 15 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_O : Misa -> mword ty1\<close>\<close>

definition get_Misa_O  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_O v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_O : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_O  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_O r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 14 :: int)::ii) (( 14 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_O : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_O  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_O v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 14 :: int)::ii) (( 14 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_N : Misa -> mword ty1\<close>\<close>

definition get_Misa_N  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_N v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 13 :: int)::ii) (( 13 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_N : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_N  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_N r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 13 :: int)::ii) (( 13 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_N : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_N  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_N v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 13 :: int)::ii) (( 13 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_M : Misa -> mword ty1\<close>\<close>

definition get_Misa_M  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_M v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_M : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_M  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_M r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 12 :: int)::ii) (( 12 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_M : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_M  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_M v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 12 :: int)::ii) (( 12 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_L : Misa -> mword ty1\<close>\<close>

definition get_Misa_L  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_L v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_L : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_L  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_L r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 11 :: int)::ii) (( 11 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_L : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_L  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_L v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 11 :: int)::ii) (( 11 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Pmpcfg_ent_L : Pmpcfg_ent -> mword ty1 -> Pmpcfg_ent\<close>\<close>

\<comment> \<open>\<open>val _get_Pmpcfg_ent_L : Pmpcfg_ent -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Pmpcfg_ent_L : register_ref regstate register_value Pmpcfg_ent -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_K : Misa -> mword ty1\<close>\<close>

definition get_Misa_K  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_K v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_K : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_K  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_K r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 10 :: int)::ii) (( 10 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_K : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_K  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_K v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 10 :: int)::ii) (( 10 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_J : Misa -> mword ty1\<close>\<close>

definition get_Misa_J  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_J v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_J : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_J  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_J r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 9 :: int)::ii) (( 9 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_J : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_J  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_J v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 9 :: int)::ii) (( 9 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_I : Misa -> mword ty1\<close>\<close>

definition get_Misa_I  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_I v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_I : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_I  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_I r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 8 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_I : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_I  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_I v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_H : Misa -> mword ty1\<close>\<close>

definition get_Misa_H  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_H v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_H : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_H  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_H r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 7 :: int)::ii) (( 7 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_H : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_H  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_H v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_G : Misa -> mword ty1\<close>\<close>

definition get_Misa_G  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_G v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_G : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_G  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_G r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 6 :: int)::ii) (( 6 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_G : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_G  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_G v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 6 :: int)::ii) (( 6 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_G : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_G : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_G : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_F : Misa -> mword ty1\<close>\<close>

definition get_Misa_F  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_F v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_F : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_F  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_F r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 5 :: int)::ii) (( 5 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_F : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_F  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_F v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_E : Misa -> mword ty1\<close>\<close>

definition get_Misa_E  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_E v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_E : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_E  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_E r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 4 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_E : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_E  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_E v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_D : Misa -> mword ty1\<close>\<close>

definition get_Misa_D  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_D v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_D : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_D  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_D r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 3 :: int)::ii) (( 3 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_D : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_D  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_D v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_D : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_D : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_D : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Misa_C : Misa -> mword ty1\<close>\<close>

definition get_Misa_C  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_C v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_C : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_C  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_C r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 2 :: int)::ii) (( 2 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_C : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_C  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_C v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_B : Misa -> mword ty1\<close>\<close>

definition get_Misa_B  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_B v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_B : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_B  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_B r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_B : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_B  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_B v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Misa_A : Misa -> mword ty1\<close>\<close>

definition get_Misa_A  :: " Misa \<Rightarrow>(1)Word.word "  where 
     " get_Misa_A v = ( (subrange_vec_dec(Misa_Misa_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Misa "


\<comment> \<open>\<open>val _set_Misa_A : register_ref regstate register_value Misa -> mword ty1 -> M unit\<close>\<close>

definition set_Misa_A  :: "((regstate),(register_value),(Misa))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Misa_A r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Misa_Misa_chunk_0 :=
         ((update_subrange_vec_dec(Misa_Misa_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Misa))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Misa_A : Misa -> mword ty1 -> Misa\<close>\<close>

definition update_Misa_A  :: " Misa \<Rightarrow>(1)Word.word \<Rightarrow> Misa "  where 
     " update_Misa_A v x = (
   (v (|
     Misa_Misa_chunk_0 :=
       ((update_subrange_vec_dec(Misa_Misa_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Misa " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_A : PTE_Bits -> mword ty1 -> PTE_Bits\<close>\<close>

\<comment> \<open>\<open>val _get_PTE_Bits_A : PTE_Bits -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_PTE_Bits_A : register_ref regstate register_value PTE_Bits -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val legalize_misa : Misa -> mword ty32 -> M Misa\<close>\<close>

definition legalize_misa  :: " Misa \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(Misa),(exception))monad "  where 
     " legalize_misa (m :: Misa) (v :: xlenbits) = (
   if ((sys_enable_writable_misa () )) then
     (let v = (Mk_Misa v) in
     and_boolM
       (return (((((get_Misa_C v  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))))
       ((read_reg nextPC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
        return (((((bit_to_bool ((access_vec_dec w__0 (( 1 :: int)::ii))))) = True))))) \<bind> (\<lambda> (w__1 :: bool) . 
     return (if w__1 then m
             else update_Misa_C m ((get_Misa_C v  ::  1 Word.word)))))
   else return m )" 
  for  m  :: " Misa " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val haveAtomics : unit -> M bool\<close>\<close>

definition haveAtomics  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " haveAtomics _ = (
   read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_A w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))"


\<comment> \<open>\<open>val haveRVC : unit -> M bool\<close>\<close>

definition haveRVC  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " haveRVC _ = (
   read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_C w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))"


\<comment> \<open>\<open>val haveMulDiv : unit -> M bool\<close>\<close>

definition haveMulDiv  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " haveMulDiv _ = (
   read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_M w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))"


\<comment> \<open>\<open>val haveSupMode : unit -> M bool\<close>\<close>

definition haveSupMode  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " haveSupMode _ = (
   read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_S w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))"


\<comment> \<open>\<open>val haveUsrMode : unit -> M bool\<close>\<close>

definition haveUsrMode  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " haveUsrMode _ = (
   read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_U w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))"


\<comment> \<open>\<open>val haveNExt : unit -> M bool\<close>\<close>

definition haveNExt  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " haveNExt _ = (
   read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   return (((((get_Misa_N w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))"


\<comment> \<open>\<open>val Mk_Mstatus : mword ty32 -> Mstatus\<close>\<close>

definition Mk_Mstatus  :: "(32)Word.word \<Rightarrow> Mstatus "  where 
     " Mk_Mstatus v = (
   (| Mstatus_Mstatus_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_bits : Mstatus -> mword ty32\<close>\<close>

definition get_Mstatus_bits  :: " Mstatus \<Rightarrow>(32)Word.word "  where 
     " get_Mstatus_bits v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_bits : register_ref regstate register_value Mstatus -> mword ty32 -> M unit\<close>\<close>

definition set_Mstatus_bits  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_bits : Mstatus -> mword ty32 -> Mstatus\<close>\<close>

definition update_Mstatus_bits  :: " Mstatus \<Rightarrow>(32)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_bits v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_SD : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_SD  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_SD v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_SD : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_SD  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_SD r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 31 :: int)::ii) (( 31 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_SD : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_SD  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_SD v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_SD : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_SD : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_SD : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_TSR : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_TSR  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_TSR v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 22 :: int)::ii) (( 22 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_TSR : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_TSR  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_TSR r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 22 :: int)::ii) (( 22 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_TSR : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_TSR  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_TSR v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 22 :: int)::ii) (( 22 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_TW : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_TW  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_TW v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 21 :: int)::ii) (( 21 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_TW : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_TW  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_TW r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 21 :: int)::ii) (( 21 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_TW : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_TW  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_TW v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 21 :: int)::ii) (( 21 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_TVM : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_TVM  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_TVM v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_TVM : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_TVM  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_TVM r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 20 :: int)::ii) (( 20 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_TVM : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_TVM  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_TVM v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 20 :: int)::ii) (( 20 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_MXR : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_MXR  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_MXR v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 19 :: int)::ii) (( 19 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_MXR : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_MXR  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_MXR r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 19 :: int)::ii) (( 19 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_MXR : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_MXR  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_MXR v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 19 :: int)::ii) (( 19 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_MXR : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_MXR : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_MXR : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_SUM : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_SUM  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_SUM v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 18 :: int)::ii) (( 18 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_SUM : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_SUM  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_SUM r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 18 :: int)::ii) (( 18 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_SUM : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_SUM  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_SUM v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 18 :: int)::ii) (( 18 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_SUM : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_SUM : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_SUM : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_MPRV : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_MPRV  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_MPRV v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 17 :: int)::ii) (( 17 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_MPRV : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_MPRV  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_MPRV r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 17 :: int)::ii) (( 17 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_MPRV : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_MPRV  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_MPRV v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 17 :: int)::ii) (( 17 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_XS : Mstatus -> mword ty2\<close>\<close>

definition get_Mstatus_XS  :: " Mstatus \<Rightarrow>(2)Word.word "  where 
     " get_Mstatus_XS v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 16 :: int)::ii) (( 15 :: int)::ii)  ::  2 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_XS : register_ref regstate register_value Mstatus -> mword ty2 -> M unit\<close>\<close>

definition set_Mstatus_XS  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_XS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 16 :: int)::ii) (( 15 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_XS : Mstatus -> mword ty2 -> Mstatus\<close>\<close>

definition update_Mstatus_XS  :: " Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_XS v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 16 :: int)::ii) (( 15 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_XS : Sstatus -> mword ty2 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_XS : Sstatus -> mword ty2\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_XS : register_ref regstate register_value Sstatus -> mword ty2 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_FS : Mstatus -> mword ty2\<close>\<close>

definition get_Mstatus_FS  :: " Mstatus \<Rightarrow>(2)Word.word "  where 
     " get_Mstatus_FS v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_FS : register_ref regstate register_value Mstatus -> mword ty2 -> M unit\<close>\<close>

definition set_Mstatus_FS  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_FS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 14 :: int)::ii) (( 13 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_FS : Mstatus -> mword ty2 -> Mstatus\<close>\<close>

definition update_Mstatus_FS  :: " Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_FS v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 14 :: int)::ii) (( 13 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_FS : Sstatus -> mword ty2 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_FS : Sstatus -> mword ty2\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_FS : register_ref regstate register_value Sstatus -> mword ty2 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_MPP : Mstatus -> mword ty2\<close>\<close>

definition get_Mstatus_MPP  :: " Mstatus \<Rightarrow>(2)Word.word "  where 
     " get_Mstatus_MPP v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 12 :: int)::ii) (( 11 :: int)::ii)  ::  2 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_MPP : register_ref regstate register_value Mstatus -> mword ty2 -> M unit\<close>\<close>

definition set_Mstatus_MPP  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_MPP r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 12 :: int)::ii) (( 11 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_MPP : Mstatus -> mword ty2 -> Mstatus\<close>\<close>

definition update_Mstatus_MPP  :: " Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_MPP v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 12 :: int)::ii) (( 11 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_SPP : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_SPP  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_SPP v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_SPP : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_SPP  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_SPP r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 8 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_SPP : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_SPP  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_SPP v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_SPP : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_SPP : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_SPP : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_MPIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_MPIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_MPIE v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_MPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_MPIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_MPIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 7 :: int)::ii) (( 7 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_MPIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_MPIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_MPIE v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_SPIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_SPIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_SPIE v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_SPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_SPIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_SPIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 5 :: int)::ii) (( 5 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_SPIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_SPIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_SPIE v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_SPIE : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_SPIE : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_SPIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_UPIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_UPIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_UPIE v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_UPIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_UPIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_UPIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 4 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_UPIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_UPIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_UPIE v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Ustatus_UPIE : Ustatus -> mword ty1 -> Ustatus\<close>\<close>

\<comment> \<open>\<open>val _get_Ustatus_UPIE : Ustatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Ustatus_UPIE : register_ref regstate register_value Ustatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_MIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_MIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_MIE v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_MIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_MIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_MIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 3 :: int)::ii) (( 3 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_MIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_MIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_MIE v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mstatus_SIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_SIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_SIE v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_SIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_SIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_SIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_SIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_SIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_SIE v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_SIE : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

\<comment> \<open>\<open>val _get_Sstatus_SIE : Sstatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sstatus_SIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Mstatus_UIE : Mstatus -> mword ty1\<close>\<close>

definition get_Mstatus_UIE  :: " Mstatus \<Rightarrow>(1)Word.word "  where 
     " get_Mstatus_UIE v = ( (subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mstatus "


\<comment> \<open>\<open>val _set_Mstatus_UIE : register_ref regstate register_value Mstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Mstatus_UIE  :: "((regstate),(register_value),(Mstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mstatus_UIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mstatus_Mstatus_chunk_0 :=
         ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mstatus_UIE : Mstatus -> mword ty1 -> Mstatus\<close>\<close>

definition update_Mstatus_UIE  :: " Mstatus \<Rightarrow>(1)Word.word \<Rightarrow> Mstatus "  where 
     " update_Mstatus_UIE v x = (
   (v (|
     Mstatus_Mstatus_chunk_0 :=
       ((update_subrange_vec_dec(Mstatus_Mstatus_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Ustatus_UIE : Ustatus -> mword ty1 -> Ustatus\<close>\<close>

\<comment> \<open>\<open>val _get_Ustatus_UIE : Ustatus -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Ustatus_UIE : register_ref regstate register_value Ustatus -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val effectivePrivilege : Mstatus -> Privilege -> M Privilege\<close>\<close>

definition effectivePrivilege  :: " Mstatus \<Rightarrow> Privilege \<Rightarrow>((register_value),(Privilege),(exception))monad "  where 
     " effectivePrivilege (m :: Mstatus) (priv :: Privilege) = (
   if (((((get_Mstatus_MPRV m  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
     read_reg mstatus_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
     privLevel_of_bits ((get_Mstatus_MPP w__0  ::  2 Word.word)))
   else read_reg cur_privilege_ref )" 
  for  m  :: " Mstatus " 
  and  priv  :: " Privilege "


\<comment> \<open>\<open>val get_mstatus_SXL : Mstatus -> mword ty2\<close>\<close>

definition get_mstatus_SXL  :: " Mstatus \<Rightarrow>(2)Word.word "  where 
     " get_mstatus_SXL m = ( (arch_to_bits RV32  ::  2 Word.word))" 
  for  m  :: " Mstatus "


\<comment> \<open>\<open>val set_mstatus_SXL : Mstatus -> mword ty2 -> Mstatus\<close>\<close>

definition set_mstatus_SXL  :: " Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus "  where 
     " set_mstatus_SXL (m :: Mstatus) (a :: arch_xlen) = ( m )" 
  for  m  :: " Mstatus " 
  and  a  :: "(2)Word.word "


\<comment> \<open>\<open>val get_mstatus_UXL : Mstatus -> mword ty2\<close>\<close>

definition get_mstatus_UXL  :: " Mstatus \<Rightarrow>(2)Word.word "  where 
     " get_mstatus_UXL m = ( (arch_to_bits RV32  ::  2 Word.word))" 
  for  m  :: " Mstatus "


\<comment> \<open>\<open>val set_mstatus_UXL : Mstatus -> mword ty2 -> Mstatus\<close>\<close>

definition set_mstatus_UXL  :: " Mstatus \<Rightarrow>(2)Word.word \<Rightarrow> Mstatus "  where 
     " set_mstatus_UXL (m :: Mstatus) (a :: arch_xlen) = ( m )" 
  for  m  :: " Mstatus " 
  and  a  :: "(2)Word.word "


\<comment> \<open>\<open>val legalize_mstatus : Mstatus -> mword ty32 -> M Mstatus\<close>\<close>

definition legalize_mstatus  :: " Mstatus \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(Mstatus),(exception))monad "  where 
     " legalize_mstatus (o1 :: Mstatus) (v :: xlenbits) = (
   (let (m :: Mstatus) = (Mk_Mstatus v) in
   (let m = (update_Mstatus_XS m ((extStatus_to_bits Off  ::  2 Word.word))) in
   or_boolM
     (extStatus_of_bits ((get_Mstatus_FS m  ::  2 Word.word)) \<bind> (\<lambda> (w__0 :: ExtStatus) . 
      return (((((extStatus_to_bits w__0  ::  2 Word.word)) = ((extStatus_to_bits Dirty  ::  2 Word.word)))))))
     (extStatus_of_bits ((get_Mstatus_XS m  ::  2 Word.word)) \<bind> (\<lambda> (w__1 :: ExtStatus) . 
      return (((((extStatus_to_bits w__1  ::  2 Word.word)) = ((extStatus_to_bits Dirty  ::  2 Word.word))))))) \<bind> (\<lambda> (w__2 :: bool) . 
   (let m = (update_Mstatus_SD m ((bool_to_bits w__2  ::  1 Word.word))) in
   (let m = (set_mstatus_SXL m ((get_mstatus_SXL o1  ::  2 Word.word))) in
   (let m = (set_mstatus_UXL m ((get_mstatus_UXL o1  ::  2 Word.word))) in
   (let m = (update_Mstatus_UPIE m ((bool_to_bits False  ::  1 Word.word))) in
   (let m = (update_Mstatus_UIE m ((bool_to_bits False  ::  1 Word.word))) in
   return m)))))))))" 
  for  o1  :: " Mstatus " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val cur_Architecture : unit -> M Architecture\<close>\<close>

definition cur_Architecture  :: " unit \<Rightarrow>((register_value),(Architecture),(exception))monad "  where 
     " cur_Architecture _ = (
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (case  w__0 of
     Machine =>
      read_reg misa_ref \<bind> (\<lambda> (w__1 :: Misa) .  return ((get_Misa_MXL w__1  ::  2 Word.word)))
   | Supervisor =>
      read_reg mstatus_ref \<bind> (\<lambda> (w__2 :: Mstatus) .  return ((get_mstatus_SXL w__2  ::  2 Word.word)))
   | User =>
      read_reg mstatus_ref \<bind> (\<lambda> (w__3 :: Mstatus) .  return ((get_mstatus_UXL w__3  ::  2 Word.word)))
   ) \<bind> (\<lambda> (a :: arch_xlen) . 
   (case  ((architecture a)) of
     Some (a) => return a
   | None => internal_error (''Invalid current architecture'')
   ))))"


\<comment> \<open>\<open>val in32BitMode : unit -> M bool\<close>\<close>

definition in32BitMode  :: " unit \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " in32BitMode _ = ( cur_Architecture ()  \<bind> (\<lambda> (w__0 :: Architecture) .  return (((w__0 = RV32)))))"


\<comment> \<open>\<open>val Mk_Minterrupts : mword ty32 -> Minterrupts\<close>\<close>

definition Mk_Minterrupts  :: "(32)Word.word \<Rightarrow> Minterrupts "  where 
     " Mk_Minterrupts v = (
   (| Minterrupts_Minterrupts_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Minterrupts_bits : Minterrupts -> mword ty32\<close>\<close>

definition get_Minterrupts_bits  :: " Minterrupts \<Rightarrow>(32)Word.word "  where 
     " get_Minterrupts_bits v = (
   (subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_bits : register_ref regstate register_value Minterrupts -> mword ty32 -> M unit\<close>\<close>

definition set_Minterrupts_bits  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Minterrupts_Minterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_bits : Minterrupts -> mword ty32 -> Minterrupts\<close>\<close>

definition update_Minterrupts_bits  :: " Minterrupts \<Rightarrow>(32)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_bits v x = (
   (v (|
     Minterrupts_Minterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Minterrupts " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Minterrupts_MEI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_MEI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_MEI v = (
   (subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_MEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_MEI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_MEI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Minterrupts_Minterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   r) (( 11 :: int)::ii) (( 11 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_MEI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_MEI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_MEI v x = (
   (v (|
     Minterrupts_Minterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 11 :: int)::ii) (( 11 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Minterrupts_SEI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_SEI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_SEI v = (
   (subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_SEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_SEI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_SEI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Minterrupts_Minterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   r) (( 9 :: int)::ii) (( 9 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_SEI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_SEI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_SEI v x = (
   (v (|
     Minterrupts_Minterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 9 :: int)::ii) (( 9 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_SEI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Sinterrupts_SEI : Sinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sinterrupts_SEI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Minterrupts_UEI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_UEI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_UEI v = (
   (subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_UEI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_UEI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_UEI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Minterrupts_Minterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   r) (( 8 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_UEI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_UEI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_UEI v x = (
   (v (|
     Minterrupts_Minterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Uinterrupts_UEI : Uinterrupts -> mword ty1 -> Uinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Uinterrupts_UEI : Uinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Uinterrupts_UEI : register_ref regstate register_value Uinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Minterrupts_MTI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_MTI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_MTI v = (
   (subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_MTI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_MTI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_MTI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Minterrupts_Minterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   r) (( 7 :: int)::ii) (( 7 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_MTI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_MTI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_MTI v x = (
   (v (|
     Minterrupts_Minterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Minterrupts_STI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_STI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_STI v = (
   (subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_STI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_STI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_STI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Minterrupts_Minterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   r) (( 5 :: int)::ii) (( 5 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_STI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_STI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_STI v x = (
   (v (|
     Minterrupts_Minterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_STI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Sinterrupts_STI : Sinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sinterrupts_STI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Minterrupts_UTI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_UTI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_UTI v = (
   (subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_UTI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_UTI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_UTI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Minterrupts_Minterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   r) (( 4 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_UTI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_UTI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_UTI v x = (
   (v (|
     Minterrupts_Minterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Uinterrupts_UTI : Uinterrupts -> mword ty1 -> Uinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Uinterrupts_UTI : Uinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Uinterrupts_UTI : register_ref regstate register_value Uinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Minterrupts_MSI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_MSI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_MSI v = (
   (subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_MSI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_MSI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_MSI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Minterrupts_Minterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   r) (( 3 :: int)::ii) (( 3 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_MSI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_MSI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_MSI v x = (
   (v (|
     Minterrupts_Minterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Minterrupts_SSI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_SSI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_SSI v = (
   (subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_SSI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_SSI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_SSI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Minterrupts_Minterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_SSI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_SSI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_SSI v x = (
   (v (|
     Minterrupts_Minterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_SSI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Sinterrupts_SSI : Sinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sinterrupts_SSI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Minterrupts_USI : Minterrupts -> mword ty1\<close>\<close>

definition get_Minterrupts_USI  :: " Minterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Minterrupts_USI v = (
   (subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Minterrupts "


\<comment> \<open>\<open>val _set_Minterrupts_USI : register_ref regstate register_value Minterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Minterrupts_USI  :: "((regstate),(register_value),(Minterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Minterrupts_USI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Minterrupts_Minterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Minterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Minterrupts_USI : Minterrupts -> mword ty1 -> Minterrupts\<close>\<close>

definition update_Minterrupts_USI  :: " Minterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Minterrupts "  where 
     " update_Minterrupts_USI v x = (
   (v (|
     Minterrupts_Minterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Minterrupts_Minterrupts_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Minterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Uinterrupts_USI : Uinterrupts -> mword ty1 -> Uinterrupts\<close>\<close>

\<comment> \<open>\<open>val _get_Uinterrupts_USI : Uinterrupts -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Uinterrupts_USI : register_ref regstate register_value Uinterrupts -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val legalize_mip : Minterrupts -> mword ty32 -> M Minterrupts\<close>\<close>

definition legalize_mip  :: " Minterrupts \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(Minterrupts),(exception))monad "  where 
     " legalize_mip (o1 :: Minterrupts) (v :: xlenbits) = (
   (let v = (Mk_Minterrupts v) in
   (let m = (update_Minterrupts_SEI o1 ((get_Minterrupts_SEI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_STI m ((get_Minterrupts_STI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_SSI m ((get_Minterrupts_SSI v  ::  1 Word.word))) in
   haveUsrMode ()  \<bind> (\<lambda> (w__0 :: bool) . 
   return (if w__0 then
             (let m = (update_Minterrupts_UEI m ((get_Minterrupts_UEI v  ::  1 Word.word))) in
             (let m = (update_Minterrupts_UTI m ((get_Minterrupts_UTI v  ::  1 Word.word))) in
             update_Minterrupts_USI m ((get_Minterrupts_USI v  ::  1 Word.word))))
           else m)))))))" 
  for  o1  :: " Minterrupts " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val legalize_mie : Minterrupts -> mword ty32 -> M Minterrupts\<close>\<close>

definition legalize_mie  :: " Minterrupts \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(Minterrupts),(exception))monad "  where 
     " legalize_mie (o1 :: Minterrupts) (v :: xlenbits) = (
   (let v = (Mk_Minterrupts v) in
   (let m = (update_Minterrupts_MEI o1 ((get_Minterrupts_MEI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_MTI m ((get_Minterrupts_MTI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_MSI m ((get_Minterrupts_MSI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_SEI m ((get_Minterrupts_SEI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_STI m ((get_Minterrupts_STI v  ::  1 Word.word))) in
   (let m = (update_Minterrupts_SSI m ((get_Minterrupts_SSI v  ::  1 Word.word))) in
   haveUsrMode ()  \<bind> (\<lambda> (w__0 :: bool) . 
   return (if w__0 then
             (let m = (update_Minterrupts_UEI m ((get_Minterrupts_UEI v  ::  1 Word.word))) in
             (let m = (update_Minterrupts_UTI m ((get_Minterrupts_UTI v  ::  1 Word.word))) in
             update_Minterrupts_USI m ((get_Minterrupts_USI v  ::  1 Word.word))))
           else m))))))))))" 
  for  o1  :: " Minterrupts " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val legalize_mideleg : Minterrupts -> mword ty32 -> Minterrupts\<close>\<close>

definition legalize_mideleg  :: " Minterrupts \<Rightarrow>(32)Word.word \<Rightarrow> Minterrupts "  where 
     " legalize_mideleg (o1 :: Minterrupts) (v :: xlenbits) = (
   (let m = (Mk_Minterrupts v) in
   (let m = (update_Minterrupts_MEI m ((bool_to_bits False  ::  1 Word.word))) in
   (let m = (update_Minterrupts_MTI m ((bool_to_bits False  ::  1 Word.word))) in
   update_Minterrupts_MSI m ((bool_to_bits False  ::  1 Word.word))))))" 
  for  o1  :: " Minterrupts " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val Mk_Medeleg : mword ty32 -> Medeleg\<close>\<close>

definition Mk_Medeleg  :: "(32)Word.word \<Rightarrow> Medeleg "  where 
     " Mk_Medeleg v = (
   (| Medeleg_Medeleg_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_bits : Medeleg -> mword ty32\<close>\<close>

definition get_Medeleg_bits  :: " Medeleg \<Rightarrow>(32)Word.word "  where 
     " get_Medeleg_bits v = ( (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_bits : register_ref regstate register_value Medeleg -> mword ty32 -> M unit\<close>\<close>

definition set_Medeleg_bits  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_bits : Medeleg -> mword ty32 -> Medeleg\<close>\<close>

definition update_Medeleg_bits  :: " Medeleg \<Rightarrow>(32)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_bits v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_SAMO_Page_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_SAMO_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_SAMO_Page_Fault v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 15 :: int)::ii) (( 15 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_SAMO_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_SAMO_Page_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_SAMO_Page_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 15 :: int)::ii) (( 15 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_SAMO_Page_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_SAMO_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_SAMO_Page_Fault v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 15 :: int)::ii) (( 15 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_Load_Page_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Load_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Load_Page_Fault v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 13 :: int)::ii) (( 13 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Load_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Load_Page_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Load_Page_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 13 :: int)::ii) (( 13 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Load_Page_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Load_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Load_Page_Fault v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 13 :: int)::ii) (( 13 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_Fetch_Page_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Fetch_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Fetch_Page_Fault v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Fetch_Page_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Fetch_Page_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Fetch_Page_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 12 :: int)::ii) (( 12 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Fetch_Page_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Fetch_Page_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Fetch_Page_Fault v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 12 :: int)::ii) (( 12 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_MEnvCall : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_MEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_MEnvCall v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_MEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_MEnvCall  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_MEnvCall r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 10 :: int)::ii) (( 10 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_MEnvCall : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_MEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_MEnvCall v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 10 :: int)::ii) (( 10 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_SEnvCall : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_SEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_SEnvCall v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_SEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_SEnvCall  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_SEnvCall r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 9 :: int)::ii) (( 9 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_SEnvCall : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_SEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_SEnvCall v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 9 :: int)::ii) (( 9 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Medeleg_UEnvCall : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_UEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_UEnvCall v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_UEnvCall : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_UEnvCall  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_UEnvCall r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 8 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_UEnvCall : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_UEnvCall  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_UEnvCall v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_UEnvCall : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_UEnvCall : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_UEnvCall : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_SAMO_Access_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_SAMO_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_SAMO_Access_Fault v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_SAMO_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_SAMO_Access_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_SAMO_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 7 :: int)::ii) (( 7 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_SAMO_Access_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_SAMO_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_SAMO_Access_Fault v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_SAMO_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_SAMO_Access_Fault : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_SAMO_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_SAMO_Addr_Align : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_SAMO_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_SAMO_Addr_Align v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_SAMO_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_SAMO_Addr_Align  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_SAMO_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 6 :: int)::ii) (( 6 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_SAMO_Addr_Align : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_SAMO_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_SAMO_Addr_Align v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 6 :: int)::ii) (( 6 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_SAMO_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_SAMO_Addr_Align : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_SAMO_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Load_Access_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Load_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Load_Access_Fault v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Load_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Load_Access_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Load_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 5 :: int)::ii) (( 5 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Load_Access_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Load_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Load_Access_Fault v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Load_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Load_Access_Fault : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Load_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Load_Addr_Align : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Load_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Load_Addr_Align v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Load_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Load_Addr_Align  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Load_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 4 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Load_Addr_Align : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Load_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Load_Addr_Align v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Load_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Load_Addr_Align : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Load_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Breakpoint : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Breakpoint  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Breakpoint v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Breakpoint : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Breakpoint  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Breakpoint r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 3 :: int)::ii) (( 3 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Breakpoint : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Breakpoint  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Breakpoint v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Breakpoint : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Breakpoint : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Breakpoint : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Illegal_Instr : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Illegal_Instr  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Illegal_Instr v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Illegal_Instr : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Illegal_Instr  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Illegal_Instr r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 2 :: int)::ii) (( 2 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Illegal_Instr : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Illegal_Instr  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Illegal_Instr v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Illegal_Instr : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Illegal_Instr : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Illegal_Instr : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Fetch_Access_Fault : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Fetch_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Fetch_Access_Fault v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Fetch_Access_Fault : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Fetch_Access_Fault  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Fetch_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Fetch_Access_Fault : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Fetch_Access_Fault  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Fetch_Access_Fault v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Fetch_Access_Fault : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Fetch_Access_Fault : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Fetch_Access_Fault : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Medeleg_Fetch_Addr_Align : Medeleg -> mword ty1\<close>\<close>

definition get_Medeleg_Fetch_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word "  where 
     " get_Medeleg_Fetch_Addr_Align v = (
   (subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Medeleg "


\<comment> \<open>\<open>val _set_Medeleg_Fetch_Addr_Align : register_ref regstate register_value Medeleg -> mword ty1 -> M unit\<close>\<close>

definition set_Medeleg_Fetch_Addr_Align  :: "((regstate),(register_value),(Medeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Medeleg_Fetch_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Medeleg_Medeleg_chunk_0 :=
         ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Medeleg))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Medeleg_Fetch_Addr_Align : Medeleg -> mword ty1 -> Medeleg\<close>\<close>

definition update_Medeleg_Fetch_Addr_Align  :: " Medeleg \<Rightarrow>(1)Word.word \<Rightarrow> Medeleg "  where 
     " update_Medeleg_Fetch_Addr_Align v x = (
   (v (|
     Medeleg_Medeleg_chunk_0 :=
       ((update_subrange_vec_dec(Medeleg_Medeleg_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Medeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_Fetch_Addr_Align : Sedeleg -> mword ty1 -> Sedeleg\<close>\<close>

\<comment> \<open>\<open>val _get_Sedeleg_Fetch_Addr_Align : Sedeleg -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Sedeleg_Fetch_Addr_Align : register_ref regstate register_value Sedeleg -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val legalize_medeleg : Medeleg -> mword ty32 -> Medeleg\<close>\<close>

definition legalize_medeleg  :: " Medeleg \<Rightarrow>(32)Word.word \<Rightarrow> Medeleg "  where 
     " legalize_medeleg (o1 :: Medeleg) (v :: xlenbits) = (
   (let m = (Mk_Medeleg v) in
   update_Medeleg_MEnvCall m ((bool_to_bits False  ::  1 Word.word))))" 
  for  o1  :: " Medeleg " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val Mk_Mtvec : mword ty32 -> Mtvec\<close>\<close>

definition Mk_Mtvec  :: "(32)Word.word \<Rightarrow> Mtvec "  where 
     " Mk_Mtvec v = ( (| Mtvec_Mtvec_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Mtvec_bits : Mtvec -> mword ty32\<close>\<close>

definition get_Mtvec_bits  :: " Mtvec \<Rightarrow>(32)Word.word "  where 
     " get_Mtvec_bits v = ( (subrange_vec_dec(Mtvec_Mtvec_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Mtvec "


\<comment> \<open>\<open>val _set_Mtvec_bits : register_ref regstate register_value Mtvec -> mword ty32 -> M unit\<close>\<close>

definition set_Mtvec_bits  :: "((regstate),(register_value),(Mtvec))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mtvec_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mtvec_Mtvec_chunk_0 :=
         ((update_subrange_vec_dec(Mtvec_Mtvec_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mtvec))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Mtvec_bits : Mtvec -> mword ty32 -> Mtvec\<close>\<close>

definition update_Mtvec_bits  :: " Mtvec \<Rightarrow>(32)Word.word \<Rightarrow> Mtvec "  where 
     " update_Mtvec_bits v x = (
   (v (|
     Mtvec_Mtvec_chunk_0 :=
       ((update_subrange_vec_dec(Mtvec_Mtvec_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mtvec " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Mtvec_Base : Mtvec -> mword ty30\<close>\<close>

definition get_Mtvec_Base  :: " Mtvec \<Rightarrow>(30)Word.word "  where 
     " get_Mtvec_Base v = ( (subrange_vec_dec(Mtvec_Mtvec_chunk_0   v) (( 31 :: int)::ii) (( 2 :: int)::ii)  ::  30 Word.word))" 
  for  v  :: " Mtvec "


\<comment> \<open>\<open>val _set_Mtvec_Base : register_ref regstate register_value Mtvec -> mword ty30 -> M unit\<close>\<close>

definition set_Mtvec_Base  :: "((regstate),(register_value),(Mtvec))register_ref \<Rightarrow>(30)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mtvec_Base r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mtvec_Mtvec_chunk_0 :=
         ((update_subrange_vec_dec(Mtvec_Mtvec_chunk_0   r) (( 31 :: int)::ii) (( 2 :: int)::ii)
             ((subrange_vec_dec v (( 29 :: int)::ii) (( 0 :: int)::ii)  ::  30 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mtvec))register_ref " 
  and  v  :: "(30)Word.word "


\<comment> \<open>\<open>val _update_Mtvec_Base : Mtvec -> mword ty30 -> Mtvec\<close>\<close>

definition update_Mtvec_Base  :: " Mtvec \<Rightarrow>(30)Word.word \<Rightarrow> Mtvec "  where 
     " update_Mtvec_Base v x = (
   (v (|
     Mtvec_Mtvec_chunk_0 :=
       ((update_subrange_vec_dec(Mtvec_Mtvec_chunk_0   v) (( 31 :: int)::ii) (( 2 :: int)::ii)
           ((subrange_vec_dec x (( 29 :: int)::ii) (( 0 :: int)::ii)  ::  30 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mtvec " 
  and  x  :: "(30)Word.word "


\<comment> \<open>\<open>val _get_Mtvec_Mode : Mtvec -> mword ty2\<close>\<close>

definition get_Mtvec_Mode  :: " Mtvec \<Rightarrow>(2)Word.word "  where 
     " get_Mtvec_Mode v = ( (subrange_vec_dec(Mtvec_Mtvec_chunk_0   v) (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))" 
  for  v  :: " Mtvec "


\<comment> \<open>\<open>val _set_Mtvec_Mode : register_ref regstate register_value Mtvec -> mword ty2 -> M unit\<close>\<close>

definition set_Mtvec_Mode  :: "((regstate),(register_value),(Mtvec))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mtvec_Mode r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mtvec_Mtvec_chunk_0 :=
         ((update_subrange_vec_dec(Mtvec_Mtvec_chunk_0   r) (( 1 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mtvec))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Mtvec_Mode : Mtvec -> mword ty2 -> Mtvec\<close>\<close>

definition update_Mtvec_Mode  :: " Mtvec \<Rightarrow>(2)Word.word \<Rightarrow> Mtvec "  where 
     " update_Mtvec_Mode v x = (
   (v (|
     Mtvec_Mtvec_chunk_0 :=
       ((update_subrange_vec_dec(Mtvec_Mtvec_chunk_0   v) (( 1 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mtvec " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Satp32_Mode : Satp32 -> mword ty1 -> Satp32\<close>\<close>

\<comment> \<open>\<open>val _get_Satp32_Mode : Satp32 -> mword ty1\<close>\<close>

\<comment> \<open>\<open>val _set_Satp32_Mode : register_ref regstate register_value Satp32 -> mword ty1 -> M unit\<close>\<close>

\<comment> \<open>\<open>val legalize_tvec : Mtvec -> mword ty32 -> Mtvec\<close>\<close>

definition legalize_tvec  :: " Mtvec \<Rightarrow>(32)Word.word \<Rightarrow> Mtvec "  where 
     " legalize_tvec (o1 :: Mtvec) (v :: xlenbits) = (
   (let v = (Mk_Mtvec v) in
   (case  ((trapVectorMode_of_bits ((get_Mtvec_Mode v  ::  2 Word.word)))) of
     TV_Direct => v
   | TV_Vector => v
   | _ => update_Mtvec_Mode v ((get_Mtvec_Mode o1  ::  2 Word.word))
   )))" 
  for  o1  :: " Mtvec " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val Mk_Mcause : mword ty32 -> Mcause\<close>\<close>

definition Mk_Mcause  :: "(32)Word.word \<Rightarrow> Mcause "  where 
     " Mk_Mcause v = ( (| Mcause_Mcause_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Mcause_bits : Mcause -> mword ty32\<close>\<close>

definition get_Mcause_bits  :: " Mcause \<Rightarrow>(32)Word.word "  where 
     " get_Mcause_bits v = ( (subrange_vec_dec(Mcause_Mcause_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Mcause "


\<comment> \<open>\<open>val _set_Mcause_bits : register_ref regstate register_value Mcause -> mword ty32 -> M unit\<close>\<close>

definition set_Mcause_bits  :: "((regstate),(register_value),(Mcause))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mcause_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mcause_Mcause_chunk_0 :=
         ((update_subrange_vec_dec(Mcause_Mcause_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mcause))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Mcause_bits : Mcause -> mword ty32 -> Mcause\<close>\<close>

definition update_Mcause_bits  :: " Mcause \<Rightarrow>(32)Word.word \<Rightarrow> Mcause "  where 
     " update_Mcause_bits v x = (
   (v (|
     Mcause_Mcause_chunk_0 :=
       ((update_subrange_vec_dec(Mcause_Mcause_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mcause " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Mcause_IsInterrupt : Mcause -> mword ty1\<close>\<close>

definition get_Mcause_IsInterrupt  :: " Mcause \<Rightarrow>(1)Word.word "  where 
     " get_Mcause_IsInterrupt v = (
   (subrange_vec_dec(Mcause_Mcause_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Mcause "


\<comment> \<open>\<open>val _set_Mcause_IsInterrupt : register_ref regstate register_value Mcause -> mword ty1 -> M unit\<close>\<close>

definition set_Mcause_IsInterrupt  :: "((regstate),(register_value),(Mcause))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mcause_IsInterrupt r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mcause_Mcause_chunk_0 :=
         ((update_subrange_vec_dec(Mcause_Mcause_chunk_0   r) (( 31 :: int)::ii) (( 31 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mcause))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Mcause_IsInterrupt : Mcause -> mword ty1 -> Mcause\<close>\<close>

definition update_Mcause_IsInterrupt  :: " Mcause \<Rightarrow>(1)Word.word \<Rightarrow> Mcause "  where 
     " update_Mcause_IsInterrupt v x = (
   (v (|
     Mcause_Mcause_chunk_0 :=
       ((update_subrange_vec_dec(Mcause_Mcause_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mcause " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Mcause_Cause : Mcause -> mword ty31\<close>\<close>

definition get_Mcause_Cause  :: " Mcause \<Rightarrow>(31)Word.word "  where 
     " get_Mcause_Cause v = ( (subrange_vec_dec(Mcause_Mcause_chunk_0   v) (( 30 :: int)::ii) (( 0 :: int)::ii)  ::  31 Word.word))" 
  for  v  :: " Mcause "


\<comment> \<open>\<open>val _set_Mcause_Cause : register_ref regstate register_value Mcause -> mword ty31 -> M unit\<close>\<close>

definition set_Mcause_Cause  :: "((regstate),(register_value),(Mcause))register_ref \<Rightarrow>(31)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Mcause_Cause r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Mcause_Mcause_chunk_0 :=
         ((update_subrange_vec_dec(Mcause_Mcause_chunk_0   r) (( 30 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 30 :: int)::ii) (( 0 :: int)::ii)  ::  31 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Mcause))register_ref " 
  and  v  :: "(31)Word.word "


\<comment> \<open>\<open>val _update_Mcause_Cause : Mcause -> mword ty31 -> Mcause\<close>\<close>

definition update_Mcause_Cause  :: " Mcause \<Rightarrow>(31)Word.word \<Rightarrow> Mcause "  where 
     " update_Mcause_Cause v x = (
   (v (|
     Mcause_Mcause_chunk_0 :=
       ((update_subrange_vec_dec(Mcause_Mcause_chunk_0   v) (( 30 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 30 :: int)::ii) (( 0 :: int)::ii)  ::  31 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Mcause " 
  and  x  :: "(31)Word.word "


\<comment> \<open>\<open>val tvec_addr : Mtvec -> Mcause -> maybe (mword ty32)\<close>\<close>

definition tvec_addr  :: " Mtvec \<Rightarrow> Mcause \<Rightarrow>((32)Word.word)option "  where 
     " tvec_addr (m :: Mtvec) (c :: Mcause) = (
   (let (base :: xlenbits) =
     ((concat_vec ((get_Mtvec_Base m  ::  30 Word.word)) (vec_of_bits [B0,B0]  ::  2 Word.word)
       ::  32 Word.word)) in
   (case  ((trapVectorMode_of_bits ((get_Mtvec_Mode m  ::  2 Word.word)))) of
     TV_Direct => Some base
   | TV_Vector =>
      if (((((get_Mcause_IsInterrupt c  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
      then
        Some ((add_vec base
                 ((shiftl ((EXTZ (( 32 :: int)::ii) ((get_Mcause_Cause c  ::  31 Word.word))  ::  32 Word.word))
                     (( 2 :: int)::ii)
                    ::  32 Word.word))
                ::  32 Word.word))
      else Some base
   | TV_Reserved => None
   )))" 
  for  m  :: " Mtvec " 
  and  c  :: " Mcause "


\<comment> \<open>\<open>val legalize_xepc : mword ty32 -> M (mword ty32)\<close>\<close>

definition legalize_xepc  :: "(32)Word.word \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " legalize_xepc v = (
   or_boolM (return ((sys_enable_writable_misa () )))
     (read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
      return (((((get_Misa_C w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))))) \<bind> (\<lambda> (w__1 ::
     bool) . 
   return (if w__1 then (update_vec_dec v (( 0 :: int)::ii) B0  ::  32 Word.word)
           else
             (and_vec v ((EXTS (( 32 :: int)::ii) (vec_of_bits [B1,B0,B0]  ::  3 Word.word)  ::  32 Word.word))
               ::  32 Word.word))))" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val pc_alignment_mask : unit -> M (mword ty32)\<close>\<close>

definition pc_alignment_mask  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " pc_alignment_mask _ = (
   read_reg misa_ref \<bind> (\<lambda> (w__0 :: Misa) . 
   return ((not_vec
              ((EXTZ (( 32 :: int)::ii)
                  (if (((((get_Misa_C w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
                   then
                     (vec_of_bits [B0,B0]  ::  2 Word.word)
                   else (vec_of_bits [B1,B0]  ::  2 Word.word))
                 ::  32 Word.word))
             ::  32 Word.word))))"


\<comment> \<open>\<open>val Mk_Counteren : mword ty32 -> Counteren\<close>\<close>

definition Mk_Counteren  :: "(32)Word.word \<Rightarrow> Counteren "  where 
     " Mk_Counteren v = (
   (| Counteren_Counteren_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Counteren_bits : Counteren -> mword ty32\<close>\<close>

definition get_Counteren_bits  :: " Counteren \<Rightarrow>(32)Word.word "  where 
     " get_Counteren_bits v = (
   (subrange_vec_dec(Counteren_Counteren_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Counteren "


\<comment> \<open>\<open>val _set_Counteren_bits : register_ref regstate register_value Counteren -> mword ty32 -> M unit\<close>\<close>

definition set_Counteren_bits  :: "((regstate),(register_value),(Counteren))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Counteren_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Counteren_Counteren_chunk_0 :=
         ((update_subrange_vec_dec(Counteren_Counteren_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Counteren))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Counteren_bits : Counteren -> mword ty32 -> Counteren\<close>\<close>

definition update_Counteren_bits  :: " Counteren \<Rightarrow>(32)Word.word \<Rightarrow> Counteren "  where 
     " update_Counteren_bits v x = (
   (v (|
     Counteren_Counteren_chunk_0 :=
       ((update_subrange_vec_dec(Counteren_Counteren_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Counteren " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Counteren_HPM : Counteren -> mword ty29\<close>\<close>

definition get_Counteren_HPM  :: " Counteren \<Rightarrow>(29)Word.word "  where 
     " get_Counteren_HPM v = (
   (subrange_vec_dec(Counteren_Counteren_chunk_0   v) (( 31 :: int)::ii) (( 3 :: int)::ii)  ::  29 Word.word))" 
  for  v  :: " Counteren "


\<comment> \<open>\<open>val _set_Counteren_HPM : register_ref regstate register_value Counteren -> mword ty29 -> M unit\<close>\<close>

definition set_Counteren_HPM  :: "((regstate),(register_value),(Counteren))register_ref \<Rightarrow>(29)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Counteren_HPM r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Counteren_Counteren_chunk_0 :=
         ((update_subrange_vec_dec(Counteren_Counteren_chunk_0   r) (( 31 :: int)::ii) (( 3 :: int)::ii)
             ((subrange_vec_dec v (( 28 :: int)::ii) (( 0 :: int)::ii)  ::  29 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Counteren))register_ref " 
  and  v  :: "(29)Word.word "


\<comment> \<open>\<open>val _update_Counteren_HPM : Counteren -> mword ty29 -> Counteren\<close>\<close>

definition update_Counteren_HPM  :: " Counteren \<Rightarrow>(29)Word.word \<Rightarrow> Counteren "  where 
     " update_Counteren_HPM v x = (
   (v (|
     Counteren_Counteren_chunk_0 :=
       ((update_subrange_vec_dec(Counteren_Counteren_chunk_0   v) (( 31 :: int)::ii) (( 3 :: int)::ii)
           ((subrange_vec_dec x (( 28 :: int)::ii) (( 0 :: int)::ii)  ::  29 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Counteren " 
  and  x  :: "(29)Word.word "


\<comment> \<open>\<open>val _get_Counteren_IR : Counteren -> mword ty1\<close>\<close>

definition get_Counteren_IR  :: " Counteren \<Rightarrow>(1)Word.word "  where 
     " get_Counteren_IR v = (
   (subrange_vec_dec(Counteren_Counteren_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Counteren "


\<comment> \<open>\<open>val _set_Counteren_IR : register_ref regstate register_value Counteren -> mword ty1 -> M unit\<close>\<close>

definition set_Counteren_IR  :: "((regstate),(register_value),(Counteren))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Counteren_IR r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Counteren_Counteren_chunk_0 :=
         ((update_subrange_vec_dec(Counteren_Counteren_chunk_0   r) (( 2 :: int)::ii) (( 2 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Counteren))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Counteren_IR : Counteren -> mword ty1 -> Counteren\<close>\<close>

definition update_Counteren_IR  :: " Counteren \<Rightarrow>(1)Word.word \<Rightarrow> Counteren "  where 
     " update_Counteren_IR v x = (
   (v (|
     Counteren_Counteren_chunk_0 :=
       ((update_subrange_vec_dec(Counteren_Counteren_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Counteren " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Counteren_TM : Counteren -> mword ty1\<close>\<close>

definition get_Counteren_TM  :: " Counteren \<Rightarrow>(1)Word.word "  where 
     " get_Counteren_TM v = (
   (subrange_vec_dec(Counteren_Counteren_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Counteren "


\<comment> \<open>\<open>val _set_Counteren_TM : register_ref regstate register_value Counteren -> mword ty1 -> M unit\<close>\<close>

definition set_Counteren_TM  :: "((regstate),(register_value),(Counteren))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Counteren_TM r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Counteren_Counteren_chunk_0 :=
         ((update_subrange_vec_dec(Counteren_Counteren_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Counteren))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Counteren_TM : Counteren -> mword ty1 -> Counteren\<close>\<close>

definition update_Counteren_TM  :: " Counteren \<Rightarrow>(1)Word.word \<Rightarrow> Counteren "  where 
     " update_Counteren_TM v x = (
   (v (|
     Counteren_Counteren_chunk_0 :=
       ((update_subrange_vec_dec(Counteren_Counteren_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Counteren " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Counteren_CY : Counteren -> mword ty1\<close>\<close>

definition get_Counteren_CY  :: " Counteren \<Rightarrow>(1)Word.word "  where 
     " get_Counteren_CY v = (
   (subrange_vec_dec(Counteren_Counteren_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Counteren "


\<comment> \<open>\<open>val _set_Counteren_CY : register_ref regstate register_value Counteren -> mword ty1 -> M unit\<close>\<close>

definition set_Counteren_CY  :: "((regstate),(register_value),(Counteren))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Counteren_CY r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Counteren_Counteren_chunk_0 :=
         ((update_subrange_vec_dec(Counteren_Counteren_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Counteren))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Counteren_CY : Counteren -> mword ty1 -> Counteren\<close>\<close>

definition update_Counteren_CY  :: " Counteren \<Rightarrow>(1)Word.word \<Rightarrow> Counteren "  where 
     " update_Counteren_CY v x = (
   (v (|
     Counteren_Counteren_chunk_0 :=
       ((update_subrange_vec_dec(Counteren_Counteren_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Counteren " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val legalize_mcounteren : Counteren -> mword ty32 -> Counteren\<close>\<close>

definition legalize_mcounteren  :: " Counteren \<Rightarrow>(32)Word.word \<Rightarrow> Counteren "  where 
     " legalize_mcounteren (c :: Counteren) (v :: xlenbits) = (
   (let c = (update_Counteren_IR c ((cast_unit_vec0 ((access_vec_dec v (( 2 :: int)::ii)))  ::  1 Word.word))) in
   (let c = (update_Counteren_TM c ((cast_unit_vec0 ((access_vec_dec v (( 1 :: int)::ii)))  ::  1 Word.word))) in
   update_Counteren_CY c ((cast_unit_vec0 ((access_vec_dec v (( 0 :: int)::ii)))  ::  1 Word.word)))))" 
  for  c  :: " Counteren " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val legalize_scounteren : Counteren -> mword ty32 -> Counteren\<close>\<close>

definition legalize_scounteren  :: " Counteren \<Rightarrow>(32)Word.word \<Rightarrow> Counteren "  where 
     " legalize_scounteren (c :: Counteren) (v :: xlenbits) = (
   (let c = (update_Counteren_IR c ((cast_unit_vec0 ((access_vec_dec v (( 2 :: int)::ii)))  ::  1 Word.word))) in
   (let c = (update_Counteren_TM c ((cast_unit_vec0 ((access_vec_dec v (( 1 :: int)::ii)))  ::  1 Word.word))) in
   update_Counteren_CY c ((cast_unit_vec0 ((access_vec_dec v (( 0 :: int)::ii)))  ::  1 Word.word)))))" 
  for  c  :: " Counteren " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val retire_instruction : unit -> M unit\<close>\<close>

definition retire_instruction  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " retire_instruction _ = (
   read_reg minstret_written_ref \<bind> (\<lambda> (w__0 :: bool) . 
   if (((w__0 = True))) then write_reg minstret_written_ref False
   else
     (read_reg minstret_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     write_reg minstret_ref ((add_vec_int w__1 (( 1 :: int)::ii)  ::  64 Word.word)))))"


\<comment> \<open>\<open>val Mk_Sstatus : mword ty32 -> Sstatus\<close>\<close>

definition Mk_Sstatus  :: "(32)Word.word \<Rightarrow> Sstatus "  where 
     " Mk_Sstatus v = (
   (| Sstatus_Sstatus_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Sstatus_bits : Sstatus -> mword ty32\<close>\<close>

definition get_Sstatus_bits  :: " Sstatus \<Rightarrow>(32)Word.word "  where 
     " get_Sstatus_bits v = ( (subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Sstatus "


\<comment> \<open>\<open>val _set_Sstatus_bits : register_ref regstate register_value Sstatus -> mword ty32 -> M unit\<close>\<close>

definition set_Sstatus_bits  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sstatus_Sstatus_chunk_0 :=
         ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_bits : Sstatus -> mword ty32 -> Sstatus\<close>\<close>

definition update_Sstatus_bits  :: " Sstatus \<Rightarrow>(32)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_bits v x = (
   (v (|
     Sstatus_Sstatus_chunk_0 :=
       ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sstatus " 
  and  x  :: "(32)Word.word "


definition get_Sstatus_SD  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_SD v = ( (subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sstatus "


definition set_Sstatus_SD  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_SD r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sstatus_Sstatus_chunk_0 :=
         ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   r) (( 31 :: int)::ii) (( 31 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_SD  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_SD v x = (
   (v (|
     Sstatus_Sstatus_chunk_0 :=
       ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_MXR  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_MXR v = ( (subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 19 :: int)::ii) (( 19 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sstatus "


definition set_Sstatus_MXR  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_MXR r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sstatus_Sstatus_chunk_0 :=
         ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   r) (( 19 :: int)::ii) (( 19 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_MXR  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_MXR v x = (
   (v (|
     Sstatus_Sstatus_chunk_0 :=
       ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 19 :: int)::ii) (( 19 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_SUM  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_SUM v = ( (subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 18 :: int)::ii) (( 18 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sstatus "


definition set_Sstatus_SUM  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_SUM r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sstatus_Sstatus_chunk_0 :=
         ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   r) (( 18 :: int)::ii) (( 18 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_SUM  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_SUM v x = (
   (v (|
     Sstatus_Sstatus_chunk_0 :=
       ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 18 :: int)::ii) (( 18 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_XS  :: " Sstatus \<Rightarrow>(2)Word.word "  where 
     " get_Sstatus_XS v = ( (subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 16 :: int)::ii) (( 15 :: int)::ii)  ::  2 Word.word))" 
  for  v  :: " Sstatus "


definition set_Sstatus_XS  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_XS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sstatus_Sstatus_chunk_0 :=
         ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   r) (( 16 :: int)::ii) (( 15 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(2)Word.word "


definition update_Sstatus_XS  :: " Sstatus \<Rightarrow>(2)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_XS v x = (
   (v (|
     Sstatus_Sstatus_chunk_0 :=
       ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 16 :: int)::ii) (( 15 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sstatus " 
  and  x  :: "(2)Word.word "


definition get_Sstatus_FS  :: " Sstatus \<Rightarrow>(2)Word.word "  where 
     " get_Sstatus_FS v = ( (subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word))" 
  for  v  :: " Sstatus "


definition set_Sstatus_FS  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_FS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sstatus_Sstatus_chunk_0 :=
         ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   r) (( 14 :: int)::ii) (( 13 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(2)Word.word "


definition update_Sstatus_FS  :: " Sstatus \<Rightarrow>(2)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_FS v x = (
   (v (|
     Sstatus_Sstatus_chunk_0 :=
       ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 14 :: int)::ii) (( 13 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sstatus " 
  and  x  :: "(2)Word.word "


definition get_Sstatus_SPP  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_SPP v = ( (subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sstatus "


definition set_Sstatus_SPP  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_SPP r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sstatus_Sstatus_chunk_0 :=
         ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   r) (( 8 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_SPP  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_SPP v x = (
   (v (|
     Sstatus_Sstatus_chunk_0 :=
       ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_SPIE  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_SPIE v = ( (subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sstatus "


definition set_Sstatus_SPIE  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_SPIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sstatus_Sstatus_chunk_0 :=
         ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   r) (( 5 :: int)::ii) (( 5 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_SPIE  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_SPIE v x = (
   (v (|
     Sstatus_Sstatus_chunk_0 :=
       ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Sstatus_UPIE : Sstatus -> mword ty1\<close>\<close>

definition get_Sstatus_UPIE  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_UPIE v = ( (subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sstatus "


\<comment> \<open>\<open>val _set_Sstatus_UPIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Sstatus_UPIE  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_UPIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sstatus_Sstatus_chunk_0 :=
         ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   r) (( 4 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_UPIE : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

definition update_Sstatus_UPIE  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_UPIE v x = (
   (v (|
     Sstatus_Sstatus_chunk_0 :=
       ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


definition get_Sstatus_SIE  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_SIE v = ( (subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sstatus "


definition set_Sstatus_SIE  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_SIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sstatus_Sstatus_chunk_0 :=
         ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sstatus_SIE  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_SIE v x = (
   (v (|
     Sstatus_Sstatus_chunk_0 :=
       ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Sstatus_UIE : Sstatus -> mword ty1\<close>\<close>

definition get_Sstatus_UIE  :: " Sstatus \<Rightarrow>(1)Word.word "  where 
     " get_Sstatus_UIE v = ( (subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sstatus "


\<comment> \<open>\<open>val _set_Sstatus_UIE : register_ref regstate register_value Sstatus -> mword ty1 -> M unit\<close>\<close>

definition set_Sstatus_UIE  :: "((regstate),(register_value),(Sstatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sstatus_UIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sstatus_Sstatus_chunk_0 :=
         ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sstatus))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sstatus_UIE : Sstatus -> mword ty1 -> Sstatus\<close>\<close>

definition update_Sstatus_UIE  :: " Sstatus \<Rightarrow>(1)Word.word \<Rightarrow> Sstatus "  where 
     " update_Sstatus_UIE v x = (
   (v (|
     Sstatus_Sstatus_chunk_0 :=
       ((update_subrange_vec_dec(Sstatus_Sstatus_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sstatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val get_sstatus_UXL : Sstatus -> mword ty2\<close>\<close>

definition get_sstatus_UXL  :: " Sstatus \<Rightarrow>(2)Word.word "  where 
     " get_sstatus_UXL s = (
   (let m = (Mk_Mstatus ((get_Sstatus_bits s  ::  32 Word.word))) in
   (get_mstatus_UXL m  ::  2 Word.word)))" 
  for  s  :: " Sstatus "


\<comment> \<open>\<open>val set_sstatus_UXL : Sstatus -> mword ty2 -> Sstatus\<close>\<close>

definition set_sstatus_UXL  :: " Sstatus \<Rightarrow>(2)Word.word \<Rightarrow> Sstatus "  where 
     " set_sstatus_UXL (s :: Sstatus) (a :: arch_xlen) = (
   (let m = (Mk_Mstatus ((get_Sstatus_bits s  ::  32 Word.word))) in
   (let m = (set_mstatus_UXL m a) in
   Mk_Sstatus ((get_Mstatus_bits m  ::  32 Word.word)))))" 
  for  s  :: " Sstatus " 
  and  a  :: "(2)Word.word "


\<comment> \<open>\<open>val lower_mstatus : Mstatus -> Sstatus\<close>\<close>

definition lower_mstatus  :: " Mstatus \<Rightarrow> Sstatus "  where 
     " lower_mstatus m = (
   (let s = (Mk_Sstatus ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) in
   (let s = (update_Sstatus_SD s ((get_Mstatus_SD m  ::  1 Word.word))) in
   (let s = (set_sstatus_UXL s ((get_mstatus_UXL m  ::  2 Word.word))) in
   (let s = (update_Sstatus_MXR s ((get_Mstatus_MXR m  ::  1 Word.word))) in
   (let s = (update_Sstatus_SUM s ((get_Mstatus_SUM m  ::  1 Word.word))) in
   (let s = (update_Sstatus_XS s ((get_Mstatus_XS m  ::  2 Word.word))) in
   (let s = (update_Sstatus_FS s ((get_Mstatus_FS m  ::  2 Word.word))) in
   (let s = (update_Sstatus_SPP s ((get_Mstatus_SPP m  ::  1 Word.word))) in
   (let s = (update_Sstatus_SPIE s ((get_Mstatus_SPIE m  ::  1 Word.word))) in
   (let s = (update_Sstatus_UPIE s ((get_Mstatus_UPIE m  ::  1 Word.word))) in
   (let s = (update_Sstatus_SIE s ((get_Mstatus_SIE m  ::  1 Word.word))) in
   update_Sstatus_UIE s ((get_Mstatus_UIE m  ::  1 Word.word))))))))))))))" 
  for  m  :: " Mstatus "


\<comment> \<open>\<open>val lift_sstatus : Mstatus -> Sstatus -> M Mstatus\<close>\<close>

definition lift_sstatus  :: " Mstatus \<Rightarrow> Sstatus \<Rightarrow>((register_value),(Mstatus),(exception))monad "  where 
     " lift_sstatus (m :: Mstatus) (s :: Sstatus) = (
   (let m = (update_Mstatus_MXR m ((get_Sstatus_MXR s  ::  1 Word.word))) in
   (let m = (update_Mstatus_SUM m ((get_Sstatus_SUM s  ::  1 Word.word))) in
   (let m = (update_Mstatus_XS m ((get_Sstatus_XS s  ::  2 Word.word))) in
   (let m = (update_Mstatus_FS m ((get_Sstatus_FS s  ::  2 Word.word))) in
   or_boolM
     (extStatus_of_bits ((get_Mstatus_FS m  ::  2 Word.word)) \<bind> (\<lambda> (w__0 :: ExtStatus) . 
      return (((((extStatus_to_bits w__0  ::  2 Word.word)) = ((extStatus_to_bits Dirty  ::  2 Word.word)))))))
     (extStatus_of_bits ((get_Mstatus_XS m  ::  2 Word.word)) \<bind> (\<lambda> (w__1 :: ExtStatus) . 
      return (((((extStatus_to_bits w__1  ::  2 Word.word)) = ((extStatus_to_bits Dirty  ::  2 Word.word))))))) \<bind> (\<lambda> (w__2 :: bool) . 
   (let m = (update_Mstatus_SD m ((bool_to_bits w__2  ::  1 Word.word))) in
   (let m = (update_Mstatus_SPP m ((get_Sstatus_SPP s  ::  1 Word.word))) in
   (let m = (update_Mstatus_SPIE m ((get_Sstatus_SPIE s  ::  1 Word.word))) in
   (let m = (update_Mstatus_UPIE m ((get_Sstatus_UPIE s  ::  1 Word.word))) in
   (let m = (update_Mstatus_SIE m ((get_Sstatus_SIE s  ::  1 Word.word))) in
   (let m = (update_Mstatus_UIE m ((get_Sstatus_UIE s  ::  1 Word.word))) in
   return m))))))))))))" 
  for  m  :: " Mstatus " 
  and  s  :: " Sstatus "


\<comment> \<open>\<open>val legalize_sstatus : Mstatus -> mword ty32 -> M Mstatus\<close>\<close>

definition legalize_sstatus  :: " Mstatus \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(Mstatus),(exception))monad "  where 
     " legalize_sstatus (m :: Mstatus) (v :: xlenbits) = ( lift_sstatus m ((Mk_Sstatus v)))" 
  for  m  :: " Mstatus " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val Mk_Sedeleg : mword ty32 -> Sedeleg\<close>\<close>

definition Mk_Sedeleg  :: "(32)Word.word \<Rightarrow> Sedeleg "  where 
     " Mk_Sedeleg v = (
   (| Sedeleg_Sedeleg_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Sedeleg_bits : Sedeleg -> mword ty32\<close>\<close>

definition get_Sedeleg_bits  :: " Sedeleg \<Rightarrow>(32)Word.word "  where 
     " get_Sedeleg_bits v = ( (subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Sedeleg "


\<comment> \<open>\<open>val _set_Sedeleg_bits : register_ref regstate register_value Sedeleg -> mword ty32 -> M unit\<close>\<close>

definition set_Sedeleg_bits  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sedeleg_Sedeleg_chunk_0 :=
         ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Sedeleg_bits : Sedeleg -> mword ty32 -> Sedeleg\<close>\<close>

definition update_Sedeleg_bits  :: " Sedeleg \<Rightarrow>(32)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_bits v x = (
   (v (|
     Sedeleg_Sedeleg_chunk_0 :=
       ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sedeleg " 
  and  x  :: "(32)Word.word "


definition get_Sedeleg_UEnvCall  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_UEnvCall v = (
   (subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sedeleg "


definition set_Sedeleg_UEnvCall  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_UEnvCall r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sedeleg_Sedeleg_chunk_0 :=
         ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   r) (( 8 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_UEnvCall  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_UEnvCall v x = (
   (v (|
     Sedeleg_Sedeleg_chunk_0 :=
       ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_SAMO_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_SAMO_Access_Fault v = (
   (subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sedeleg "


definition set_Sedeleg_SAMO_Access_Fault  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_SAMO_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sedeleg_Sedeleg_chunk_0 :=
         ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   r) (( 7 :: int)::ii) (( 7 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_SAMO_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_SAMO_Access_Fault v x = (
   (v (|
     Sedeleg_Sedeleg_chunk_0 :=
       ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_SAMO_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_SAMO_Addr_Align v = (
   (subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sedeleg "


definition set_Sedeleg_SAMO_Addr_Align  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_SAMO_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sedeleg_Sedeleg_chunk_0 :=
         ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   r) (( 6 :: int)::ii) (( 6 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_SAMO_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_SAMO_Addr_Align v x = (
   (v (|
     Sedeleg_Sedeleg_chunk_0 :=
       ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 6 :: int)::ii) (( 6 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_Load_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Load_Access_Fault v = (
   (subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Load_Access_Fault  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Load_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sedeleg_Sedeleg_chunk_0 :=
         ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   r) (( 5 :: int)::ii) (( 5 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Load_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Load_Access_Fault v x = (
   (v (|
     Sedeleg_Sedeleg_chunk_0 :=
       ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_Load_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Load_Addr_Align v = (
   (subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Load_Addr_Align  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Load_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sedeleg_Sedeleg_chunk_0 :=
         ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   r) (( 4 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Load_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Load_Addr_Align v x = (
   (v (|
     Sedeleg_Sedeleg_chunk_0 :=
       ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_Breakpoint  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Breakpoint v = (
   (subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Breakpoint  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Breakpoint r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sedeleg_Sedeleg_chunk_0 :=
         ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   r) (( 3 :: int)::ii) (( 3 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Breakpoint  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Breakpoint v x = (
   (v (|
     Sedeleg_Sedeleg_chunk_0 :=
       ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_Illegal_Instr  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Illegal_Instr v = (
   (subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Illegal_Instr  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Illegal_Instr r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sedeleg_Sedeleg_chunk_0 :=
         ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   r) (( 2 :: int)::ii) (( 2 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Illegal_Instr  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Illegal_Instr v x = (
   (v (|
     Sedeleg_Sedeleg_chunk_0 :=
       ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_Fetch_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Fetch_Access_Fault v = (
   (subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Fetch_Access_Fault  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Fetch_Access_Fault r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sedeleg_Sedeleg_chunk_0 :=
         ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Fetch_Access_Fault  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Fetch_Access_Fault v x = (
   (v (|
     Sedeleg_Sedeleg_chunk_0 :=
       ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


definition get_Sedeleg_Fetch_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word "  where 
     " get_Sedeleg_Fetch_Addr_Align v = (
   (subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sedeleg "


definition set_Sedeleg_Fetch_Addr_Align  :: "((regstate),(register_value),(Sedeleg))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sedeleg_Fetch_Addr_Align r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sedeleg_Sedeleg_chunk_0 :=
         ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sedeleg))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sedeleg_Fetch_Addr_Align  :: " Sedeleg \<Rightarrow>(1)Word.word \<Rightarrow> Sedeleg "  where 
     " update_Sedeleg_Fetch_Addr_Align v x = (
   (v (|
     Sedeleg_Sedeleg_chunk_0 :=
       ((update_subrange_vec_dec(Sedeleg_Sedeleg_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sedeleg " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val legalize_sedeleg : Sedeleg -> mword ty32 -> Sedeleg\<close>\<close>

definition legalize_sedeleg  :: " Sedeleg \<Rightarrow>(32)Word.word \<Rightarrow> Sedeleg "  where 
     " legalize_sedeleg (s :: Sedeleg) (v :: xlenbits) = (
   Mk_Sedeleg ((EXTZ (( 32 :: int)::ii) ((subrange_vec_dec v (( 8 :: int)::ii) (( 0 :: int)::ii)  ::  9 Word.word))  ::  32 Word.word)))" 
  for  s  :: " Sedeleg " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val Mk_Sinterrupts : mword ty32 -> Sinterrupts\<close>\<close>

definition Mk_Sinterrupts  :: "(32)Word.word \<Rightarrow> Sinterrupts "  where 
     " Mk_Sinterrupts v = (
   (| Sinterrupts_Sinterrupts_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Sinterrupts_bits : Sinterrupts -> mword ty32\<close>\<close>

definition get_Sinterrupts_bits  :: " Sinterrupts \<Rightarrow>(32)Word.word "  where 
     " get_Sinterrupts_bits v = (
   (subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Sinterrupts "


\<comment> \<open>\<open>val _set_Sinterrupts_bits : register_ref regstate register_value Sinterrupts -> mword ty32 -> M unit\<close>\<close>

definition set_Sinterrupts_bits  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sinterrupts_Sinterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_bits : Sinterrupts -> mword ty32 -> Sinterrupts\<close>\<close>

definition update_Sinterrupts_bits  :: " Sinterrupts \<Rightarrow>(32)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_bits v x = (
   (v (|
     Sinterrupts_Sinterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sinterrupts " 
  and  x  :: "(32)Word.word "


definition get_Sinterrupts_SEI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_SEI v = (
   (subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sinterrupts "


definition set_Sinterrupts_SEI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_SEI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sinterrupts_Sinterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   r) (( 9 :: int)::ii) (( 9 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sinterrupts_SEI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_SEI v x = (
   (v (|
     Sinterrupts_Sinterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 9 :: int)::ii) (( 9 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Sinterrupts_UEI : Sinterrupts -> mword ty1\<close>\<close>

definition get_Sinterrupts_UEI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_UEI v = (
   (subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sinterrupts "


\<comment> \<open>\<open>val _set_Sinterrupts_UEI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Sinterrupts_UEI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_UEI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sinterrupts_Sinterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   r) (( 8 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_UEI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

definition update_Sinterrupts_UEI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_UEI v x = (
   (v (|
     Sinterrupts_Sinterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


definition get_Sinterrupts_STI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_STI v = (
   (subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sinterrupts "


definition set_Sinterrupts_STI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_STI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sinterrupts_Sinterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   r) (( 5 :: int)::ii) (( 5 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sinterrupts_STI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_STI v x = (
   (v (|
     Sinterrupts_Sinterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Sinterrupts_UTI : Sinterrupts -> mword ty1\<close>\<close>

definition get_Sinterrupts_UTI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_UTI v = (
   (subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sinterrupts "


\<comment> \<open>\<open>val _set_Sinterrupts_UTI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Sinterrupts_UTI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_UTI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sinterrupts_Sinterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   r) (( 4 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_UTI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

definition update_Sinterrupts_UTI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_UTI v x = (
   (v (|
     Sinterrupts_Sinterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


definition get_Sinterrupts_SSI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_SSI v = (
   (subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sinterrupts "


definition set_Sinterrupts_SSI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_SSI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sinterrupts_Sinterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Sinterrupts_SSI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_SSI v x = (
   (v (|
     Sinterrupts_Sinterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Sinterrupts_USI : Sinterrupts -> mword ty1\<close>\<close>

definition get_Sinterrupts_USI  :: " Sinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Sinterrupts_USI v = (
   (subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Sinterrupts "


\<comment> \<open>\<open>val _set_Sinterrupts_USI : register_ref regstate register_value Sinterrupts -> mword ty1 -> M unit\<close>\<close>

definition set_Sinterrupts_USI  :: "((regstate),(register_value),(Sinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Sinterrupts_USI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Sinterrupts_Sinterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Sinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Sinterrupts_USI : Sinterrupts -> mword ty1 -> Sinterrupts\<close>\<close>

definition update_Sinterrupts_USI  :: " Sinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Sinterrupts "  where 
     " update_Sinterrupts_USI v x = (
   (v (|
     Sinterrupts_Sinterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Sinterrupts_Sinterrupts_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Sinterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val lower_mip : Minterrupts -> Minterrupts -> Sinterrupts\<close>\<close>

definition lower_mip  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts "  where 
     " lower_mip (m :: Minterrupts) (d :: Minterrupts) = (
   (let (s :: Sinterrupts) =
     (Mk_Sinterrupts ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) in
   (let s =
     (update_Sinterrupts_SEI s
       ((and_vec ((get_Minterrupts_SEI m  ::  1 Word.word)) ((get_Minterrupts_SEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_STI s
       ((and_vec ((get_Minterrupts_STI m  ::  1 Word.word)) ((get_Minterrupts_STI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_SSI s
       ((and_vec ((get_Minterrupts_SSI m  ::  1 Word.word)) ((get_Minterrupts_SSI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UEI s
       ((and_vec ((get_Minterrupts_UEI m  ::  1 Word.word)) ((get_Minterrupts_UEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UTI s
       ((and_vec ((get_Minterrupts_UTI m  ::  1 Word.word)) ((get_Minterrupts_UTI d  ::  1 Word.word))
          ::  1 Word.word))) in
   update_Sinterrupts_USI s
     ((and_vec ((get_Minterrupts_USI m  ::  1 Word.word)) ((get_Minterrupts_USI d  ::  1 Word.word))
        ::  1 Word.word)))))))))" 
  for  m  :: " Minterrupts " 
  and  d  :: " Minterrupts "


\<comment> \<open>\<open>val lower_mie : Minterrupts -> Minterrupts -> Sinterrupts\<close>\<close>

definition lower_mie  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts "  where 
     " lower_mie (m :: Minterrupts) (d :: Minterrupts) = (
   (let (s :: Sinterrupts) =
     (Mk_Sinterrupts ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) in
   (let s =
     (update_Sinterrupts_SEI s
       ((and_vec ((get_Minterrupts_SEI m  ::  1 Word.word)) ((get_Minterrupts_SEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_STI s
       ((and_vec ((get_Minterrupts_STI m  ::  1 Word.word)) ((get_Minterrupts_STI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_SSI s
       ((and_vec ((get_Minterrupts_SSI m  ::  1 Word.word)) ((get_Minterrupts_SSI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UEI s
       ((and_vec ((get_Minterrupts_UEI m  ::  1 Word.word)) ((get_Minterrupts_UEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let s =
     (update_Sinterrupts_UTI s
       ((and_vec ((get_Minterrupts_UTI m  ::  1 Word.word)) ((get_Minterrupts_UTI d  ::  1 Word.word))
          ::  1 Word.word))) in
   update_Sinterrupts_USI s
     ((and_vec ((get_Minterrupts_USI m  ::  1 Word.word)) ((get_Minterrupts_USI d  ::  1 Word.word))
        ::  1 Word.word)))))))))" 
  for  m  :: " Minterrupts " 
  and  d  :: " Minterrupts "


\<comment> \<open>\<open>val lift_sip : Minterrupts -> Minterrupts -> Sinterrupts -> M Minterrupts\<close>\<close>

definition lift_sip  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts \<Rightarrow>((register_value),(Minterrupts),(exception))monad "  where 
     " lift_sip (o1 :: Minterrupts) (d :: Minterrupts) (s :: Sinterrupts) = (
   (let (m :: Minterrupts) = o1 in
   (let m =
     (update_Minterrupts_SSI m
       ((and_vec ((get_Sinterrupts_SSI s  ::  1 Word.word)) ((get_Minterrupts_SSI d  ::  1 Word.word))
          ::  1 Word.word))) in
   haveNExt ()  \<bind> (\<lambda> (w__0 :: bool) . 
   return (if w__0 then
             (let m =
               (if (((((get_Minterrupts_UEI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
                 update_Minterrupts_UEI m ((get_Sinterrupts_UEI s  ::  1 Word.word))
               else m) in
             if (((((get_Minterrupts_USI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
             then
               update_Minterrupts_USI m ((get_Sinterrupts_USI s  ::  1 Word.word))
             else m)
           else m)))))" 
  for  o1  :: " Minterrupts " 
  and  d  :: " Minterrupts " 
  and  s  :: " Sinterrupts "


\<comment> \<open>\<open>val legalize_sip : Minterrupts -> Minterrupts -> mword ty32 -> M Minterrupts\<close>\<close>

definition legalize_sip  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(Minterrupts),(exception))monad "  where 
     " legalize_sip (m :: Minterrupts) (d :: Minterrupts) (v :: xlenbits) = (
   lift_sip m d ((Mk_Sinterrupts v)))" 
  for  m  :: " Minterrupts " 
  and  d  :: " Minterrupts " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val lift_sie : Minterrupts -> Minterrupts -> Sinterrupts -> M Minterrupts\<close>\<close>

definition lift_sie  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow> Sinterrupts \<Rightarrow>((register_value),(Minterrupts),(exception))monad "  where 
     " lift_sie (o1 :: Minterrupts) (d :: Minterrupts) (s :: Sinterrupts) = (
   (let (m :: Minterrupts) = o1 in
   (let m =
     (if (((((get_Minterrupts_SEI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
       update_Minterrupts_SEI m ((get_Sinterrupts_SEI s  ::  1 Word.word))
     else m) in
   (let m =
     (if (((((get_Minterrupts_STI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
       update_Minterrupts_STI m ((get_Sinterrupts_STI s  ::  1 Word.word))
     else m) in
   (let m =
     (if (((((get_Minterrupts_SSI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
       update_Minterrupts_SSI m ((get_Sinterrupts_SSI s  ::  1 Word.word))
     else m) in
   haveNExt ()  \<bind> (\<lambda> (w__0 :: bool) . 
   return (if w__0 then
             (let m =
               (if (((((get_Minterrupts_UEI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
                 update_Minterrupts_UEI m ((get_Sinterrupts_UEI s  ::  1 Word.word))
               else m) in
             (let m =
               (if (((((get_Minterrupts_UTI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
                 update_Minterrupts_UTI m ((get_Sinterrupts_UTI s  ::  1 Word.word))
               else m) in
             if (((((get_Minterrupts_USI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
             then
               update_Minterrupts_USI m ((get_Sinterrupts_USI s  ::  1 Word.word))
             else m))
           else m)))))))" 
  for  o1  :: " Minterrupts " 
  and  d  :: " Minterrupts " 
  and  s  :: " Sinterrupts "


\<comment> \<open>\<open>val legalize_sie : Minterrupts -> Minterrupts -> mword ty32 -> M Minterrupts\<close>\<close>

definition legalize_sie  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(Minterrupts),(exception))monad "  where 
     " legalize_sie (m :: Minterrupts) (d :: Minterrupts) (v :: xlenbits) = (
   lift_sie m d ((Mk_Sinterrupts v)))" 
  for  m  :: " Minterrupts " 
  and  d  :: " Minterrupts " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val Mk_Satp64 : mword ty64 -> Satp64\<close>\<close>

definition Mk_Satp64  :: "(64)Word.word \<Rightarrow> Satp64 "  where 
     " Mk_Satp64 v = ( (| Satp64_Satp64_chunk_0 = ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) |) )" 
  for  v  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_Satp64_bits : Satp64 -> mword ty64\<close>\<close>

definition get_Satp64_bits  :: " Satp64 \<Rightarrow>(64)Word.word "  where 
     " get_Satp64_bits v = ( (subrange_vec_dec(Satp64_Satp64_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))" 
  for  v  :: " Satp64 "


\<comment> \<open>\<open>val _set_Satp64_bits : register_ref regstate register_value Satp64 -> mword ty64 -> M unit\<close>\<close>

definition set_Satp64_bits  :: "((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp64_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Satp64_Satp64_chunk_0 :=
         ((update_subrange_vec_dec(Satp64_Satp64_chunk_0   r) (( 63 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Satp64))register_ref " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val _update_Satp64_bits : Satp64 -> mword ty64 -> Satp64\<close>\<close>

definition update_Satp64_bits  :: " Satp64 \<Rightarrow>(64)Word.word \<Rightarrow> Satp64 "  where 
     " update_Satp64_bits v x = (
   (v (|
     Satp64_Satp64_chunk_0 :=
       ((update_subrange_vec_dec(Satp64_Satp64_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " Satp64 " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_Satp64_Mode : Satp64 -> mword ty4\<close>\<close>

definition get_Satp64_Mode  :: " Satp64 \<Rightarrow>(4)Word.word "  where 
     " get_Satp64_Mode v = ( (subrange_vec_dec(Satp64_Satp64_chunk_0   v) (( 63 :: int)::ii) (( 60 :: int)::ii)  ::  4 Word.word))" 
  for  v  :: " Satp64 "


\<comment> \<open>\<open>val _set_Satp64_Mode : register_ref regstate register_value Satp64 -> mword ty4 -> M unit\<close>\<close>

definition set_Satp64_Mode  :: "((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp64_Mode r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Satp64_Satp64_chunk_0 :=
         ((update_subrange_vec_dec(Satp64_Satp64_chunk_0   r) (( 63 :: int)::ii) (( 60 :: int)::ii)
             ((subrange_vec_dec v (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Satp64))register_ref " 
  and  v  :: "(4)Word.word "


\<comment> \<open>\<open>val _update_Satp64_Mode : Satp64 -> mword ty4 -> Satp64\<close>\<close>

definition update_Satp64_Mode  :: " Satp64 \<Rightarrow>(4)Word.word \<Rightarrow> Satp64 "  where 
     " update_Satp64_Mode v x = (
   (v (|
     Satp64_Satp64_chunk_0 :=
       ((update_subrange_vec_dec(Satp64_Satp64_chunk_0   v) (( 63 :: int)::ii) (( 60 :: int)::ii)
           ((subrange_vec_dec x (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " Satp64 " 
  and  x  :: "(4)Word.word "


\<comment> \<open>\<open>val _get_Satp64_Asid : Satp64 -> mword ty16\<close>\<close>

definition get_Satp64_Asid  :: " Satp64 \<Rightarrow>(16)Word.word "  where 
     " get_Satp64_Asid v = ( (subrange_vec_dec(Satp64_Satp64_chunk_0   v) (( 59 :: int)::ii) (( 44 :: int)::ii)  ::  16 Word.word))" 
  for  v  :: " Satp64 "


\<comment> \<open>\<open>val _set_Satp64_Asid : register_ref regstate register_value Satp64 -> mword ty16 -> M unit\<close>\<close>

definition set_Satp64_Asid  :: "((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(16)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp64_Asid r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Satp64_Satp64_chunk_0 :=
         ((update_subrange_vec_dec(Satp64_Satp64_chunk_0   r) (( 59 :: int)::ii) (( 44 :: int)::ii)
             ((subrange_vec_dec v (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Satp64))register_ref " 
  and  v  :: "(16)Word.word "


\<comment> \<open>\<open>val _update_Satp64_Asid : Satp64 -> mword ty16 -> Satp64\<close>\<close>

definition update_Satp64_Asid  :: " Satp64 \<Rightarrow>(16)Word.word \<Rightarrow> Satp64 "  where 
     " update_Satp64_Asid v x = (
   (v (|
     Satp64_Satp64_chunk_0 :=
       ((update_subrange_vec_dec(Satp64_Satp64_chunk_0   v) (( 59 :: int)::ii) (( 44 :: int)::ii)
           ((subrange_vec_dec x (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " Satp64 " 
  and  x  :: "(16)Word.word "


\<comment> \<open>\<open>val _update_Satp32_Asid : Satp32 -> mword ty9 -> Satp32\<close>\<close>

\<comment> \<open>\<open>val _get_Satp32_Asid : Satp32 -> mword ty9\<close>\<close>

\<comment> \<open>\<open>val _set_Satp32_Asid : register_ref regstate register_value Satp32 -> mword ty9 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_Satp64_PPN : Satp64 -> mword ty44\<close>\<close>

definition get_Satp64_PPN  :: " Satp64 \<Rightarrow>(44)Word.word "  where 
     " get_Satp64_PPN v = ( (subrange_vec_dec(Satp64_Satp64_chunk_0   v) (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))" 
  for  v  :: " Satp64 "


\<comment> \<open>\<open>val _set_Satp64_PPN : register_ref regstate register_value Satp64 -> mword ty44 -> M unit\<close>\<close>

definition set_Satp64_PPN  :: "((regstate),(register_value),(Satp64))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp64_PPN r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Satp64_Satp64_chunk_0 :=
         ((update_subrange_vec_dec(Satp64_Satp64_chunk_0   r) (( 43 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Satp64))register_ref " 
  and  v  :: "(44)Word.word "


\<comment> \<open>\<open>val _update_Satp64_PPN : Satp64 -> mword ty44 -> Satp64\<close>\<close>

definition update_Satp64_PPN  :: " Satp64 \<Rightarrow>(44)Word.word \<Rightarrow> Satp64 "  where 
     " update_Satp64_PPN v x = (
   (v (|
     Satp64_Satp64_chunk_0 :=
       ((update_subrange_vec_dec(Satp64_Satp64_chunk_0   v) (( 43 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " Satp64 " 
  and  x  :: "(44)Word.word "


\<comment> \<open>\<open>val _update_Satp32_PPN : Satp32 -> mword ty22 -> Satp32\<close>\<close>

\<comment> \<open>\<open>val _get_Satp32_PPN : Satp32 -> mword ty22\<close>\<close>

\<comment> \<open>\<open>val _set_Satp32_PPN : register_ref regstate register_value Satp32 -> mword ty22 -> M unit\<close>\<close>

\<comment> \<open>\<open>val legalize_satp64 : Architecture -> mword ty64 -> mword ty64 -> mword ty64\<close>\<close>

definition legalize_satp64  :: " Architecture \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word \<Rightarrow>(64)Word.word "  where 
     " legalize_satp64 (a :: Architecture) (o1 :: 64 bits) (v :: 64 bits) = (
   (let s = (Mk_Satp64 v) in
   (case  ((satp64Mode_of_bits a ((get_Satp64_Mode s  ::  4 Word.word)))) of
     None => o1
   | Some (Sv32) => o1
   | Some (_) => (get_Satp64_bits s  ::  64 Word.word)
   )))" 
  for  a  :: " Architecture " 
  and  o1  :: "(64)Word.word " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val Mk_Satp32 : mword ty32 -> Satp32\<close>\<close>

definition Mk_Satp32  :: "(32)Word.word \<Rightarrow> Satp32 "  where 
     " Mk_Satp32 v = ( (| Satp32_Satp32_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Satp32_bits : Satp32 -> mword ty32\<close>\<close>

definition get_Satp32_bits  :: " Satp32 \<Rightarrow>(32)Word.word "  where 
     " get_Satp32_bits v = ( (subrange_vec_dec(Satp32_Satp32_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Satp32 "


\<comment> \<open>\<open>val _set_Satp32_bits : register_ref regstate register_value Satp32 -> mword ty32 -> M unit\<close>\<close>

definition set_Satp32_bits  :: "((regstate),(register_value),(Satp32))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp32_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Satp32_Satp32_chunk_0 :=
         ((update_subrange_vec_dec(Satp32_Satp32_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Satp32))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Satp32_bits : Satp32 -> mword ty32 -> Satp32\<close>\<close>

definition update_Satp32_bits  :: " Satp32 \<Rightarrow>(32)Word.word \<Rightarrow> Satp32 "  where 
     " update_Satp32_bits v x = (
   (v (|
     Satp32_Satp32_chunk_0 :=
       ((update_subrange_vec_dec(Satp32_Satp32_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Satp32 " 
  and  x  :: "(32)Word.word "


definition get_Satp32_Mode  :: " Satp32 \<Rightarrow>(1)Word.word "  where 
     " get_Satp32_Mode v = ( (subrange_vec_dec(Satp32_Satp32_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Satp32 "


definition set_Satp32_Mode  :: "((regstate),(register_value),(Satp32))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp32_Mode r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Satp32_Satp32_chunk_0 :=
         ((update_subrange_vec_dec(Satp32_Satp32_chunk_0   r) (( 31 :: int)::ii) (( 31 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Satp32))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Satp32_Mode  :: " Satp32 \<Rightarrow>(1)Word.word \<Rightarrow> Satp32 "  where 
     " update_Satp32_Mode v x = (
   (v (|
     Satp32_Satp32_chunk_0 :=
       ((update_subrange_vec_dec(Satp32_Satp32_chunk_0   v) (( 31 :: int)::ii) (( 31 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Satp32 " 
  and  x  :: "(1)Word.word "


definition get_Satp32_Asid  :: " Satp32 \<Rightarrow>(9)Word.word "  where 
     " get_Satp32_Asid v = ( (subrange_vec_dec(Satp32_Satp32_chunk_0   v) (( 30 :: int)::ii) (( 22 :: int)::ii)  ::  9 Word.word))" 
  for  v  :: " Satp32 "


definition set_Satp32_Asid  :: "((regstate),(register_value),(Satp32))register_ref \<Rightarrow>(9)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp32_Asid r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Satp32_Satp32_chunk_0 :=
         ((update_subrange_vec_dec(Satp32_Satp32_chunk_0   r) (( 30 :: int)::ii) (( 22 :: int)::ii)
             ((subrange_vec_dec v (( 8 :: int)::ii) (( 0 :: int)::ii)  ::  9 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Satp32))register_ref " 
  and  v  :: "(9)Word.word "


definition update_Satp32_Asid  :: " Satp32 \<Rightarrow>(9)Word.word \<Rightarrow> Satp32 "  where 
     " update_Satp32_Asid v x = (
   (v (|
     Satp32_Satp32_chunk_0 :=
       ((update_subrange_vec_dec(Satp32_Satp32_chunk_0   v) (( 30 :: int)::ii) (( 22 :: int)::ii)
           ((subrange_vec_dec x (( 8 :: int)::ii) (( 0 :: int)::ii)  ::  9 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Satp32 " 
  and  x  :: "(9)Word.word "


definition get_Satp32_PPN  :: " Satp32 \<Rightarrow>(22)Word.word "  where 
     " get_Satp32_PPN v = ( (subrange_vec_dec(Satp32_Satp32_chunk_0   v) (( 21 :: int)::ii) (( 0 :: int)::ii)  ::  22 Word.word))" 
  for  v  :: " Satp32 "


definition set_Satp32_PPN  :: "((regstate),(register_value),(Satp32))register_ref \<Rightarrow>(22)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Satp32_PPN r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Satp32_Satp32_chunk_0 :=
         ((update_subrange_vec_dec(Satp32_Satp32_chunk_0   r) (( 21 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 21 :: int)::ii) (( 0 :: int)::ii)  ::  22 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Satp32))register_ref " 
  and  v  :: "(22)Word.word "


definition update_Satp32_PPN  :: " Satp32 \<Rightarrow>(22)Word.word \<Rightarrow> Satp32 "  where 
     " update_Satp32_PPN v x = (
   (v (|
     Satp32_Satp32_chunk_0 :=
       ((update_subrange_vec_dec(Satp32_Satp32_chunk_0   v) (( 21 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 21 :: int)::ii) (( 0 :: int)::ii)  ::  22 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Satp32 " 
  and  x  :: "(22)Word.word "


\<comment> \<open>\<open>val legalize_satp32 : Architecture -> mword ty32 -> mword ty32 -> mword ty32\<close>\<close>

definition legalize_satp32  :: " Architecture \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word "  where 
     " legalize_satp32 (a :: Architecture) (o1 :: 32 bits) (v :: 32 bits) = ( v )" 
  for  a  :: " Architecture " 
  and  o1  :: "(32)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val PmpAddrMatchType_of_num : integer -> PmpAddrMatchType\<close>\<close>

definition PmpAddrMatchType_of_num  :: " int \<Rightarrow> PmpAddrMatchType "  where 
     " PmpAddrMatchType_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then OFF
   else if (((p00 = (( 1 :: int)::ii)))) then TOR
   else if (((p00 = (( 2 :: int)::ii)))) then NA4
   else NAPOT))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_PmpAddrMatchType : PmpAddrMatchType -> integer\<close>\<close>

fun num_of_PmpAddrMatchType  :: " PmpAddrMatchType \<Rightarrow> int "  where 
     " num_of_PmpAddrMatchType OFF = ( (( 0 :: int)::ii))"
|" num_of_PmpAddrMatchType TOR = ( (( 1 :: int)::ii))"
|" num_of_PmpAddrMatchType NA4 = ( (( 2 :: int)::ii))"
|" num_of_PmpAddrMatchType NAPOT = ( (( 3 :: int)::ii))"


\<comment> \<open>\<open>val pmpAddrMatchType_of_bits : mword ty2 -> M PmpAddrMatchType\<close>\<close>

definition pmpAddrMatchType_of_bits  :: "(2)Word.word \<Rightarrow>((register_value),(PmpAddrMatchType),(exception))monad "  where 
     " pmpAddrMatchType_of_bits bs = (
   (let b__0 = bs in
   if (((b__0 = (vec_of_bits [B0,B0]  ::  2 Word.word)))) then return OFF
   else if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return TOR
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then return NA4
   else if (((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then return NAPOT
   else assert_exp False (''Pattern match failure at model/riscv_pmp_regs.sail 7:2 - 12:3'') \<then> exit0 () ))" 
  for  bs  :: "(2)Word.word "


\<comment> \<open>\<open>val pmpAddrMatchType_to_bits : PmpAddrMatchType -> mword ty2\<close>\<close>

fun pmpAddrMatchType_to_bits  :: " PmpAddrMatchType \<Rightarrow>(2)Word.word "  where 
     " pmpAddrMatchType_to_bits OFF = ( (vec_of_bits [B0,B0]  ::  2 Word.word))"
|" pmpAddrMatchType_to_bits TOR = ( (vec_of_bits [B0,B1]  ::  2 Word.word))"
|" pmpAddrMatchType_to_bits NA4 = ( (vec_of_bits [B1,B0]  ::  2 Word.word))"
|" pmpAddrMatchType_to_bits NAPOT = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


\<comment> \<open>\<open>val Mk_Pmpcfg_ent : mword ty8 -> Pmpcfg_ent\<close>\<close>

definition Mk_Pmpcfg_ent  :: "(8)Word.word \<Rightarrow> Pmpcfg_ent "  where 
     " Mk_Pmpcfg_ent v = (
   (| Pmpcfg_ent_Pmpcfg_ent_chunk_0 = ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) |) )" 
  for  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_Pmpcfg_ent_bits : Pmpcfg_ent -> mword ty8\<close>\<close>

definition get_Pmpcfg_ent_bits  :: " Pmpcfg_ent \<Rightarrow>(8)Word.word "  where 
     " get_Pmpcfg_ent_bits v = (
   (subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))" 
  for  v  :: " Pmpcfg_ent "


\<comment> \<open>\<open>val _set_Pmpcfg_ent_bits : register_ref regstate register_value Pmpcfg_ent -> mword ty8 -> M unit\<close>\<close>

definition set_Pmpcfg_ent_bits  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Pmpcfg_ent_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   r) (( 7 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_Pmpcfg_ent_bits : Pmpcfg_ent -> mword ty8 -> Pmpcfg_ent\<close>\<close>

definition update_Pmpcfg_ent_bits  :: " Pmpcfg_ent \<Rightarrow>(8)Word.word \<Rightarrow> Pmpcfg_ent "  where 
     " update_Pmpcfg_ent_bits v x = (
   (v (|
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(8)Word.word "


definition get_Pmpcfg_ent_L  :: " Pmpcfg_ent \<Rightarrow>(1)Word.word "  where 
     " get_Pmpcfg_ent_L v = (
   (subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Pmpcfg_ent "


definition set_Pmpcfg_ent_L  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Pmpcfg_ent_L r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   r) (( 7 :: int)::ii) (( 7 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Pmpcfg_ent_L  :: " Pmpcfg_ent \<Rightarrow>(1)Word.word \<Rightarrow> Pmpcfg_ent "  where 
     " update_Pmpcfg_ent_L v x = (
   (v (|
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Pmpcfg_ent_A : Pmpcfg_ent -> mword ty2\<close>\<close>

definition get_Pmpcfg_ent_A  :: " Pmpcfg_ent \<Rightarrow>(2)Word.word "  where 
     " get_Pmpcfg_ent_A v = (
   (subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word))" 
  for  v  :: " Pmpcfg_ent "


\<comment> \<open>\<open>val _set_Pmpcfg_ent_A : register_ref regstate register_value Pmpcfg_ent -> mword ty2 -> M unit\<close>\<close>

definition set_Pmpcfg_ent_A  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Pmpcfg_ent_A r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   r) (( 4 :: int)::ii) (( 3 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_Pmpcfg_ent_A : Pmpcfg_ent -> mword ty2 -> Pmpcfg_ent\<close>\<close>

definition update_Pmpcfg_ent_A  :: " Pmpcfg_ent \<Rightarrow>(2)Word.word \<Rightarrow> Pmpcfg_ent "  where 
     " update_Pmpcfg_ent_A v x = (
   (v (|
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 4 :: int)::ii) (( 3 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _get_Pmpcfg_ent_X : Pmpcfg_ent -> mword ty1\<close>\<close>

definition get_Pmpcfg_ent_X  :: " Pmpcfg_ent \<Rightarrow>(1)Word.word "  where 
     " get_Pmpcfg_ent_X v = (
   (subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Pmpcfg_ent "


\<comment> \<open>\<open>val _set_Pmpcfg_ent_X : register_ref regstate register_value Pmpcfg_ent -> mword ty1 -> M unit\<close>\<close>

definition set_Pmpcfg_ent_X  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Pmpcfg_ent_X r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   r) (( 2 :: int)::ii) (( 2 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Pmpcfg_ent_X : Pmpcfg_ent -> mword ty1 -> Pmpcfg_ent\<close>\<close>

definition update_Pmpcfg_ent_X  :: " Pmpcfg_ent \<Rightarrow>(1)Word.word \<Rightarrow> Pmpcfg_ent "  where 
     " update_Pmpcfg_ent_X v x = (
   (v (|
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Pmpcfg_ent_W : Pmpcfg_ent -> mword ty1\<close>\<close>

definition get_Pmpcfg_ent_W  :: " Pmpcfg_ent \<Rightarrow>(1)Word.word "  where 
     " get_Pmpcfg_ent_W v = (
   (subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Pmpcfg_ent "


\<comment> \<open>\<open>val _set_Pmpcfg_ent_W : register_ref regstate register_value Pmpcfg_ent -> mword ty1 -> M unit\<close>\<close>

definition set_Pmpcfg_ent_W  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Pmpcfg_ent_W r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Pmpcfg_ent_W : Pmpcfg_ent -> mword ty1 -> Pmpcfg_ent\<close>\<close>

definition update_Pmpcfg_ent_W  :: " Pmpcfg_ent \<Rightarrow>(1)Word.word \<Rightarrow> Pmpcfg_ent "  where 
     " update_Pmpcfg_ent_W v x = (
   (v (|
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val _get_Pmpcfg_ent_R : Pmpcfg_ent -> mword ty1\<close>\<close>

definition get_Pmpcfg_ent_R  :: " Pmpcfg_ent \<Rightarrow>(1)Word.word "  where 
     " get_Pmpcfg_ent_R v = (
   (subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Pmpcfg_ent "


\<comment> \<open>\<open>val _set_Pmpcfg_ent_R : register_ref regstate register_value Pmpcfg_ent -> mword ty1 -> M unit\<close>\<close>

definition set_Pmpcfg_ent_R  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Pmpcfg_ent_R r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
         ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Pmpcfg_ent))register_ref " 
  and  v  :: "(1)Word.word "


\<comment> \<open>\<open>val _update_Pmpcfg_ent_R : Pmpcfg_ent -> mword ty1 -> Pmpcfg_ent\<close>\<close>

definition update_Pmpcfg_ent_R  :: " Pmpcfg_ent \<Rightarrow>(1)Word.word \<Rightarrow> Pmpcfg_ent "  where 
     " update_Pmpcfg_ent_R v x = (
   (v (|
     Pmpcfg_ent_Pmpcfg_ent_chunk_0 :=
       ((update_subrange_vec_dec(Pmpcfg_ent_Pmpcfg_ent_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " Pmpcfg_ent " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val pmpReadCfgReg : integer -> M (mword ty32)\<close>\<close>

definition pmpReadCfgReg  :: " int \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " pmpReadCfgReg n = (
   (let p00 = n in
   if (((p00 = (( 0 :: int)::ii)))) then
     read_reg pmp3cfg_ref \<bind> (\<lambda> (w__0 :: Pmpcfg_ent) . 
     read_reg pmp2cfg_ref \<bind> (\<lambda> (w__1 :: Pmpcfg_ent) . 
     read_reg pmp1cfg_ref \<bind> (\<lambda> (w__2 :: Pmpcfg_ent) . 
     read_reg pmp0cfg_ref \<bind> (\<lambda> (w__3 :: Pmpcfg_ent) . 
     return ((concat_vec ((get_Pmpcfg_ent_bits w__0  ::  8 Word.word))
                ((concat_vec ((get_Pmpcfg_ent_bits w__1  ::  8 Word.word))
                    ((concat_vec ((get_Pmpcfg_ent_bits w__2  ::  8 Word.word))
                        ((get_Pmpcfg_ent_bits w__3  ::  8 Word.word))
                       ::  16 Word.word))
                   ::  24 Word.word))
               ::  32 Word.word))))))
   else if (((p00 = (( 1 :: int)::ii)))) then
     read_reg pmp7cfg_ref \<bind> (\<lambda> (w__4 :: Pmpcfg_ent) . 
     read_reg pmp6cfg_ref \<bind> (\<lambda> (w__5 :: Pmpcfg_ent) . 
     read_reg pmp5cfg_ref \<bind> (\<lambda> (w__6 :: Pmpcfg_ent) . 
     read_reg pmp4cfg_ref \<bind> (\<lambda> (w__7 :: Pmpcfg_ent) . 
     return ((concat_vec ((get_Pmpcfg_ent_bits w__4  ::  8 Word.word))
                ((concat_vec ((get_Pmpcfg_ent_bits w__5  ::  8 Word.word))
                    ((concat_vec ((get_Pmpcfg_ent_bits w__6  ::  8 Word.word))
                        ((get_Pmpcfg_ent_bits w__7  ::  8 Word.word))
                       ::  16 Word.word))
                   ::  24 Word.word))
               ::  32 Word.word))))))
   else if (((p00 = (( 2 :: int)::ii)))) then
     read_reg pmp11cfg_ref \<bind> (\<lambda> (w__8 :: Pmpcfg_ent) . 
     read_reg pmp10cfg_ref \<bind> (\<lambda> (w__9 :: Pmpcfg_ent) . 
     read_reg pmp9cfg_ref \<bind> (\<lambda> (w__10 :: Pmpcfg_ent) . 
     read_reg pmp8cfg_ref \<bind> (\<lambda> (w__11 :: Pmpcfg_ent) . 
     return ((concat_vec ((get_Pmpcfg_ent_bits w__8  ::  8 Word.word))
                ((concat_vec ((get_Pmpcfg_ent_bits w__9  ::  8 Word.word))
                    ((concat_vec ((get_Pmpcfg_ent_bits w__10  ::  8 Word.word))
                        ((get_Pmpcfg_ent_bits w__11  ::  8 Word.word))
                       ::  16 Word.word))
                   ::  24 Word.word))
               ::  32 Word.word))))))
   else if (((p00 = (( 3 :: int)::ii)))) then
     read_reg pmp15cfg_ref \<bind> (\<lambda> (w__12 :: Pmpcfg_ent) . 
     read_reg pmp14cfg_ref \<bind> (\<lambda> (w__13 :: Pmpcfg_ent) . 
     read_reg pmp13cfg_ref \<bind> (\<lambda> (w__14 :: Pmpcfg_ent) . 
     read_reg pmp12cfg_ref \<bind> (\<lambda> (w__15 :: Pmpcfg_ent) . 
     return ((concat_vec ((get_Pmpcfg_ent_bits w__12  ::  8 Word.word))
                ((concat_vec ((get_Pmpcfg_ent_bits w__13  ::  8 Word.word))
                    ((concat_vec ((get_Pmpcfg_ent_bits w__14  ::  8 Word.word))
                        ((get_Pmpcfg_ent_bits w__15  ::  8 Word.word))
                       ::  16 Word.word))
                   ::  24 Word.word))
               ::  32 Word.word))))))
   else assert_exp False (''Pattern match failure at model/riscv_pmp_regs.sail 75:2 - 85:8'') \<then> exit0 () ))" 
  for  n  :: " int "


\<comment> \<open>\<open>val pmpWriteCfg : Pmpcfg_ent -> mword ty8 -> Pmpcfg_ent\<close>\<close>

definition pmpWriteCfg  :: " Pmpcfg_ent \<Rightarrow>(8)Word.word \<Rightarrow> Pmpcfg_ent "  where 
     " pmpWriteCfg (cfg :: Pmpcfg_ent) (v :: 8 bits) = (
   if (((((get_Pmpcfg_ent_L cfg  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then cfg
   else Mk_Pmpcfg_ent v )" 
  for  cfg  :: " Pmpcfg_ent " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val pmpWriteCfgReg : integer -> mword ty32 -> M unit\<close>\<close>

definition pmpWriteCfgReg  :: " int \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " pmpWriteCfgReg n v = (
   (let p00 = n in
   if (((p00 = (( 0 :: int)::ii)))) then
     read_reg pmp0cfg_ref \<bind> (\<lambda> (w__0 :: Pmpcfg_ent) . 
     (write_reg pmp0cfg_ref ((pmpWriteCfg w__0 ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp1cfg_ref) \<bind> (\<lambda> (w__1 :: Pmpcfg_ent) . 
     (write_reg pmp1cfg_ref ((pmpWriteCfg w__1 ((subrange_vec_dec v (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp2cfg_ref) \<bind> (\<lambda> (w__2 :: Pmpcfg_ent) . 
     (write_reg pmp2cfg_ref ((pmpWriteCfg w__2 ((subrange_vec_dec v (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp3cfg_ref) \<bind> (\<lambda> (w__3 :: Pmpcfg_ent) . 
     write_reg pmp3cfg_ref ((pmpWriteCfg w__3 ((subrange_vec_dec v (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))))))
   else if (((p00 = (( 1 :: int)::ii)))) then
     read_reg pmp4cfg_ref \<bind> (\<lambda> (w__4 :: Pmpcfg_ent) . 
     (write_reg pmp4cfg_ref ((pmpWriteCfg w__4 ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp5cfg_ref) \<bind> (\<lambda> (w__5 :: Pmpcfg_ent) . 
     (write_reg pmp5cfg_ref ((pmpWriteCfg w__5 ((subrange_vec_dec v (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp6cfg_ref) \<bind> (\<lambda> (w__6 :: Pmpcfg_ent) . 
     (write_reg pmp6cfg_ref ((pmpWriteCfg w__6 ((subrange_vec_dec v (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp7cfg_ref) \<bind> (\<lambda> (w__7 :: Pmpcfg_ent) . 
     write_reg pmp7cfg_ref ((pmpWriteCfg w__7 ((subrange_vec_dec v (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))))))
   else if (((p00 = (( 2 :: int)::ii)))) then
     read_reg pmp8cfg_ref \<bind> (\<lambda> (w__8 :: Pmpcfg_ent) . 
     (let pmp8cfg8 = (pmpWriteCfg w__8 ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))) in
     read_reg pmp9cfg_ref \<bind> (\<lambda> (w__9 :: Pmpcfg_ent) . 
     (let pmp9cfg9 = (pmpWriteCfg w__9 ((subrange_vec_dec v (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word))) in
     read_reg pmp10cfg_ref \<bind> (\<lambda> (w__10 :: Pmpcfg_ent) . 
     (write_reg
       pmp10cfg_ref
       ((pmpWriteCfg w__10 ((subrange_vec_dec v (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp11cfg_ref) \<bind> (\<lambda> (w__11 :: Pmpcfg_ent) . 
     write_reg
       pmp11cfg_ref
       ((pmpWriteCfg w__11 ((subrange_vec_dec v (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))))))))
   else if (((p00 = (( 3 :: int)::ii)))) then
     read_reg pmp12cfg_ref \<bind> (\<lambda> (w__12 :: Pmpcfg_ent) . 
     (write_reg pmp12cfg_ref ((pmpWriteCfg w__12 ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp13cfg_ref) \<bind> (\<lambda> (w__13 :: Pmpcfg_ent) . 
     (write_reg pmp13cfg_ref ((pmpWriteCfg w__13 ((subrange_vec_dec v (( 15 :: int)::ii) (( 8 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp14cfg_ref) \<bind> (\<lambda> (w__14 :: Pmpcfg_ent) . 
     (write_reg
       pmp14cfg_ref
       ((pmpWriteCfg w__14 ((subrange_vec_dec v (( 23 :: int)::ii) (( 16 :: int)::ii)  ::  8 Word.word)))) \<then>
     read_reg pmp15cfg_ref) \<bind> (\<lambda> (w__15 :: Pmpcfg_ent) . 
     write_reg
       pmp15cfg_ref
       ((pmpWriteCfg w__15 ((subrange_vec_dec v (( 31 :: int)::ii) (( 24 :: int)::ii)  ::  8 Word.word))))))))
   else
     assert_exp False (''Pattern match failure at model/riscv_pmp_regs.sail 94:2 - 137:8'') \<then> exit0 () ))" 
  for  n  :: " int " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val pmpWriteAddr : Pmpcfg_ent -> mword ty32 -> mword ty32 -> mword ty32\<close>\<close>

definition pmpWriteAddr  :: " Pmpcfg_ent \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word "  where 
     " pmpWriteAddr (cfg :: Pmpcfg_ent) (reg :: xlenbits) (v :: xlenbits) = (
   if (((((get_Pmpcfg_ent_L cfg  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then reg
   else v )" 
  for  cfg  :: " Pmpcfg_ent " 
  and  reg  :: "(32)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val pmpAddrRange : Pmpcfg_ent -> mword ty32 -> mword ty32 -> M (maybe ((mword ty32 * mword ty32)))\<close>\<close>

definition pmpAddrRange  :: " Pmpcfg_ent \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(((32)Word.word*(32)Word.word)option),(exception))monad "  where 
     " pmpAddrRange (cfg :: Pmpcfg_ent) (pmpaddr :: xlenbits) (prev_pmpaddr :: xlenbits) = (
   pmpAddrMatchType_of_bits ((get_Pmpcfg_ent_A cfg  ::  2 Word.word)) \<bind> (\<lambda> (w__0 :: PmpAddrMatchType) . 
   return ((case  w__0 of
     OFF => None
   | TOR => Some ((shiftl prev_pmpaddr (( 2 :: int)::ii)  ::  32 Word.word), (shiftl pmpaddr (( 2 :: int)::ii)  ::  32 Word.word))
   | NA4 =>
      (let lo = ((shiftl pmpaddr (( 2 :: int)::ii)  ::  32 Word.word)) in
      Some (lo, (add_vec_int lo (( 4 :: int)::ii)  ::  32 Word.word)))
   | NAPOT =>
      (let mask1 = ((xor_vec pmpaddr ((add_vec_int pmpaddr (( 1 :: int)::ii)  ::  32 Word.word))  ::  32 Word.word)) in
      (let lo = ((and_vec pmpaddr ((not_vec mask1  ::  32 Word.word))  ::  32 Word.word)) in
      (let len = ((add_vec_int mask1 (( 1 :: int)::ii)  ::  32 Word.word)) in
      Some ((shiftl lo (( 2 :: int)::ii)  ::  32 Word.word),
            (shiftl ((add_vec lo len  ::  32 Word.word)) (( 2 :: int)::ii)  ::  32 Word.word)))))
   ))))" 
  for  cfg  :: " Pmpcfg_ent " 
  and  pmpaddr  :: "(32)Word.word " 
  and  prev_pmpaddr  :: "(32)Word.word "


\<comment> \<open>\<open>val pmpCheckRWX : Pmpcfg_ent -> AccessType -> bool\<close>\<close>

fun pmpCheckRWX  :: " Pmpcfg_ent \<Rightarrow> AccessType \<Rightarrow> bool "  where 
     " pmpCheckRWX ent Read = ( (((get_Pmpcfg_ent_R ent  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))" 
  for  ent  :: " Pmpcfg_ent "
|" pmpCheckRWX ent Write = ( (((get_Pmpcfg_ent_W ent  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))" 
  for  ent  :: " Pmpcfg_ent "
|" pmpCheckRWX ent ReadWrite = (
      ((((((get_Pmpcfg_ent_R ent  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> (((((get_Pmpcfg_ent_W ent  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))" 
  for  ent  :: " Pmpcfg_ent "
|" pmpCheckRWX ent Execute = ( (((get_Pmpcfg_ent_X ent  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))" 
  for  ent  :: " Pmpcfg_ent "


\<comment> \<open>\<open>val pmpCheckPerms : Pmpcfg_ent -> AccessType -> Privilege -> bool\<close>\<close>

fun pmpCheckPerms  :: " Pmpcfg_ent \<Rightarrow> AccessType \<Rightarrow> Privilege \<Rightarrow> bool "  where 
     " pmpCheckPerms ent acc1 Machine = (
      if (((((get_Pmpcfg_ent_L ent  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
        pmpCheckRWX ent acc1
      else True )" 
  for  ent  :: " Pmpcfg_ent " 
  and  acc1  :: " AccessType "
|" pmpCheckPerms ent acc1 _ = ( pmpCheckRWX ent acc1 )" 
  for  ent  :: " Pmpcfg_ent " 
  and  acc1  :: " AccessType "


\<comment> \<open>\<open>val pmpAddrMatch_of_num : integer -> pmpAddrMatch\<close>\<close>

definition pmpAddrMatch_of_num  :: " int \<Rightarrow> pmpAddrMatch "  where 
     " pmpAddrMatch_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then PMP_NoMatch
   else if (((p00 = (( 1 :: int)::ii)))) then PMP_PartialMatch
   else PMP_Match))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_pmpAddrMatch : pmpAddrMatch -> integer\<close>\<close>

fun num_of_pmpAddrMatch  :: " pmpAddrMatch \<Rightarrow> int "  where 
     " num_of_pmpAddrMatch PMP_NoMatch = ( (( 0 :: int)::ii))"
|" num_of_pmpAddrMatch PMP_PartialMatch = ( (( 1 :: int)::ii))"
|" num_of_pmpAddrMatch PMP_Match = ( (( 2 :: int)::ii))"


\<comment> \<open>\<open>val pmpMatchAddr : mword ty32 -> mword ty32 -> maybe ((mword ty32 * mword ty32)) -> pmpAddrMatch\<close>\<close>

fun pmpMatchAddr  :: "(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(xlenbits*xlenbits)option \<Rightarrow> pmpAddrMatch "  where 
     " pmpMatchAddr (addr :: xlenbits) (width :: xlenbits) (None :: pmp_addr_range) = ( PMP_NoMatch )" 
  for  addr  :: "(32)Word.word " 
  and  width  :: "(32)Word.word "
|" pmpMatchAddr (addr :: xlenbits) (width :: xlenbits) ((Some ((lo, hi))) :: pmp_addr_range) = (
      if ((zopz0zI_u hi lo)) then PMP_NoMatch
      else if (((((zopz0zI_u ((add_vec addr width  ::  32 Word.word)) lo)) \<or> ((zopz0zI_u hi addr)))))
      then
        PMP_NoMatch
      else if (((((zopz0zIzJ_u lo addr)) \<and> ((zopz0zIzJ_u ((add_vec addr width  ::  32 Word.word)) hi))))) then
        PMP_Match
      else PMP_PartialMatch )" 
  for  addr  :: "(32)Word.word " 
  and  width  :: "(32)Word.word " 
  and  hi  :: "(32)Word.word " 
  and  lo  :: "(32)Word.word "


\<comment> \<open>\<open>val pmpMatch_of_num : integer -> pmpMatch\<close>\<close>

definition pmpMatch_of_num  :: " int \<Rightarrow> pmpMatch "  where 
     " pmpMatch_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then PMP_Success
   else if (((p00 = (( 1 :: int)::ii)))) then PMP_Continue
   else PMP_Fail))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_pmpMatch : pmpMatch -> integer\<close>\<close>

fun num_of_pmpMatch  :: " pmpMatch \<Rightarrow> int "  where 
     " num_of_pmpMatch PMP_Success = ( (( 0 :: int)::ii))"
|" num_of_pmpMatch PMP_Continue = ( (( 1 :: int)::ii))"
|" num_of_pmpMatch PMP_Fail = ( (( 2 :: int)::ii))"


\<comment> \<open>\<open>val pmpMatchEntry : mword ty32 -> mword ty32 -> AccessType -> Privilege -> Pmpcfg_ent -> mword ty32 -> mword ty32 -> M pmpMatch\<close>\<close>

definition pmpMatchEntry  :: "(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> AccessType \<Rightarrow> Privilege \<Rightarrow> Pmpcfg_ent \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(pmpMatch),(exception))monad "  where 
     " pmpMatchEntry (addr :: xlenbits) (width :: xlenbits) (acc1 :: AccessType) (priv :: Privilege) (ent ::
  Pmpcfg_ent) (pmpaddr :: xlenbits) (prev_pmpaddr :: xlenbits) = (
   (pmpAddrRange ent pmpaddr prev_pmpaddr  :: ( (( 32 Word.word *  32 Word.word))option) M) \<bind> (\<lambda> rng . 
   return ((case  ((pmpMatchAddr addr width rng)) of
     PMP_NoMatch => PMP_Continue
   | PMP_PartialMatch => PMP_Fail
   | PMP_Match => if ((pmpCheckPerms ent acc1 priv)) then PMP_Success else PMP_Fail
   ))))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: "(32)Word.word " 
  and  acc1  :: " AccessType " 
  and  priv  :: " Privilege " 
  and  ent  :: " Pmpcfg_ent " 
  and  pmpaddr  :: "(32)Word.word " 
  and  prev_pmpaddr  :: "(32)Word.word "


\<comment> \<open>\<open>val pmpCheck : mword ty32 -> integer -> AccessType -> Privilege -> M (maybe ExceptionType)\<close>\<close>

definition pmpCheck  :: "(32)Word.word \<Rightarrow> int \<Rightarrow> AccessType \<Rightarrow> Privilege \<Rightarrow>((register_value),((ExceptionType)option),(exception))monad "  where 
     " pmpCheck (addr :: xlenbits) (width :: int) (acc1 :: AccessType) (priv :: Privilege) = (
   (let (width :: xlenbits) = ((to_bits (( 32 :: int)::ii) width  ::  32 Word.word)) in
   read_reg pmp0cfg_ref \<bind> (\<lambda> (w__0 :: Pmpcfg_ent) . 
   (read_reg pmpaddr0_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
   pmpMatchEntry addr width acc1 priv w__0 w__1 ((zeros_implicit (( 32 :: int)::ii)  ::  32 Word.word)) \<bind> (\<lambda> (w__2 ::
     pmpMatch) . 
   (case  w__2 of
     PMP_Success => return True
   | PMP_Fail => return False
   | PMP_Continue =>
      read_reg pmp1cfg_ref \<bind> (\<lambda> (w__3 :: Pmpcfg_ent) . 
      (read_reg pmpaddr1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 ::  32 Word.word) . 
      (read_reg pmpaddr0_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__5 ::  32 Word.word) . 
      pmpMatchEntry addr width acc1 priv w__3 w__4 w__5 \<bind> (\<lambda> (w__6 :: pmpMatch) . 
      (case  w__6 of
        PMP_Success => return True
      | PMP_Fail => return False
      | PMP_Continue =>
         read_reg pmp2cfg_ref \<bind> (\<lambda> (w__7 :: Pmpcfg_ent) . 
         (read_reg pmpaddr2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 ::  32 Word.word) . 
         (read_reg pmpaddr1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 ::  32 Word.word) . 
         pmpMatchEntry addr width acc1 priv w__7 w__8 w__9 \<bind> (\<lambda> (w__10 :: pmpMatch) . 
         (case  w__10 of
           PMP_Success => return True
         | PMP_Fail => return False
         | PMP_Continue =>
            read_reg pmp3cfg_ref \<bind> (\<lambda> (w__11 :: Pmpcfg_ent) . 
            (read_reg pmpaddr3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 ::  32 Word.word) . 
            (read_reg pmpaddr2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 ::  32 Word.word) . 
            pmpMatchEntry addr width acc1 priv w__11 w__12 w__13 \<bind> (\<lambda> (w__14 :: pmpMatch) . 
            (case  w__14 of
              PMP_Success => return True
            | PMP_Fail => return False
            | PMP_Continue =>
               read_reg pmp4cfg_ref \<bind> (\<lambda> (w__15 :: Pmpcfg_ent) . 
               (read_reg pmpaddr4_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__16 ::  32 Word.word) . 
               (read_reg pmpaddr3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__17 ::  32 Word.word) . 
               pmpMatchEntry addr width acc1 priv w__15 w__16 w__17 \<bind> (\<lambda> (w__18 :: pmpMatch) . 
               (case  w__18 of
                 PMP_Success => return True
               | PMP_Fail => return False
               | PMP_Continue =>
                  read_reg pmp5cfg_ref \<bind> (\<lambda> (w__19 :: Pmpcfg_ent) . 
                  (read_reg pmpaddr5_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__20 ::  32 Word.word) . 
                  (read_reg pmpaddr4_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__21 ::  32 Word.word) . 
                  pmpMatchEntry addr width acc1 priv w__19 w__20 w__21 \<bind> (\<lambda> (w__22 :: pmpMatch) . 
                  (case  w__22 of
                    PMP_Success => return True
                  | PMP_Fail => return False
                  | PMP_Continue =>
                     read_reg pmp6cfg_ref \<bind> (\<lambda> (w__23 :: Pmpcfg_ent) . 
                     (read_reg pmpaddr6_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__24 ::  32 Word.word) . 
                     (read_reg pmpaddr5_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__25 ::  32 Word.word) . 
                     pmpMatchEntry addr width acc1 priv w__23 w__24 w__25 \<bind> (\<lambda> (w__26 :: pmpMatch) . 
                     (case  w__26 of
                       PMP_Success => return True
                     | PMP_Fail => return False
                     | PMP_Continue =>
                        read_reg pmp7cfg_ref \<bind> (\<lambda> (w__27 :: Pmpcfg_ent) . 
                        (read_reg pmpaddr7_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__28 ::  32 Word.word) . 
                        (read_reg pmpaddr6_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__29 ::  32 Word.word) . 
                        pmpMatchEntry addr width acc1 priv w__27 w__28 w__29 \<bind> (\<lambda> (w__30 ::
                          pmpMatch) . 
                        (case  w__30 of
                          PMP_Success => return True
                        | PMP_Fail => return False
                        | PMP_Continue =>
                           read_reg pmp8cfg_ref \<bind> (\<lambda> (w__31 :: Pmpcfg_ent) . 
                           (read_reg pmpaddr8_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__32 ::  32 Word.word) . 
                           (read_reg pmpaddr7_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__33 ::  32 Word.word) . 
                           pmpMatchEntry addr width acc1 priv w__31 w__32 w__33 \<bind> (\<lambda> (w__34 ::
                             pmpMatch) . 
                           (case  w__34 of
                             PMP_Success => return True
                           | PMP_Fail => return False
                           | PMP_Continue =>
                              read_reg pmp9cfg_ref \<bind> (\<lambda> (w__35 :: Pmpcfg_ent) . 
                              (read_reg pmpaddr9_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__36 ::  32 Word.word) . 
                              (read_reg pmpaddr8_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__37 ::  32 Word.word) . 
                              pmpMatchEntry addr width acc1 priv w__35 w__36 w__37 \<bind> (\<lambda> (w__38 ::
                                pmpMatch) . 
                              (case  w__38 of
                                PMP_Success => return True
                              | PMP_Fail => return False
                              | PMP_Continue =>
                                 read_reg pmp10cfg_ref \<bind> (\<lambda> (w__39 :: Pmpcfg_ent) . 
                                 (read_reg pmpaddr10_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__40 ::
                                    32 Word.word) . 
                                 (read_reg pmpaddr9_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__41 ::
                                    32 Word.word) . 
                                 pmpMatchEntry addr width acc1 priv w__39 w__40 w__41 \<bind> (\<lambda> (w__42 ::
                                   pmpMatch) . 
                                 (case  w__42 of
                                   PMP_Success => return True
                                 | PMP_Fail => return False
                                 | PMP_Continue =>
                                    read_reg pmp11cfg_ref \<bind> (\<lambda> (w__43 :: Pmpcfg_ent) . 
                                    (read_reg pmpaddr11_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__44 ::
                                       32 Word.word) . 
                                    (read_reg pmpaddr10_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__45 ::
                                       32 Word.word) . 
                                    pmpMatchEntry addr width acc1 priv w__43 w__44 w__45 \<bind> (\<lambda> (w__46 ::
                                      pmpMatch) . 
                                    (case  w__46 of
                                      PMP_Success => return True
                                    | PMP_Fail => return False
                                    | PMP_Continue =>
                                       read_reg pmp12cfg_ref \<bind> (\<lambda> (w__47 :: Pmpcfg_ent) . 
                                       (read_reg pmpaddr12_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__48 ::
                                          32 Word.word) . 
                                       (read_reg pmpaddr11_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__49 ::
                                          32 Word.word) . 
                                       pmpMatchEntry addr width acc1 priv w__47 w__48 w__49 \<bind> (\<lambda> (w__50 ::
                                         pmpMatch) . 
                                       (case  w__50 of
                                         PMP_Success => return True
                                       | PMP_Fail => return False
                                       | PMP_Continue =>
                                          read_reg pmp13cfg_ref \<bind> (\<lambda> (w__51 :: Pmpcfg_ent) . 
                                          (read_reg pmpaddr13_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__52 ::
                                             32 Word.word) . 
                                          (read_reg pmpaddr12_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__53 ::
                                             32 Word.word) . 
                                          pmpMatchEntry addr width acc1 priv w__51 w__52 w__53 \<bind> (\<lambda> (w__54 ::
                                            pmpMatch) . 
                                          (case  w__54 of
                                            PMP_Success => return True
                                          | PMP_Fail => return False
                                          | PMP_Continue =>
                                             read_reg pmp14cfg_ref \<bind> (\<lambda> (w__55 :: Pmpcfg_ent) . 
                                             (read_reg pmpaddr14_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__56 ::
                                                32 Word.word) . 
                                             (read_reg pmpaddr13_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__57 ::
                                                32 Word.word) . 
                                             pmpMatchEntry addr width acc1 priv w__55 w__56 w__57 \<bind> (\<lambda> (w__58 ::
                                               pmpMatch) . 
                                             (case  w__58 of
                                               PMP_Success => return True
                                             | PMP_Fail => return False
                                             | PMP_Continue =>
                                                read_reg pmp15cfg_ref \<bind> (\<lambda> (w__59 :: Pmpcfg_ent) . 
                                                (read_reg pmpaddr15_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__60 ::
                                                   32 Word.word) . 
                                                (read_reg pmpaddr14_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__61 ::
                                                   32 Word.word) . 
                                                pmpMatchEntry addr width acc1 priv w__59 w__60 w__61 \<bind> (\<lambda> (w__62 ::
                                                  pmpMatch) . 
                                                return ((case  w__62 of
                                                  PMP_Success => True
                                                | PMP_Fail => False
                                                | PMP_Continue =>
                                                   (case  priv of
                                                     Machine => True
                                                   | _ => False
                                                   )
                                                ))))))
                                             )))))
                                          )))))
                                       )))))
                                    )))))
                                 )))))
                              )))))
                           )))))
                        )))))
                     )))))
                  )))))
               )))))
            )))))
         )))))
      )))))
   ) \<bind> (\<lambda> (check' :: bool) . 
   return (if check' then None
           else
             (case  acc1 of
               Read => Some E_Load_Access_Fault
             | Write => Some E_SAMO_Access_Fault
             | ReadWrite => Some E_SAMO_Access_Fault
             | Execute => Some E_Fetch_Access_Fault
             ))))))))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  acc1  :: " AccessType " 
  and  priv  :: " Privilege "


\<comment> \<open>\<open>val init_pmp : unit -> M unit\<close>\<close>

definition init_pmp  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " init_pmp _ = (
   read_reg pmp0cfg_ref \<bind> (\<lambda> (w__0 :: Pmpcfg_ent) . 
   (write_reg pmp0cfg_ref ((update_Pmpcfg_ent_A w__0 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp1cfg_ref) \<bind> (\<lambda> (w__1 :: Pmpcfg_ent) . 
   (write_reg pmp1cfg_ref ((update_Pmpcfg_ent_A w__1 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp2cfg_ref) \<bind> (\<lambda> (w__2 :: Pmpcfg_ent) . 
   (write_reg pmp2cfg_ref ((update_Pmpcfg_ent_A w__2 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp3cfg_ref) \<bind> (\<lambda> (w__3 :: Pmpcfg_ent) . 
   (write_reg pmp3cfg_ref ((update_Pmpcfg_ent_A w__3 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp4cfg_ref) \<bind> (\<lambda> (w__4 :: Pmpcfg_ent) . 
   (write_reg pmp4cfg_ref ((update_Pmpcfg_ent_A w__4 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp5cfg_ref) \<bind> (\<lambda> (w__5 :: Pmpcfg_ent) . 
   (write_reg pmp5cfg_ref ((update_Pmpcfg_ent_A w__5 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp6cfg_ref) \<bind> (\<lambda> (w__6 :: Pmpcfg_ent) . 
   (write_reg pmp6cfg_ref ((update_Pmpcfg_ent_A w__6 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp7cfg_ref) \<bind> (\<lambda> (w__7 :: Pmpcfg_ent) . 
   (write_reg pmp7cfg_ref ((update_Pmpcfg_ent_A w__7 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp8cfg_ref) \<bind> (\<lambda> (w__8 :: Pmpcfg_ent) . 
   (write_reg pmp8cfg_ref ((update_Pmpcfg_ent_A w__8 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp9cfg_ref) \<bind> (\<lambda> (w__9 :: Pmpcfg_ent) . 
   (write_reg pmp9cfg_ref ((update_Pmpcfg_ent_A w__9 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp10cfg_ref) \<bind> (\<lambda> (w__10 :: Pmpcfg_ent) . 
   (write_reg
     pmp10cfg_ref
     ((update_Pmpcfg_ent_A w__10 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp11cfg_ref) \<bind> (\<lambda> (w__11 :: Pmpcfg_ent) . 
   (write_reg
     pmp11cfg_ref
     ((update_Pmpcfg_ent_A w__11 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp12cfg_ref) \<bind> (\<lambda> (w__12 :: Pmpcfg_ent) . 
   (write_reg
     pmp12cfg_ref
     ((update_Pmpcfg_ent_A w__12 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp13cfg_ref) \<bind> (\<lambda> (w__13 :: Pmpcfg_ent) . 
   (write_reg
     pmp13cfg_ref
     ((update_Pmpcfg_ent_A w__13 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp14cfg_ref) \<bind> (\<lambda> (w__14 :: Pmpcfg_ent) . 
   (write_reg
     pmp14cfg_ref
     ((update_Pmpcfg_ent_A w__14 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))) \<then>
   read_reg pmp15cfg_ref) \<bind> (\<lambda> (w__15 :: Pmpcfg_ent) . 
   write_reg
     pmp15cfg_ref
     ((update_Pmpcfg_ent_A w__15 ((pmpAddrMatchType_to_bits OFF  ::  2 Word.word)))))))))))))))))))))"


\<comment> \<open>\<open>val ext_init_regs : unit -> M unit\<close>\<close>

definition ext_init_regs  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " ext_init_regs _ = ( return ()  )"


\<comment> \<open>\<open>
This function is called after above when running rvfi and allows the model
to be initialised differently (e.g. CHERI cap regs are initialised
to omnipotent instead of null).
 \<close>\<close>
\<comment> \<open>\<open>val ext_rvfi_init : unit -> M unit\<close>\<close>

definition ext_rvfi_init  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " ext_rvfi_init _ = ( return ()  )"


\<comment> \<open>\<open>val ext_fetch_check_pc : mword ty32 -> mword ty32 -> Ext_FetchAddr_Check unit\<close>\<close>

definition ext_fetch_check_pc  :: "(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(unit)Ext_FetchAddr_Check "  where 
     " ext_fetch_check_pc (start_pc :: xlenbits) (pc :: xlenbits) = ( Ext_FetchAddr_OK pc )" 
  for  start_pc  :: "(32)Word.word " 
  and  pc  :: "(32)Word.word "


\<comment> \<open>\<open>val ext_handle_fetch_check_error : unit -> unit\<close>\<close>

definition ext_handle_fetch_check_error  :: " unit \<Rightarrow> unit "  where 
     " ext_handle_fetch_check_error err = ( ()  )" 
  for  err  :: " unit "


\<comment> \<open>\<open>val ext_control_check_addr : mword ty32 -> Ext_ControlAddr_Check unit\<close>\<close>

definition ext_control_check_addr  :: "(32)Word.word \<Rightarrow>(unit)Ext_ControlAddr_Check "  where 
     " ext_control_check_addr pc = ( Ext_ControlAddr_OK pc )" 
  for  pc  :: "(32)Word.word "


\<comment> \<open>\<open>val ext_control_check_pc : mword ty32 -> Ext_ControlAddr_Check unit\<close>\<close>

definition ext_control_check_pc  :: "(32)Word.word \<Rightarrow>(unit)Ext_ControlAddr_Check "  where 
     " ext_control_check_pc pc = ( Ext_ControlAddr_OK pc )" 
  for  pc  :: "(32)Word.word "


\<comment> \<open>\<open>val ext_handle_control_check_error : unit -> unit\<close>\<close>

definition ext_handle_control_check_error  :: " unit \<Rightarrow> unit "  where 
     " ext_handle_control_check_error err = ( ()  )" 
  for  err  :: " unit "


\<comment> \<open>\<open>val ext_data_get_addr : mword ty5 -> mword ty32 -> AccessType -> word_width -> M (Ext_DataAddr_Check unit)\<close>\<close>

definition ext_data_get_addr  :: "(5)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> AccessType \<Rightarrow> word_width \<Rightarrow>((register_value),((unit)Ext_DataAddr_Check),(exception))monad "  where 
     " ext_data_get_addr (base :: regidx) (offset :: xlenbits) (acc1 :: AccessType) (width :: word_width) = (
   (rX ((regidx_to_regno base))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   (let addr = ((add_vec w__0 offset  ::  32 Word.word)) in
   return (Ext_DataAddr_OK addr))))" 
  for  base  :: "(5)Word.word " 
  and  offset  :: "(32)Word.word " 
  and  acc1  :: " AccessType " 
  and  width  :: " word_width "


\<comment> \<open>\<open>val ext_handle_data_check_error : unit -> unit\<close>\<close>

definition ext_handle_data_check_error  :: " unit \<Rightarrow> unit "  where 
     " ext_handle_data_check_error err = ( ()  )" 
  for  err  :: " unit "


\<comment> \<open>\<open>val csr_name : mword ty12 -> string\<close>\<close>

definition csr_name  :: "(12)Word.word \<Rightarrow> string "  where 
     " csr_name csr = (
   (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''ustatus'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''uie'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     (''utvec'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''uscratch'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''uepc'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''ucause'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''utval'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''uip'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''fflags'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''frm'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''fcsr'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''cycle'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''time'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''instret'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''cycleh'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''timeh'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''instreth'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''sstatus'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''sedeleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''sideleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''sie'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     (''stvec'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     (''scounteren'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''sscratch'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''sepc'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''scause'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''stval'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''sip'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''satp'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''mvendorid'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''marchid'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''mimpid'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''mhartid'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''mstatus'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''misa'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''medeleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''mideleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''mie'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     (''mtvec'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     (''mcounteren'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''mscratch'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (''mepc'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''mcause'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (''mtval'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     (''mip'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''pmpcfg0'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''pmpaddr0'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''mcycle'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''minstret'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''mcycleh'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     (''minstreth'')
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (''tselect'')
   else (''UNKNOWN'')))" 
  for  csr  :: "(12)Word.word "


\<comment> \<open>\<open>val csr_name_map_forwards : mword ty12 -> M string\<close>\<close>

definition csr_name_map_forwards  :: "(12)Word.word \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " csr_name_map_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''ustatus'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (''uie'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     return (''utvec'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''uscratch'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (''uepc'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''ucause'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (''utval'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (''uip'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (''fflags'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''frm'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (''fcsr'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''cycle'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (''time'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''instret'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''cycleh'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (''timeh'')
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''instreth'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''sstatus'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''sedeleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (''sideleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (''sie'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     return (''stvec'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     return (''scounteren'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''sscratch'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (''sepc'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''scause'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (''stval'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (''sip'')
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''satp'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (''mvendorid'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''marchid'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (''mimpid'')
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (''mhartid'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''mstatus'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (''misa'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''medeleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (''mideleg'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (''mie'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     return (''mtvec'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     return (''mcounteren'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''mscratch'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (''mepc'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''mcause'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (''mtval'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (''mip'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''pmpcfg0'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (''pmpcfg1'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''pmpcfg2'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (''pmpcfg3'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''pmpaddr0'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (''pmpaddr1'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''pmpaddr2'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (''pmpaddr3'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (''pmpaddr4'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B1]  ::  12 Word.word)))) then
     return (''pmpaddr5'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B0]  ::  12 Word.word)))) then
     return (''pmpaddr6'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B1]  ::  12 Word.word)))) then
     return (''pmpaddr7'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B0]  ::  12 Word.word)))) then
     return (''pmpaddr8'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B1]  ::  12 Word.word)))) then
     return (''pmpaddr9'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B0]  ::  12 Word.word)))) then
     return (''pmpaddr10'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B1]  ::  12 Word.word)))) then
     return (''pmpaddr11'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B0]  ::  12 Word.word)))) then
     return (''pmpaddr12'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B1]  ::  12 Word.word)))) then
     return (''pmpaddr13'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B0]  ::  12 Word.word)))) then
     return (''pmpaddr14'')
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B1]  ::  12 Word.word)))) then
     return (''pmpaddr15'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''mcycle'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''minstret'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''mcycleh'')
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''minstreth'')
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (''tselect'')
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (''tdata1'')
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (''tdata2'')
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (''tdata3'')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(12)Word.word "


\<comment> \<open>\<open>val csr_name_map_backwards : string -> M (mword ty12)\<close>\<close>

definition csr_name_map_backwards  :: " string \<Rightarrow>((register_value),((12)Word.word),(exception))monad "  where 
     " csr_name_map_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''ustatus'')))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''uie'')))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''utvec'')))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''uscratch'')))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''uepc'')))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''ucause'')))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''utval'')))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''uip'')))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''fflags'')))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''frm'')))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''fcsr'')))) then
     return (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''cycle'')))) then
     return (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''time'')))) then
     return (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''instret'')))) then
     return (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''cycleh'')))) then
     return (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''timeh'')))) then
     return (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''instreth'')))) then
     return (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''sstatus'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''sedeleg'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''sideleg'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''sie'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''stvec'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''scounteren'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''sscratch'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''sepc'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''scause'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''stval'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''sip'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''satp'')))) then
     return (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''mvendorid'')))) then
     return (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''marchid'')))) then
     return (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''mimpid'')))) then
     return (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''mhartid'')))) then
     return (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B1,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''mstatus'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''misa'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''medeleg'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''mideleg'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''mie'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''mtvec'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''mcounteren'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''mscratch'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''mepc'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''mcause'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''mtval'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''mip'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''pmpcfg0'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''pmpcfg1'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''pmpcfg2'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''pmpcfg3'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr0'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr1'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr2'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr3'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr4'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr5'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr6'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr7'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr8'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr9'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr10'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr11'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr12'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr13'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr14'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''pmpaddr15'')))) then
     return (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B1]  ::  12 Word.word)
   else if (((p00 = (''mcycle'')))) then
     return (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''minstret'')))) then
     return (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''mcycleh'')))) then
     return (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''minstreth'')))) then
     return (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''tselect'')))) then
     return (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)
   else if (((p00 = (''tdata1'')))) then
     return (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B1]  ::  12 Word.word)
   else if (((p00 = (''tdata2'')))) then
     return (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B1,B0]  ::  12 Word.word)
   else if (((p00 = (''tdata3'')))) then
     return (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B1,B1]  ::  12 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val csr_name_map_forwards_matches : mword ty12 -> bool\<close>\<close>

definition csr_name_map_forwards_matches  :: "(12)Word.word \<Rightarrow> bool "  where 
     " csr_name_map_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     True
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     True
   else False))" 
  for  arg1  :: "(12)Word.word "


\<comment> \<open>\<open>val csr_name_map_backwards_matches : string -> bool\<close>\<close>

definition csr_name_map_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " csr_name_map_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''ustatus'')))) then True
   else if (((p00 = (''uie'')))) then True
   else if (((p00 = (''utvec'')))) then True
   else if (((p00 = (''uscratch'')))) then True
   else if (((p00 = (''uepc'')))) then True
   else if (((p00 = (''ucause'')))) then True
   else if (((p00 = (''utval'')))) then True
   else if (((p00 = (''uip'')))) then True
   else if (((p00 = (''fflags'')))) then True
   else if (((p00 = (''frm'')))) then True
   else if (((p00 = (''fcsr'')))) then True
   else if (((p00 = (''cycle'')))) then True
   else if (((p00 = (''time'')))) then True
   else if (((p00 = (''instret'')))) then True
   else if (((p00 = (''cycleh'')))) then True
   else if (((p00 = (''timeh'')))) then True
   else if (((p00 = (''instreth'')))) then True
   else if (((p00 = (''sstatus'')))) then True
   else if (((p00 = (''sedeleg'')))) then True
   else if (((p00 = (''sideleg'')))) then True
   else if (((p00 = (''sie'')))) then True
   else if (((p00 = (''stvec'')))) then True
   else if (((p00 = (''scounteren'')))) then True
   else if (((p00 = (''sscratch'')))) then True
   else if (((p00 = (''sepc'')))) then True
   else if (((p00 = (''scause'')))) then True
   else if (((p00 = (''stval'')))) then True
   else if (((p00 = (''sip'')))) then True
   else if (((p00 = (''satp'')))) then True
   else if (((p00 = (''mvendorid'')))) then True
   else if (((p00 = (''marchid'')))) then True
   else if (((p00 = (''mimpid'')))) then True
   else if (((p00 = (''mhartid'')))) then True
   else if (((p00 = (''mstatus'')))) then True
   else if (((p00 = (''misa'')))) then True
   else if (((p00 = (''medeleg'')))) then True
   else if (((p00 = (''mideleg'')))) then True
   else if (((p00 = (''mie'')))) then True
   else if (((p00 = (''mtvec'')))) then True
   else if (((p00 = (''mcounteren'')))) then True
   else if (((p00 = (''mscratch'')))) then True
   else if (((p00 = (''mepc'')))) then True
   else if (((p00 = (''mcause'')))) then True
   else if (((p00 = (''mtval'')))) then True
   else if (((p00 = (''mip'')))) then True
   else if (((p00 = (''pmpcfg0'')))) then True
   else if (((p00 = (''pmpcfg1'')))) then True
   else if (((p00 = (''pmpcfg2'')))) then True
   else if (((p00 = (''pmpcfg3'')))) then True
   else if (((p00 = (''pmpaddr0'')))) then True
   else if (((p00 = (''pmpaddr1'')))) then True
   else if (((p00 = (''pmpaddr2'')))) then True
   else if (((p00 = (''pmpaddr3'')))) then True
   else if (((p00 = (''pmpaddr4'')))) then True
   else if (((p00 = (''pmpaddr5'')))) then True
   else if (((p00 = (''pmpaddr6'')))) then True
   else if (((p00 = (''pmpaddr7'')))) then True
   else if (((p00 = (''pmpaddr8'')))) then True
   else if (((p00 = (''pmpaddr9'')))) then True
   else if (((p00 = (''pmpaddr10'')))) then True
   else if (((p00 = (''pmpaddr11'')))) then True
   else if (((p00 = (''pmpaddr12'')))) then True
   else if (((p00 = (''pmpaddr13'')))) then True
   else if (((p00 = (''pmpaddr14'')))) then True
   else if (((p00 = (''pmpaddr15'')))) then True
   else if (((p00 = (''mcycle'')))) then True
   else if (((p00 = (''minstret'')))) then True
   else if (((p00 = (''mcycleh'')))) then True
   else if (((p00 = (''minstreth'')))) then True
   else if (((p00 = (''tselect'')))) then True
   else if (((p00 = (''tdata1'')))) then True
   else if (((p00 = (''tdata2'')))) then True
   else if (((p00 = (''tdata3'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val csr_name_map_matches_prefix : string -> maybe ((mword ty12 * ii))\<close>\<close>

\<comment> \<open>\<open>val _s488_ : string -> maybe string\<close>\<close>

definition s488  :: " string \<Rightarrow>(string)option "  where 
     " s488 s4890 = (
   (let s4900 = s4890 in
   if ((string_startswith s4900 (''tdata3''))) then  
  (case  ((string_drop s4900 ((string_length (''tdata3''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4890  :: " string "


\<comment> \<open>\<open>val _s484_ : string -> maybe string\<close>\<close>

definition s484  :: " string \<Rightarrow>(string)option "  where 
     " s484 s4850 = (
   (let s4860 = s4850 in
   if ((string_startswith s4860 (''tdata2''))) then  
  (case  ((string_drop s4860 ((string_length (''tdata2''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4850  :: " string "


\<comment> \<open>\<open>val _s480_ : string -> maybe string\<close>\<close>

definition s480  :: " string \<Rightarrow>(string)option "  where 
     " s480 s4810 = (
   (let s4820 = s4810 in
   if ((string_startswith s4820 (''tdata1''))) then  
  (case  ((string_drop s4820 ((string_length (''tdata1''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4810  :: " string "


\<comment> \<open>\<open>val _s476_ : string -> maybe string\<close>\<close>

definition s476  :: " string \<Rightarrow>(string)option "  where 
     " s476 s4770 = (
   (let s4780 = s4770 in
   if ((string_startswith s4780 (''tselect''))) then  
  (case  ((string_drop s4780 ((string_length (''tselect''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4770  :: " string "


\<comment> \<open>\<open>val _s472_ : string -> maybe string\<close>\<close>

definition s472  :: " string \<Rightarrow>(string)option "  where 
     " s472 s4730 = (
   (let s4740 = s4730 in
   if ((string_startswith s4740 (''minstreth''))) then  
  (case  ((string_drop s4740 ((string_length (''minstreth''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4730  :: " string "


\<comment> \<open>\<open>val _s468_ : string -> maybe string\<close>\<close>

definition s468  :: " string \<Rightarrow>(string)option "  where 
     " s468 s4690 = (
   (let s4700 = s4690 in
   if ((string_startswith s4700 (''mcycleh''))) then  
  (case  ((string_drop s4700 ((string_length (''mcycleh''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4690  :: " string "


\<comment> \<open>\<open>val _s464_ : string -> maybe string\<close>\<close>

definition s464  :: " string \<Rightarrow>(string)option "  where 
     " s464 s4650 = (
   (let s4660 = s4650 in
   if ((string_startswith s4660 (''minstret''))) then  
  (case  ((string_drop s4660 ((string_length (''minstret''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4650  :: " string "


\<comment> \<open>\<open>val _s460_ : string -> maybe string\<close>\<close>

definition s460  :: " string \<Rightarrow>(string)option "  where 
     " s460 s4610 = (
   (let s4620 = s4610 in
   if ((string_startswith s4620 (''mcycle''))) then  
  (case  ((string_drop s4620 ((string_length (''mcycle''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4610  :: " string "


\<comment> \<open>\<open>val _s456_ : string -> maybe string\<close>\<close>

definition s456  :: " string \<Rightarrow>(string)option "  where 
     " s456 s4570 = (
   (let s4580 = s4570 in
   if ((string_startswith s4580 (''pmpaddr15''))) then  
  (case  ((string_drop s4580 ((string_length (''pmpaddr15''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4570  :: " string "


\<comment> \<open>\<open>val _s452_ : string -> maybe string\<close>\<close>

definition s452  :: " string \<Rightarrow>(string)option "  where 
     " s452 s4530 = (
   (let s4540 = s4530 in
   if ((string_startswith s4540 (''pmpaddr14''))) then  
  (case  ((string_drop s4540 ((string_length (''pmpaddr14''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4530  :: " string "


\<comment> \<open>\<open>val _s448_ : string -> maybe string\<close>\<close>

definition s448  :: " string \<Rightarrow>(string)option "  where 
     " s448 s4490 = (
   (let s4500 = s4490 in
   if ((string_startswith s4500 (''pmpaddr13''))) then  
  (case  ((string_drop s4500 ((string_length (''pmpaddr13''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4490  :: " string "


\<comment> \<open>\<open>val _s444_ : string -> maybe string\<close>\<close>

definition s444  :: " string \<Rightarrow>(string)option "  where 
     " s444 s4450 = (
   (let s4460 = s4450 in
   if ((string_startswith s4460 (''pmpaddr12''))) then  
  (case  ((string_drop s4460 ((string_length (''pmpaddr12''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4450  :: " string "


\<comment> \<open>\<open>val _s440_ : string -> maybe string\<close>\<close>

definition s440  :: " string \<Rightarrow>(string)option "  where 
     " s440 s4410 = (
   (let s4420 = s4410 in
   if ((string_startswith s4420 (''pmpaddr11''))) then  
  (case  ((string_drop s4420 ((string_length (''pmpaddr11''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4410  :: " string "


\<comment> \<open>\<open>val _s436_ : string -> maybe string\<close>\<close>

definition s436  :: " string \<Rightarrow>(string)option "  where 
     " s436 s4370 = (
   (let s4380 = s4370 in
   if ((string_startswith s4380 (''pmpaddr10''))) then  
  (case  ((string_drop s4380 ((string_length (''pmpaddr10''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4370  :: " string "


\<comment> \<open>\<open>val _s432_ : string -> maybe string\<close>\<close>

definition s432  :: " string \<Rightarrow>(string)option "  where 
     " s432 s4330 = (
   (let s4340 = s4330 in
   if ((string_startswith s4340 (''pmpaddr9''))) then  
  (case  ((string_drop s4340 ((string_length (''pmpaddr9''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4330  :: " string "


\<comment> \<open>\<open>val _s428_ : string -> maybe string\<close>\<close>

definition s428  :: " string \<Rightarrow>(string)option "  where 
     " s428 s4290 = (
   (let s4300 = s4290 in
   if ((string_startswith s4300 (''pmpaddr8''))) then  
  (case  ((string_drop s4300 ((string_length (''pmpaddr8''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4290  :: " string "


\<comment> \<open>\<open>val _s424_ : string -> maybe string\<close>\<close>

definition s424  :: " string \<Rightarrow>(string)option "  where 
     " s424 s4250 = (
   (let s4260 = s4250 in
   if ((string_startswith s4260 (''pmpaddr7''))) then  
  (case  ((string_drop s4260 ((string_length (''pmpaddr7''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4250  :: " string "


\<comment> \<open>\<open>val _s420_ : string -> maybe string\<close>\<close>

definition s420  :: " string \<Rightarrow>(string)option "  where 
     " s420 s4210 = (
   (let s4220 = s4210 in
   if ((string_startswith s4220 (''pmpaddr6''))) then  
  (case  ((string_drop s4220 ((string_length (''pmpaddr6''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4210  :: " string "


\<comment> \<open>\<open>val _s416_ : string -> maybe string\<close>\<close>

definition s416  :: " string \<Rightarrow>(string)option "  where 
     " s416 s4170 = (
   (let s4180 = s4170 in
   if ((string_startswith s4180 (''pmpaddr5''))) then  
  (case  ((string_drop s4180 ((string_length (''pmpaddr5''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4170  :: " string "


\<comment> \<open>\<open>val _s412_ : string -> maybe string\<close>\<close>

definition s412  :: " string \<Rightarrow>(string)option "  where 
     " s412 s4130 = (
   (let s4140 = s4130 in
   if ((string_startswith s4140 (''pmpaddr4''))) then  
  (case  ((string_drop s4140 ((string_length (''pmpaddr4''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4130  :: " string "


\<comment> \<open>\<open>val _s408_ : string -> maybe string\<close>\<close>

definition s408  :: " string \<Rightarrow>(string)option "  where 
     " s408 s4090 = (
   (let s4100 = s4090 in
   if ((string_startswith s4100 (''pmpaddr3''))) then  
  (case  ((string_drop s4100 ((string_length (''pmpaddr3''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4090  :: " string "


\<comment> \<open>\<open>val _s404_ : string -> maybe string\<close>\<close>

definition s404  :: " string \<Rightarrow>(string)option "  where 
     " s404 s4050 = (
   (let s4060 = s4050 in
   if ((string_startswith s4060 (''pmpaddr2''))) then  
  (case  ((string_drop s4060 ((string_length (''pmpaddr2''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4050  :: " string "


\<comment> \<open>\<open>val _s400_ : string -> maybe string\<close>\<close>

definition s400  :: " string \<Rightarrow>(string)option "  where 
     " s400 s4010 = (
   (let s4020 = s4010 in
   if ((string_startswith s4020 (''pmpaddr1''))) then  
  (case  ((string_drop s4020 ((string_length (''pmpaddr1''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4010  :: " string "


\<comment> \<open>\<open>val _s396_ : string -> maybe string\<close>\<close>

definition s396  :: " string \<Rightarrow>(string)option "  where 
     " s396 s3970 = (
   (let s3980 = s3970 in
   if ((string_startswith s3980 (''pmpaddr0''))) then  
  (case  ((string_drop s3980 ((string_length (''pmpaddr0''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3970  :: " string "


\<comment> \<open>\<open>val _s392_ : string -> maybe string\<close>\<close>

definition s392  :: " string \<Rightarrow>(string)option "  where 
     " s392 s3930 = (
   (let s3940 = s3930 in
   if ((string_startswith s3940 (''pmpcfg3''))) then  
  (case  ((string_drop s3940 ((string_length (''pmpcfg3''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3930  :: " string "


\<comment> \<open>\<open>val _s388_ : string -> maybe string\<close>\<close>

definition s388  :: " string \<Rightarrow>(string)option "  where 
     " s388 s3890 = (
   (let s3900 = s3890 in
   if ((string_startswith s3900 (''pmpcfg2''))) then  
  (case  ((string_drop s3900 ((string_length (''pmpcfg2''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3890  :: " string "


\<comment> \<open>\<open>val _s384_ : string -> maybe string\<close>\<close>

definition s384  :: " string \<Rightarrow>(string)option "  where 
     " s384 s3850 = (
   (let s3860 = s3850 in
   if ((string_startswith s3860 (''pmpcfg1''))) then  
  (case  ((string_drop s3860 ((string_length (''pmpcfg1''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3850  :: " string "


\<comment> \<open>\<open>val _s380_ : string -> maybe string\<close>\<close>

definition s380  :: " string \<Rightarrow>(string)option "  where 
     " s380 s3810 = (
   (let s3820 = s3810 in
   if ((string_startswith s3820 (''pmpcfg0''))) then  
  (case  ((string_drop s3820 ((string_length (''pmpcfg0''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3810  :: " string "


\<comment> \<open>\<open>val _s376_ : string -> maybe string\<close>\<close>

definition s376  :: " string \<Rightarrow>(string)option "  where 
     " s376 s3770 = (
   (let s3780 = s3770 in
   if ((string_startswith s3780 (''mip''))) then  
  (case  ((string_drop s3780 ((string_length (''mip''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3770  :: " string "


\<comment> \<open>\<open>val _s372_ : string -> maybe string\<close>\<close>

definition s372  :: " string \<Rightarrow>(string)option "  where 
     " s372 s3730 = (
   (let s3740 = s3730 in
   if ((string_startswith s3740 (''mtval''))) then  
  (case  ((string_drop s3740 ((string_length (''mtval''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3730  :: " string "


\<comment> \<open>\<open>val _s368_ : string -> maybe string\<close>\<close>

definition s368  :: " string \<Rightarrow>(string)option "  where 
     " s368 s3690 = (
   (let s3700 = s3690 in
   if ((string_startswith s3700 (''mcause''))) then  
  (case  ((string_drop s3700 ((string_length (''mcause''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3690  :: " string "


\<comment> \<open>\<open>val _s364_ : string -> maybe string\<close>\<close>

definition s364  :: " string \<Rightarrow>(string)option "  where 
     " s364 s3650 = (
   (let s3660 = s3650 in
   if ((string_startswith s3660 (''mepc''))) then  
  (case  ((string_drop s3660 ((string_length (''mepc''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3650  :: " string "


\<comment> \<open>\<open>val _s360_ : string -> maybe string\<close>\<close>

definition s360  :: " string \<Rightarrow>(string)option "  where 
     " s360 s3610 = (
   (let s3620 = s3610 in
   if ((string_startswith s3620 (''mscratch''))) then  
  (case  ((string_drop s3620 ((string_length (''mscratch''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3610  :: " string "


\<comment> \<open>\<open>val _s356_ : string -> maybe string\<close>\<close>

definition s356  :: " string \<Rightarrow>(string)option "  where 
     " s356 s3570 = (
   (let s3580 = s3570 in
   if ((string_startswith s3580 (''mcounteren''))) then  
  (case  ((string_drop s3580 ((string_length (''mcounteren''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3570  :: " string "


\<comment> \<open>\<open>val _s352_ : string -> maybe string\<close>\<close>

definition s352  :: " string \<Rightarrow>(string)option "  where 
     " s352 s3530 = (
   (let s3540 = s3530 in
   if ((string_startswith s3540 (''mtvec''))) then  
  (case  ((string_drop s3540 ((string_length (''mtvec''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3530  :: " string "


\<comment> \<open>\<open>val _s348_ : string -> maybe string\<close>\<close>

definition s348  :: " string \<Rightarrow>(string)option "  where 
     " s348 s3490 = (
   (let s3500 = s3490 in
   if ((string_startswith s3500 (''mie''))) then  
  (case  ((string_drop s3500 ((string_length (''mie''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3490  :: " string "


\<comment> \<open>\<open>val _s344_ : string -> maybe string\<close>\<close>

definition s344  :: " string \<Rightarrow>(string)option "  where 
     " s344 s3450 = (
   (let s3460 = s3450 in
   if ((string_startswith s3460 (''mideleg''))) then  
  (case  ((string_drop s3460 ((string_length (''mideleg''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3450  :: " string "


\<comment> \<open>\<open>val _s340_ : string -> maybe string\<close>\<close>

definition s340  :: " string \<Rightarrow>(string)option "  where 
     " s340 s3411 = (
   (let s3420 = s3411 in
   if ((string_startswith s3420 (''medeleg''))) then  
  (case  ((string_drop s3420 ((string_length (''medeleg''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3411  :: " string "


\<comment> \<open>\<open>val _s336_ : string -> maybe string\<close>\<close>

definition s336  :: " string \<Rightarrow>(string)option "  where 
     " s336 s3370 = (
   (let s3380 = s3370 in
   if ((string_startswith s3380 (''misa''))) then  
  (case  ((string_drop s3380 ((string_length (''misa''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3370  :: " string "


\<comment> \<open>\<open>val _s332_ : string -> maybe string\<close>\<close>

definition s332  :: " string \<Rightarrow>(string)option "  where 
     " s332 s3330 = (
   (let s3340 = s3330 in
   if ((string_startswith s3340 (''mstatus''))) then  
  (case  ((string_drop s3340 ((string_length (''mstatus''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3330  :: " string "


\<comment> \<open>\<open>val _s328_ : string -> maybe string\<close>\<close>

definition s328  :: " string \<Rightarrow>(string)option "  where 
     " s328 s3290 = (
   (let s3300 = s3290 in
   if ((string_startswith s3300 (''mhartid''))) then  
  (case  ((string_drop s3300 ((string_length (''mhartid''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3290  :: " string "


\<comment> \<open>\<open>val _s324_ : string -> maybe string\<close>\<close>

definition s324  :: " string \<Rightarrow>(string)option "  where 
     " s324 s3250 = (
   (let s3260 = s3250 in
   if ((string_startswith s3260 (''mimpid''))) then  
  (case  ((string_drop s3260 ((string_length (''mimpid''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3250  :: " string "


\<comment> \<open>\<open>val _s320_ : string -> maybe string\<close>\<close>

definition s320  :: " string \<Rightarrow>(string)option "  where 
     " s320 s3210 = (
   (let s3220 = s3210 in
   if ((string_startswith s3220 (''marchid''))) then  
  (case  ((string_drop s3220 ((string_length (''marchid''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3210  :: " string "


\<comment> \<open>\<open>val _s316_ : string -> maybe string\<close>\<close>

definition s316  :: " string \<Rightarrow>(string)option "  where 
     " s316 s3170 = (
   (let s3180 = s3170 in
   if ((string_startswith s3180 (''mvendorid''))) then  
  (case  ((string_drop s3180 ((string_length (''mvendorid''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3170  :: " string "


\<comment> \<open>\<open>val _s312_ : string -> maybe string\<close>\<close>

definition s312  :: " string \<Rightarrow>(string)option "  where 
     " s312 s3130 = (
   (let s3140 = s3130 in
   if ((string_startswith s3140 (''satp''))) then  
  (case  ((string_drop s3140 ((string_length (''satp''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3130  :: " string "


\<comment> \<open>\<open>val _s308_ : string -> maybe string\<close>\<close>

definition s308  :: " string \<Rightarrow>(string)option "  where 
     " s308 s3090 = (
   (let s3100 = s3090 in
   if ((string_startswith s3100 (''sip''))) then  
  (case  ((string_drop s3100 ((string_length (''sip''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3090  :: " string "


\<comment> \<open>\<open>val _s304_ : string -> maybe string\<close>\<close>

definition s304  :: " string \<Rightarrow>(string)option "  where 
     " s304 s3050 = (
   (let s3060 = s3050 in
   if ((string_startswith s3060 (''stval''))) then  
  (case  ((string_drop s3060 ((string_length (''stval''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3050  :: " string "


\<comment> \<open>\<open>val _s300_ : string -> maybe string\<close>\<close>

definition s300  :: " string \<Rightarrow>(string)option "  where 
     " s300 s3010 = (
   (let s3020 = s3010 in
   if ((string_startswith s3020 (''scause''))) then  
  (case  ((string_drop s3020 ((string_length (''scause''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s3010  :: " string "


\<comment> \<open>\<open>val _s296_ : string -> maybe string\<close>\<close>

definition s296  :: " string \<Rightarrow>(string)option "  where 
     " s296 s2970 = (
   (let s2980 = s2970 in
   if ((string_startswith s2980 (''sepc''))) then  
  (case  ((string_drop s2980 ((string_length (''sepc''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2970  :: " string "


\<comment> \<open>\<open>val _s292_ : string -> maybe string\<close>\<close>

definition s292  :: " string \<Rightarrow>(string)option "  where 
     " s292 s2930 = (
   (let s2940 = s2930 in
   if ((string_startswith s2940 (''sscratch''))) then  
  (case  ((string_drop s2940 ((string_length (''sscratch''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2930  :: " string "


\<comment> \<open>\<open>val _s288_ : string -> maybe string\<close>\<close>

definition s288  :: " string \<Rightarrow>(string)option "  where 
     " s288 s2890 = (
   (let s2900 = s2890 in
   if ((string_startswith s2900 (''scounteren''))) then  
  (case  ((string_drop s2900 ((string_length (''scounteren''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2890  :: " string "


\<comment> \<open>\<open>val _s284_ : string -> maybe string\<close>\<close>

definition s284  :: " string \<Rightarrow>(string)option "  where 
     " s284 s2850 = (
   (let s2860 = s2850 in
   if ((string_startswith s2860 (''stvec''))) then  
  (case  ((string_drop s2860 ((string_length (''stvec''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2850  :: " string "


\<comment> \<open>\<open>val _s280_ : string -> maybe string\<close>\<close>

definition s280  :: " string \<Rightarrow>(string)option "  where 
     " s280 s2810 = (
   (let s2820 = s2810 in
   if ((string_startswith s2820 (''sie''))) then  
  (case  ((string_drop s2820 ((string_length (''sie''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2810  :: " string "


\<comment> \<open>\<open>val _s276_ : string -> maybe string\<close>\<close>

definition s276  :: " string \<Rightarrow>(string)option "  where 
     " s276 s2770 = (
   (let s2780 = s2770 in
   if ((string_startswith s2780 (''sideleg''))) then  
  (case  ((string_drop s2780 ((string_length (''sideleg''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2770  :: " string "


\<comment> \<open>\<open>val _s272_ : string -> maybe string\<close>\<close>

definition s272  :: " string \<Rightarrow>(string)option "  where 
     " s272 s2730 = (
   (let s2741 = s2730 in
   if ((string_startswith s2741 (''sedeleg''))) then  
  (case  ((string_drop s2741 ((string_length (''sedeleg''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2730  :: " string "


\<comment> \<open>\<open>val _s268_ : string -> maybe string\<close>\<close>

definition s268  :: " string \<Rightarrow>(string)option "  where 
     " s268 s2690 = (
   (let s2700 = s2690 in
   if ((string_startswith s2700 (''sstatus''))) then  
  (case  ((string_drop s2700 ((string_length (''sstatus''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2690  :: " string "


\<comment> \<open>\<open>val _s264_ : string -> maybe string\<close>\<close>

definition s264  :: " string \<Rightarrow>(string)option "  where 
     " s264 s2650 = (
   (let s2660 = s2650 in
   if ((string_startswith s2660 (''instreth''))) then  
  (case  ((string_drop s2660 ((string_length (''instreth''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2650  :: " string "


\<comment> \<open>\<open>val _s260_ : string -> maybe string\<close>\<close>

definition s260  :: " string \<Rightarrow>(string)option "  where 
     " s260 s2610 = (
   (let s2620 = s2610 in
   if ((string_startswith s2620 (''timeh''))) then  
  (case  ((string_drop s2620 ((string_length (''timeh''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2610  :: " string "


\<comment> \<open>\<open>val _s256_ : string -> maybe string\<close>\<close>

definition s256  :: " string \<Rightarrow>(string)option "  where 
     " s256 s2571 = (
   (let s2580 = s2571 in
   if ((string_startswith s2580 (''cycleh''))) then  
  (case  ((string_drop s2580 ((string_length (''cycleh''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2571  :: " string "


\<comment> \<open>\<open>val _s252_ : string -> maybe string\<close>\<close>

definition s252  :: " string \<Rightarrow>(string)option "  where 
     " s252 s2530 = (
   (let s2540 = s2530 in
   if ((string_startswith s2540 (''instret''))) then  
  (case  ((string_drop s2540 ((string_length (''instret''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2530  :: " string "


\<comment> \<open>\<open>val _s248_ : string -> maybe string\<close>\<close>

definition s248  :: " string \<Rightarrow>(string)option "  where 
     " s248 s2490 = (
   (let s2500 = s2490 in
   if ((string_startswith s2500 (''time''))) then  
  (case  ((string_drop s2500 ((string_length (''time''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2490  :: " string "


\<comment> \<open>\<open>val _s244_ : string -> maybe string\<close>\<close>

definition s244  :: " string \<Rightarrow>(string)option "  where 
     " s244 s2450 = (
   (let s2460 = s2450 in
   if ((string_startswith s2460 (''cycle''))) then  
  (case  ((string_drop s2460 ((string_length (''cycle''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2450  :: " string "


\<comment> \<open>\<open>val _s240_ : string -> maybe string\<close>\<close>

definition s240  :: " string \<Rightarrow>(string)option "  where 
     " s240 s2410 = (
   (let s2420 = s2410 in
   if ((string_startswith s2420 (''fcsr''))) then  
  (case  ((string_drop s2420 ((string_length (''fcsr''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2410  :: " string "


\<comment> \<open>\<open>val _s236_ : string -> maybe string\<close>\<close>

definition s236  :: " string \<Rightarrow>(string)option "  where 
     " s236 s2370 = (
   (let s2380 = s2370 in
   if ((string_startswith s2380 (''frm''))) then  
  (case  ((string_drop s2380 ((string_length (''frm''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2370  :: " string "


\<comment> \<open>\<open>val _s232_ : string -> maybe string\<close>\<close>

definition s232  :: " string \<Rightarrow>(string)option "  where 
     " s232 s2330 = (
   (let s2340 = s2330 in
   if ((string_startswith s2340 (''fflags''))) then  
  (case  ((string_drop s2340 ((string_length (''fflags''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2330  :: " string "


\<comment> \<open>\<open>val _s228_ : string -> maybe string\<close>\<close>

definition s228  :: " string \<Rightarrow>(string)option "  where 
     " s228 s2290 = (
   (let s2300 = s2290 in
   if ((string_startswith s2300 (''uip''))) then  
  (case  ((string_drop s2300 ((string_length (''uip''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2290  :: " string "


\<comment> \<open>\<open>val _s224_ : string -> maybe string\<close>\<close>

definition s224  :: " string \<Rightarrow>(string)option "  where 
     " s224 s2250 = (
   (let s2260 = s2250 in
   if ((string_startswith s2260 (''utval''))) then  
  (case  ((string_drop s2260 ((string_length (''utval''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2250  :: " string "


\<comment> \<open>\<open>val _s220_ : string -> maybe string\<close>\<close>

definition s220  :: " string \<Rightarrow>(string)option "  where 
     " s220 s2210 = (
   (let s2220 = s2210 in
   if ((string_startswith s2220 (''ucause''))) then  
  (case  ((string_drop s2220 ((string_length (''ucause''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2210  :: " string "


\<comment> \<open>\<open>val _s216_ : string -> maybe string\<close>\<close>

definition s216  :: " string \<Rightarrow>(string)option "  where 
     " s216 s2170 = (
   (let s2180 = s2170 in
   if ((string_startswith s2180 (''uepc''))) then  
  (case  ((string_drop s2180 ((string_length (''uepc''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2170  :: " string "


\<comment> \<open>\<open>val _s212_ : string -> maybe string\<close>\<close>

definition s212  :: " string \<Rightarrow>(string)option "  where 
     " s212 s2130 = (
   (let s2140 = s2130 in
   if ((string_startswith s2140 (''uscratch''))) then  
  (case  ((string_drop s2140 ((string_length (''uscratch''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2130  :: " string "


\<comment> \<open>\<open>val _s208_ : string -> maybe string\<close>\<close>

definition s208  :: " string \<Rightarrow>(string)option "  where 
     " s208 s2090 = (
   (let s2100 = s2090 in
   if ((string_startswith s2100 (''utvec''))) then  
  (case  ((string_drop s2100 ((string_length (''utvec''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2090  :: " string "


\<comment> \<open>\<open>val _s204_ : string -> maybe string\<close>\<close>

definition s204  :: " string \<Rightarrow>(string)option "  where 
     " s204 s2050 = (
   (let s2060 = s2050 in
   if ((string_startswith s2060 (''uie''))) then  
  (case  ((string_drop s2060 ((string_length (''uie''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2050  :: " string "


\<comment> \<open>\<open>val _s200_ : string -> maybe string\<close>\<close>

definition s200  :: " string \<Rightarrow>(string)option "  where 
     " s200 s2010 = (
   (let s2020 = s2010 in
   if ((string_startswith s2020 (''ustatus''))) then  
  (case  ((string_drop s2020 ((string_length (''ustatus''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s2010  :: " string "


definition csr_name_map_matches_prefix  :: " string \<Rightarrow>((12)Word.word*int)option "  where 
     " csr_name_map_matches_prefix arg1 = (
   (let s2030 = arg1 in
   if ((case  ((s200 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s200 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s204 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s204 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s208 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s208 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s212 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s212 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s216 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s216 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s220 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s220 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s224 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s224 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s228 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s228 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B1,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s232 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s232 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s236 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s236 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s240 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s240 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s244 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s244 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s248 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s248 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s252 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s252 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s256 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s256 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s260 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s260 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s264 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s264 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s268 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s268 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s272 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s272 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s276 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s276 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s280 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s280 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s284 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s284 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s288 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s288 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s292 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s292 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s296 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s296 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s300 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s300 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s304 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s304 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s308 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s308 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s312 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s312 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s316 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s316 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s320 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s320 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s324 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s324 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s328 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s328 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B1,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s332 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s332 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s336 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s336 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s340 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s340 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s344 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s344 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s348 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s348 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s352 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s352 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s356 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s356 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s360 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s360 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s364 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s364 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s368 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s368 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s372 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s372 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s376 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s376 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s380 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s380 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s384 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s384 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s388 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s388 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s392 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s392 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s396 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s396 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s400 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s400 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s404 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s404 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s408 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s408 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s412 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s412 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s416 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s416 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s420 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s420 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s424 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s424 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s428 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s428 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s432 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s432 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s436 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s436 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s440 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s440 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s444 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s444 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s448 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s448 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s452 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s452 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s456 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s456 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s460 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s460 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s464 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s464 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s468 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s468 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s472 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s472 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s476 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s476 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s480 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s480 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s484 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s484 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B1,B0] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s488 s2030)) of   Some (s1) => True | _ => False )) then  
  (case  s488 s2030 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B1,B1] :: 12 Word.word),
    ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val Mk_Ustatus : mword ty32 -> Ustatus\<close>\<close>

definition Mk_Ustatus  :: "(32)Word.word \<Rightarrow> Ustatus "  where 
     " Mk_Ustatus v = (
   (| Ustatus_Ustatus_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Ustatus_bits : Ustatus -> mword ty32\<close>\<close>

definition get_Ustatus_bits  :: " Ustatus \<Rightarrow>(32)Word.word "  where 
     " get_Ustatus_bits v = ( (subrange_vec_dec(Ustatus_Ustatus_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Ustatus "


\<comment> \<open>\<open>val _set_Ustatus_bits : register_ref regstate register_value Ustatus -> mword ty32 -> M unit\<close>\<close>

definition set_Ustatus_bits  :: "((regstate),(register_value),(Ustatus))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Ustatus_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Ustatus_Ustatus_chunk_0 :=
         ((update_subrange_vec_dec(Ustatus_Ustatus_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Ustatus))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Ustatus_bits : Ustatus -> mword ty32 -> Ustatus\<close>\<close>

definition update_Ustatus_bits  :: " Ustatus \<Rightarrow>(32)Word.word \<Rightarrow> Ustatus "  where 
     " update_Ustatus_bits v x = (
   (v (|
     Ustatus_Ustatus_chunk_0 :=
       ((update_subrange_vec_dec(Ustatus_Ustatus_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Ustatus " 
  and  x  :: "(32)Word.word "


definition get_Ustatus_UPIE  :: " Ustatus \<Rightarrow>(1)Word.word "  where 
     " get_Ustatus_UPIE v = ( (subrange_vec_dec(Ustatus_Ustatus_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Ustatus "


definition set_Ustatus_UPIE  :: "((regstate),(register_value),(Ustatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Ustatus_UPIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Ustatus_Ustatus_chunk_0 :=
         ((update_subrange_vec_dec(Ustatus_Ustatus_chunk_0   r) (( 4 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Ustatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Ustatus_UPIE  :: " Ustatus \<Rightarrow>(1)Word.word \<Rightarrow> Ustatus "  where 
     " update_Ustatus_UPIE v x = (
   (v (|
     Ustatus_Ustatus_chunk_0 :=
       ((update_subrange_vec_dec(Ustatus_Ustatus_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Ustatus " 
  and  x  :: "(1)Word.word "


definition get_Ustatus_UIE  :: " Ustatus \<Rightarrow>(1)Word.word "  where 
     " get_Ustatus_UIE v = ( (subrange_vec_dec(Ustatus_Ustatus_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Ustatus "


definition set_Ustatus_UIE  :: "((regstate),(register_value),(Ustatus))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Ustatus_UIE r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Ustatus_Ustatus_chunk_0 :=
         ((update_subrange_vec_dec(Ustatus_Ustatus_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Ustatus))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Ustatus_UIE  :: " Ustatus \<Rightarrow>(1)Word.word \<Rightarrow> Ustatus "  where 
     " update_Ustatus_UIE v x = (
   (v (|
     Ustatus_Ustatus_chunk_0 :=
       ((update_subrange_vec_dec(Ustatus_Ustatus_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Ustatus " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val lower_sstatus : Sstatus -> Ustatus\<close>\<close>

definition lower_sstatus  :: " Sstatus \<Rightarrow> Ustatus "  where 
     " lower_sstatus s = (
   (let u = (Mk_Ustatus ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) in
   (let u = (update_Ustatus_UPIE u ((get_Sstatus_UPIE s  ::  1 Word.word))) in
   update_Ustatus_UIE u ((get_Sstatus_UIE s  ::  1 Word.word)))))" 
  for  s  :: " Sstatus "


\<comment> \<open>\<open>val lift_ustatus : Sstatus -> Ustatus -> Sstatus\<close>\<close>

definition lift_ustatus  :: " Sstatus \<Rightarrow> Ustatus \<Rightarrow> Sstatus "  where 
     " lift_ustatus (s :: Sstatus) (u :: Ustatus) = (
   (let s = (update_Sstatus_UPIE s ((get_Ustatus_UPIE u  ::  1 Word.word))) in
   update_Sstatus_UIE s ((get_Ustatus_UIE u  ::  1 Word.word))))" 
  for  s  :: " Sstatus " 
  and  u  :: " Ustatus "


\<comment> \<open>\<open>val legalize_ustatus : Mstatus -> mword ty32 -> M Mstatus\<close>\<close>

definition legalize_ustatus  :: " Mstatus \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(Mstatus),(exception))monad "  where 
     " legalize_ustatus (m :: Mstatus) (v :: xlenbits) = (
   (let u = (Mk_Ustatus v) in
   (let s = (lower_mstatus m) in
   (let s = (lift_ustatus s u) in
   lift_sstatus m s))))" 
  for  m  :: " Mstatus " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val Mk_Uinterrupts : mword ty32 -> Uinterrupts\<close>\<close>

definition Mk_Uinterrupts  :: "(32)Word.word \<Rightarrow> Uinterrupts "  where 
     " Mk_Uinterrupts v = (
   (| Uinterrupts_Uinterrupts_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_Uinterrupts_bits : Uinterrupts -> mword ty32\<close>\<close>

definition get_Uinterrupts_bits  :: " Uinterrupts \<Rightarrow>(32)Word.word "  where 
     " get_Uinterrupts_bits v = (
   (subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " Uinterrupts "


\<comment> \<open>\<open>val _set_Uinterrupts_bits : register_ref regstate register_value Uinterrupts -> mword ty32 -> M unit\<close>\<close>

definition set_Uinterrupts_bits  :: "((regstate),(register_value),(Uinterrupts))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Uinterrupts_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Uinterrupts_Uinterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Uinterrupts))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_Uinterrupts_bits : Uinterrupts -> mword ty32 -> Uinterrupts\<close>\<close>

definition update_Uinterrupts_bits  :: " Uinterrupts \<Rightarrow>(32)Word.word \<Rightarrow> Uinterrupts "  where 
     " update_Uinterrupts_bits v x = (
   (v (|
     Uinterrupts_Uinterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Uinterrupts " 
  and  x  :: "(32)Word.word "


definition get_Uinterrupts_UEI  :: " Uinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Uinterrupts_UEI v = (
   (subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Uinterrupts "


definition set_Uinterrupts_UEI  :: "((regstate),(register_value),(Uinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Uinterrupts_UEI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Uinterrupts_Uinterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   r) (( 8 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Uinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Uinterrupts_UEI  :: " Uinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Uinterrupts "  where 
     " update_Uinterrupts_UEI v x = (
   (v (|
     Uinterrupts_Uinterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   v) (( 8 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Uinterrupts " 
  and  x  :: "(1)Word.word "


definition get_Uinterrupts_UTI  :: " Uinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Uinterrupts_UTI v = (
   (subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Uinterrupts "


definition set_Uinterrupts_UTI  :: "((regstate),(register_value),(Uinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Uinterrupts_UTI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Uinterrupts_Uinterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   r) (( 4 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Uinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Uinterrupts_UTI  :: " Uinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Uinterrupts "  where 
     " update_Uinterrupts_UTI v x = (
   (v (|
     Uinterrupts_Uinterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Uinterrupts " 
  and  x  :: "(1)Word.word "


definition get_Uinterrupts_USI  :: " Uinterrupts \<Rightarrow>(1)Word.word "  where 
     " get_Uinterrupts_USI v = (
   (subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " Uinterrupts "


definition set_Uinterrupts_USI  :: "((regstate),(register_value),(Uinterrupts))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_Uinterrupts_USI r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       Uinterrupts_Uinterrupts_chunk_0 :=
         ((update_subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(Uinterrupts))register_ref " 
  and  v  :: "(1)Word.word "


definition update_Uinterrupts_USI  :: " Uinterrupts \<Rightarrow>(1)Word.word \<Rightarrow> Uinterrupts "  where 
     " update_Uinterrupts_USI v x = (
   (v (|
     Uinterrupts_Uinterrupts_chunk_0 :=
       ((update_subrange_vec_dec(Uinterrupts_Uinterrupts_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " Uinterrupts " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val lower_sip : Sinterrupts -> Sinterrupts -> Uinterrupts\<close>\<close>

definition lower_sip  :: " Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow> Uinterrupts "  where 
     " lower_sip (s :: Sinterrupts) (d :: Sinterrupts) = (
   (let (u :: Uinterrupts) =
     (Mk_Uinterrupts ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) in
   (let u =
     (update_Uinterrupts_UEI u
       ((and_vec ((get_Sinterrupts_UEI s  ::  1 Word.word)) ((get_Sinterrupts_UEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let u =
     (update_Uinterrupts_UTI u
       ((and_vec ((get_Sinterrupts_UTI s  ::  1 Word.word)) ((get_Sinterrupts_UTI d  ::  1 Word.word))
          ::  1 Word.word))) in
   update_Uinterrupts_USI u
     ((and_vec ((get_Sinterrupts_USI s  ::  1 Word.word)) ((get_Sinterrupts_USI d  ::  1 Word.word))
        ::  1 Word.word))))))" 
  for  s  :: " Sinterrupts " 
  and  d  :: " Sinterrupts "


\<comment> \<open>\<open>val lower_sie : Sinterrupts -> Sinterrupts -> Uinterrupts\<close>\<close>

definition lower_sie  :: " Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow> Uinterrupts "  where 
     " lower_sie (s :: Sinterrupts) (d :: Sinterrupts) = (
   (let (u :: Uinterrupts) =
     (Mk_Uinterrupts ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) in
   (let u =
     (update_Uinterrupts_UEI u
       ((and_vec ((get_Sinterrupts_UEI s  ::  1 Word.word)) ((get_Sinterrupts_UEI d  ::  1 Word.word))
          ::  1 Word.word))) in
   (let u =
     (update_Uinterrupts_UTI u
       ((and_vec ((get_Sinterrupts_UTI s  ::  1 Word.word)) ((get_Sinterrupts_UTI d  ::  1 Word.word))
          ::  1 Word.word))) in
   update_Uinterrupts_USI u
     ((and_vec ((get_Sinterrupts_USI s  ::  1 Word.word)) ((get_Sinterrupts_USI d  ::  1 Word.word))
        ::  1 Word.word))))))" 
  for  s  :: " Sinterrupts " 
  and  d  :: " Sinterrupts "


\<comment> \<open>\<open>val lift_uip : Sinterrupts -> Sinterrupts -> Uinterrupts -> Sinterrupts\<close>\<close>

definition lift_uip  :: " Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow> Uinterrupts \<Rightarrow> Sinterrupts "  where 
     " lift_uip (o1 :: Sinterrupts) (d :: Sinterrupts) (u :: Uinterrupts) = (
   (let (s :: Sinterrupts) = o1 in
   if (((((get_Sinterrupts_USI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
     update_Sinterrupts_USI s ((get_Uinterrupts_USI u  ::  1 Word.word))
   else s))" 
  for  o1  :: " Sinterrupts " 
  and  d  :: " Sinterrupts " 
  and  u  :: " Uinterrupts "


\<comment> \<open>\<open>val legalize_uip : Sinterrupts -> Sinterrupts -> mword ty32 -> Sinterrupts\<close>\<close>

definition legalize_uip  :: " Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow>(32)Word.word \<Rightarrow> Sinterrupts "  where 
     " legalize_uip (s :: Sinterrupts) (d :: Sinterrupts) (v :: xlenbits) = (
   lift_uip s d ((Mk_Uinterrupts v)))" 
  for  s  :: " Sinterrupts " 
  and  d  :: " Sinterrupts " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val lift_uie : Sinterrupts -> Sinterrupts -> Uinterrupts -> Sinterrupts\<close>\<close>

definition lift_uie  :: " Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow> Uinterrupts \<Rightarrow> Sinterrupts "  where 
     " lift_uie (o1 :: Sinterrupts) (d :: Sinterrupts) (u :: Uinterrupts) = (
   (let (s :: Sinterrupts) = o1 in
   (let s =
     (if (((((get_Sinterrupts_UEI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
       update_Sinterrupts_UEI s ((get_Uinterrupts_UEI u  ::  1 Word.word))
     else s) in
   (let s =
     (if (((((get_Sinterrupts_UTI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
       update_Sinterrupts_UTI s ((get_Uinterrupts_UTI u  ::  1 Word.word))
     else s) in
   if (((((get_Sinterrupts_USI d  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
     update_Sinterrupts_USI s ((get_Uinterrupts_USI u  ::  1 Word.word))
   else s))))" 
  for  o1  :: " Sinterrupts " 
  and  d  :: " Sinterrupts " 
  and  u  :: " Uinterrupts "


\<comment> \<open>\<open>val legalize_uie : Sinterrupts -> Sinterrupts -> mword ty32 -> Sinterrupts\<close>\<close>

definition legalize_uie  :: " Sinterrupts \<Rightarrow> Sinterrupts \<Rightarrow>(32)Word.word \<Rightarrow> Sinterrupts "  where 
     " legalize_uie (s :: Sinterrupts) (d :: Sinterrupts) (v :: xlenbits) = (
   lift_uie s d ((Mk_Uinterrupts v)))" 
  for  s  :: " Sinterrupts " 
  and  d  :: " Sinterrupts " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val handle_trap_extension : Privilege -> mword ty32 -> maybe unit -> unit\<close>\<close>

definition handle_trap_extension  :: " Privilege \<Rightarrow>(32)Word.word \<Rightarrow>(unit)option \<Rightarrow> unit "  where 
     " handle_trap_extension (p :: Privilege) (pc :: xlenbits) (u ::  unit option) = ( ()  )" 
  for  p  :: " Privilege " 
  and  pc  :: "(32)Word.word " 
  and  u  :: "(unit)option "


\<comment> \<open>\<open>val prepare_trap_vector : Privilege -> Mcause -> M (mword ty32)\<close>\<close>

definition prepare_trap_vector  :: " Privilege \<Rightarrow> Mcause \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " prepare_trap_vector (p :: Privilege) (cause :: Mcause) = (
   (case  p of
     Machine => read_reg mtvec_ref
   | Supervisor => read_reg stvec_ref
   | User => read_reg utvec_ref
   ) \<bind> (\<lambda> (tvec :: Mtvec) . 
   (case  ((tvec_addr tvec cause  ::  ( 32 Word.word)option)) of
     Some (epc) => return epc
   | None => (internal_error (''Invalid tvec mode'')  :: ( 32 Word.word) M)
   )))" 
  for  p  :: " Privilege " 
  and  cause  :: " Mcause "


\<comment> \<open>\<open>val get_xret_target : Privilege -> M (mword ty32)\<close>\<close>

fun get_xret_target  :: " Privilege \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " get_xret_target Machine = ( (read_reg mepc_ref  :: ( 32 Word.word) M))"
|" get_xret_target Supervisor = ( (read_reg sepc_ref  :: ( 32 Word.word) M))"
|" get_xret_target User = ( (read_reg uepc_ref  :: ( 32 Word.word) M))"


\<comment> \<open>\<open>val set_xret_target : Privilege -> mword ty32 -> M (mword ty32)\<close>\<close>

definition set_xret_target  :: " Privilege \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " set_xret_target p value1 = (
   (legalize_xepc value1  :: ( 32 Word.word) M) \<bind> (\<lambda> target . 
   (case  p of
     Machine => write_reg mepc_ref target
   | Supervisor => write_reg sepc_ref target
   | User => write_reg uepc_ref target
   ) \<then>
   return target))" 
  for  p  :: " Privilege " 
  and  value1  :: "(32)Word.word "


\<comment> \<open>\<open>val prepare_xret_target : Privilege -> M (mword ty32)\<close>\<close>

definition prepare_xret_target  :: " Privilege \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " prepare_xret_target p = ( (get_xret_target p  :: ( 32 Word.word) M))" 
  for  p  :: " Privilege "


\<comment> \<open>\<open>val get_mtvec : unit -> M (mword ty32)\<close>\<close>

definition get_mtvec  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " get_mtvec _ = (
   read_reg mtvec_ref \<bind> (\<lambda> (w__0 :: Mtvec) .  return ((get_Mtvec_bits w__0  ::  32 Word.word))))"


\<comment> \<open>\<open>val get_stvec : unit -> M (mword ty32)\<close>\<close>

definition get_stvec  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " get_stvec _ = (
   read_reg stvec_ref \<bind> (\<lambda> (w__0 :: Mtvec) .  return ((get_Mtvec_bits w__0  ::  32 Word.word))))"


\<comment> \<open>\<open>val get_utvec : unit -> M (mword ty32)\<close>\<close>

definition get_utvec  :: " unit \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " get_utvec _ = (
   read_reg utvec_ref \<bind> (\<lambda> (w__0 :: Mtvec) .  return ((get_Mtvec_bits w__0  ::  32 Word.word))))"


\<comment> \<open>\<open>val set_mtvec : mword ty32 -> M (mword ty32)\<close>\<close>

definition set_mtvec  :: "(32)Word.word \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " set_mtvec value1 = (
   read_reg mtvec_ref \<bind> (\<lambda> (w__0 :: Mtvec) . 
   (write_reg mtvec_ref ((legalize_tvec w__0 value1)) \<then>
   read_reg mtvec_ref) \<bind> (\<lambda> (w__1 :: Mtvec) .  return ((get_Mtvec_bits w__1  ::  32 Word.word)))))" 
  for  value1  :: "(32)Word.word "


\<comment> \<open>\<open>val set_stvec : mword ty32 -> M (mword ty32)\<close>\<close>

definition set_stvec  :: "(32)Word.word \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " set_stvec value1 = (
   read_reg stvec_ref \<bind> (\<lambda> (w__0 :: Mtvec) . 
   (write_reg stvec_ref ((legalize_tvec w__0 value1)) \<then>
   read_reg stvec_ref) \<bind> (\<lambda> (w__1 :: Mtvec) .  return ((get_Mtvec_bits w__1  ::  32 Word.word)))))" 
  for  value1  :: "(32)Word.word "


\<comment> \<open>\<open>val set_utvec : mword ty32 -> M (mword ty32)\<close>\<close>

definition set_utvec  :: "(32)Word.word \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " set_utvec value1 = (
   read_reg utvec_ref \<bind> (\<lambda> (w__0 :: Mtvec) . 
   (write_reg utvec_ref ((legalize_tvec w__0 value1)) \<then>
   read_reg utvec_ref) \<bind> (\<lambda> (w__1 :: Mtvec) .  return ((get_Mtvec_bits w__1  ::  32 Word.word)))))" 
  for  value1  :: "(32)Word.word "


\<comment> \<open>\<open>val is_NExt_CSR_defined : mword ty12 -> Privilege -> M bool\<close>\<close>

definition is_NExt_CSR_defined  :: "(12)Word.word \<Rightarrow> Privilege \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " is_NExt_CSR_defined (csr :: 12 bits) (p :: Privilege) = (
   (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     haveUsrMode () 
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     haveUsrMode () 
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     haveUsrMode () 
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     haveUsrMode () 
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     haveUsrMode () 
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     haveUsrMode () 
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     haveUsrMode () 
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     haveUsrMode () 
   else return False))" 
  for  csr  :: "(12)Word.word " 
  and  p  :: " Privilege "


\<comment> \<open>\<open>val read_NExt_CSR : mword ty12 -> M (maybe (mword ty32))\<close>\<close>

definition read_NExt_CSR  :: "(12)Word.word \<Rightarrow>((register_value),(((32)Word.word)option),(exception))monad "  where 
     " read_NExt_CSR csr = (
   (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     read_reg mstatus_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
     return (Some ((get_Ustatus_bits ((lower_sstatus ((lower_mstatus w__0))))  ::  32 Word.word))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     read_reg mie_ref \<bind> (\<lambda> (w__1 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> (\<lambda> (w__2 :: Minterrupts) . 
     read_reg sideleg_ref \<bind> (\<lambda> (w__3 :: Sinterrupts) . 
     return (Some ((get_Uinterrupts_bits ((lower_sie ((lower_mie w__1 w__2)) w__3))  ::  32 Word.word))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     (get_utvec ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 ::  32 Word.word) .  return (Some w__4))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     (read_reg uscratch_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__5 ::  32 Word.word) .  return (Some w__5))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     (get_xret_target User  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 ::  32 Word.word) . 
     (pc_alignment_mask ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 ::  32 Word.word) . 
     return (Some ((and_vec w__6 w__7  ::  32 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     read_reg ucause_ref \<bind> (\<lambda> (w__8 :: Mcause) . 
     return (Some ((get_Mcause_bits w__8  ::  32 Word.word))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     (read_reg utval_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 ::  32 Word.word) .  return (Some w__9))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     read_reg mip_ref \<bind> (\<lambda> (w__10 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> (\<lambda> (w__11 :: Minterrupts) . 
     read_reg sideleg_ref \<bind> (\<lambda> (w__12 :: Sinterrupts) . 
     return (Some ((get_Uinterrupts_bits ((lower_sip ((lower_mip w__10 w__11)) w__12))
                     ::  32 Word.word))))))
   else return None))" 
  for  csr  :: "(12)Word.word "


\<comment> \<open>\<open>val write_NExt_CSR : mword ty12 -> mword ty32 -> M bool\<close>\<close>

definition write_NExt_CSR  :: "(12)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " write_NExt_CSR (csr :: csreg) (value1 :: xlenbits) = (
   (let b__0 = csr in
   (if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
      read_reg mstatus_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
      legalize_ustatus w__0 value1 \<bind> (\<lambda> (w__1 :: Mstatus) . 
      (write_reg mstatus_ref w__1 \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__2 :: Mstatus) . 
      return (Some ((get_Mstatus_bits w__2  ::  32 Word.word))))))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
      read_reg mie_ref \<bind> (\<lambda> (w__3 :: Minterrupts) . 
      read_reg mideleg_ref \<bind> (\<lambda> (w__4 :: Minterrupts) . 
      read_reg sideleg_ref \<bind> (\<lambda> (w__5 :: Sinterrupts) . 
      (let sie = (legalize_uie ((lower_mie w__3 w__4)) w__5 value1) in
      read_reg mie_ref \<bind> (\<lambda> (w__6 :: Minterrupts) . 
      read_reg mideleg_ref \<bind> (\<lambda> (w__7 :: Minterrupts) . 
      lift_sie w__6 w__7 sie \<bind> (\<lambda> (w__8 :: Minterrupts) . 
      (write_reg mie_ref w__8 \<then>
      read_reg mie_ref) \<bind> (\<lambda> (w__9 :: Minterrupts) . 
      return (Some ((get_Minterrupts_bits w__9  ::  32 Word.word)))))))))))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
      (set_utvec value1  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 ::  32 Word.word) .  return (Some w__10))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
      (write_reg uscratch_ref value1 \<then>
      (read_reg uscratch_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__11 ::  32 Word.word) .  return (Some w__11))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
      (set_xret_target User value1  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 ::  32 Word.word) . 
      return (Some w__12))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
      (set_Mcause_bits ucause_ref value1 \<then>
      read_reg ucause_ref) \<bind> (\<lambda> (w__13 :: Mcause) . 
      return (Some ((get_Mcause_bits w__13  ::  32 Word.word))))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
      (write_reg utval_ref value1 \<then>
      (read_reg utval_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__14 ::  32 Word.word) .  return (Some w__14))
    else if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
      read_reg mip_ref \<bind> (\<lambda> (w__15 :: Minterrupts) . 
      read_reg mideleg_ref \<bind> (\<lambda> (w__16 :: Minterrupts) . 
      read_reg sideleg_ref \<bind> (\<lambda> (w__17 :: Sinterrupts) . 
      (let sip = (legalize_uip ((lower_mip w__15 w__16)) w__17 value1) in
      read_reg mip_ref \<bind> (\<lambda> (w__18 :: Minterrupts) . 
      read_reg mideleg_ref \<bind> (\<lambda> (w__19 :: Minterrupts) . 
      lift_sip w__18 w__19 sip \<bind> (\<lambda> (w__20 :: Minterrupts) . 
      (write_reg mip_ref w__20 \<then>
      read_reg mip_ref) \<bind> (\<lambda> (w__21 :: Minterrupts) . 
      return (Some ((get_Minterrupts_bits w__21  ::  32 Word.word)))))))))))
    else return None) \<bind> (\<lambda> (res ::  xlenbits option) . 
   return ((case  res of
     Some (v) =>
      (let (_ :: unit) =
        (if ((get_config_print_reg () )) then
          print_dbg
            (((@) (''CSR '')
                (((@) ((csr_name csr))
                    (((@) ('' <- '')
                        (((@) ((string_of_bits v))
                            (((@) ('' (input: '') (((@) ((string_of_bits value1)) ('')'')))))))))))))
        else () ) in
      True)
   | None => False
   )))))" 
  for  csr  :: "(12)Word.word " 
  and  value1  :: "(32)Word.word "


\<comment> \<open>\<open>val ext_is_CSR_defined : mword ty12 -> Privilege -> M bool\<close>\<close>

definition ext_is_CSR_defined  :: "(12)Word.word \<Rightarrow> Privilege \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " ext_is_CSR_defined (csr :: csreg) (p :: Privilege) = ( is_NExt_CSR_defined csr p )" 
  for  csr  :: "(12)Word.word " 
  and  p  :: " Privilege "


\<comment> \<open>\<open>val ext_read_CSR : mword ty12 -> M (maybe (mword ty32))\<close>\<close>

definition ext_read_CSR  :: "(12)Word.word \<Rightarrow>((register_value),(((32)Word.word)option),(exception))monad "  where 
     " ext_read_CSR csr = ( (read_NExt_CSR csr  :: ( ( 32 Word.word)option) M))" 
  for  csr  :: "(12)Word.word "


\<comment> \<open>\<open>val ext_write_CSR : mword ty12 -> mword ty32 -> M bool\<close>\<close>

definition ext_write_CSR  :: "(12)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " ext_write_CSR (csr :: csreg) (value1 :: xlenbits) = ( write_NExt_CSR csr value1 )" 
  for  csr  :: "(12)Word.word " 
  and  value1  :: "(32)Word.word "


\<comment> \<open>\<open>val csrAccess : mword ty12 -> mword ty2\<close>\<close>

definition csrAccess  :: "(12)Word.word \<Rightarrow>(2)Word.word "  where 
     " csrAccess csr = ( (subrange_vec_dec csr (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word))" 
  for  csr  :: "(12)Word.word "


\<comment> \<open>\<open>val csrPriv : mword ty12 -> mword ty2\<close>\<close>

definition csrPriv  :: "(12)Word.word \<Rightarrow>(2)Word.word "  where 
     " csrPriv csr = ( (subrange_vec_dec csr (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))" 
  for  csr  :: "(12)Word.word "


\<comment> \<open>\<open>val is_CSR_defined : mword ty12 -> Privilege -> M bool\<close>\<close>

definition is_CSR_defined  :: "(12)Word.word \<Rightarrow> Privilege \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " is_CSR_defined (csr :: csreg) (p :: Privilege) = (
   (let b__0 = csr in
   if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<and> ((((( 32 :: int)::ii) = (( 32 :: int)::ii)))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<and> ((((( 32 :: int)::ii) = (( 32 :: int)::ii)))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<and> ((((( 32 :: int)::ii) = (( 32 :: int)::ii)))))))
   else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<and> ((((( 32 :: int)::ii) = (( 32 :: int)::ii)))))))
   else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     and_boolM ((haveSupMode () ))
       (return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) \<or> (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word)))))))))
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits User  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits User  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits User  ::  2 Word.word)))))
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
     return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits User  ::  2 Word.word))))) \<and> ((((( 32 :: int)::ii) = (( 32 :: int)::ii)))))))
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
     return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits User  ::  2 Word.word))))) \<and> ((((( 32 :: int)::ii) = (( 32 :: int)::ii)))))))
   else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
     return ((((((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits User  ::  2 Word.word))))) \<and> ((((( 32 :: int)::ii) = (( 32 :: int)::ii)))))))
   else ext_is_CSR_defined csr p))" 
  for  csr  :: "(12)Word.word " 
  and  p  :: " Privilege "


\<comment> \<open>\<open>val check_CSR_access : mword ty2 -> mword ty2 -> Privilege -> bool -> bool\<close>\<close>

definition check_CSR_access  :: "(2)Word.word \<Rightarrow>(2)Word.word \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool "  where 
     " check_CSR_access csrrw csrpr p isWrite = (
   (((\<not> ((((((isWrite = True))) \<and> (((csrrw = (vec_of_bits [B1,B1]  ::  2 Word.word))))))))) \<and> ((zopz0zKzJ_u ((privLevel_to_bits p  ::  2 Word.word)) csrpr))))" 
  for  csrrw  :: "(2)Word.word " 
  and  csrpr  :: "(2)Word.word " 
  and  p  :: " Privilege " 
  and  isWrite  :: " bool "


\<comment> \<open>\<open>val check_TVM_SATP : mword ty12 -> Privilege -> M bool\<close>\<close>

definition check_TVM_SATP  :: "(12)Word.word \<Rightarrow> Privilege \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " check_TVM_SATP (csr :: csreg) (p :: Privilege) = (
   and_boolM
     (return (((csr = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))))
     (and_boolM
        (return (((((privLevel_to_bits p  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
        (read_reg mstatus_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
         return (((((get_Mstatus_TVM w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))) \<bind> (\<lambda> (w__2 ::
     bool) . 
   return ((\<not> w__2))))" 
  for  csr  :: "(12)Word.word " 
  and  p  :: " Privilege "


\<comment> \<open>\<open>val check_Counteren : mword ty12 -> Privilege -> M bool\<close>\<close>

definition check_Counteren  :: "(12)Word.word \<Rightarrow> Privilege \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " check_Counteren (csr :: csreg) (p :: Privilege) = (
   (case  (csr, p) of
     (b__0, Supervisor) =>
      if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        read_reg mcounteren_ref \<bind> (\<lambda> (w__0 :: Counteren) . 
        return (((((get_Counteren_CY w__0  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))))
      else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
        read_reg mcounteren_ref \<bind> (\<lambda> (w__1 :: Counteren) . 
        return (((((get_Counteren_TM w__1  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))))
      else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        read_reg mcounteren_ref \<bind> (\<lambda> (w__2 :: Counteren) . 
        return (((((get_Counteren_IR w__2  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))))
      else
        return ((case  (b__0, Supervisor) of
          (_, _) =>
           if (((((zopz0zIzJ_u (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)
                      csr)) \<and> ((zopz0zIzJ_u csr
                      (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1]  ::  12 Word.word)))))) then
             False
           else True
        ))
   | (b__3, User) =>
      if (((b__3 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        and_boolM
          (read_reg mcounteren_ref \<bind> (\<lambda> (w__6 :: Counteren) . 
           return (((((get_Counteren_CY w__6  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))
          (or_boolM (haveSupMode ()  \<bind> (\<lambda> (w__7 :: bool) .  return ((\<not> w__7))))
             (read_reg scounteren_ref \<bind> (\<lambda> (w__8 :: Counteren) . 
              return (((((get_Counteren_CY w__8  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))))))
      else if (((b__3 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
        and_boolM
          (read_reg mcounteren_ref \<bind> (\<lambda> (w__11 :: Counteren) . 
           return (((((get_Counteren_TM w__11  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))
          (or_boolM (haveSupMode ()  \<bind> (\<lambda> (w__12 :: bool) .  return ((\<not> w__12))))
             (read_reg scounteren_ref \<bind> (\<lambda> (w__13 :: Counteren) . 
              return (((((get_Counteren_TM w__13  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))))))
      else if (((b__3 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        and_boolM
          (read_reg mcounteren_ref \<bind> (\<lambda> (w__16 :: Counteren) . 
           return (((((get_Counteren_IR w__16  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))
          (or_boolM (haveSupMode ()  \<bind> (\<lambda> (w__17 :: bool) .  return ((\<not> w__17))))
             (read_reg scounteren_ref \<bind> (\<lambda> (w__18 :: Counteren) . 
              return (((((get_Counteren_IR w__18  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))))))
      else
        return ((case  (b__3, User) of
          (_, _) =>
           if (((((zopz0zIzJ_u (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)
                      csr)) \<and> ((zopz0zIzJ_u csr
                      (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1]  ::  12 Word.word)))))) then
             False
           else True
        ))
   | (_, _) =>
      return (if (((((zopz0zIzJ_u (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)
                         csr)) \<and> ((zopz0zIzJ_u csr
                         (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B1,B1,B1,B1,B1]  ::  12 Word.word)))))) then
                False
              else True)
   ))" 
  for  csr  :: "(12)Word.word " 
  and  p  :: " Privilege "


\<comment> \<open>\<open>val check_CSR : mword ty12 -> Privilege -> bool -> M bool\<close>\<close>

definition check_CSR  :: "(12)Word.word \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " check_CSR (csr :: csreg) (p :: Privilege) (isWrite :: bool) = (
   and_boolM ((is_CSR_defined csr p))
     (and_boolM
        (return ((check_CSR_access ((csrAccess csr  ::  2 Word.word)) ((csrPriv csr  ::  2 Word.word)) p
                    isWrite))) (and_boolM ((check_TVM_SATP csr p)) ((check_Counteren csr p)))))" 
  for  csr  :: "(12)Word.word " 
  and  p  :: " Privilege " 
  and  isWrite  :: " bool "


\<comment> \<open>\<open>val exception_delegatee : ExceptionType -> Privilege -> M Privilege\<close>\<close>

definition exception_delegatee  :: " ExceptionType \<Rightarrow> Privilege \<Rightarrow>((register_value),(Privilege),(exception))monad "  where 
     " exception_delegatee (e :: ExceptionType) (p :: Privilege) = (
   (let idx = (num_of_ExceptionType e) in
   read_reg medeleg_ref \<bind> (\<lambda> (w__0 :: Medeleg) . 
   (let super = (access_vec_dec ((get_Medeleg_bits w__0  ::  32 Word.word)) idx) in
   haveSupMode ()  \<bind> (\<lambda> (w__1 :: bool) . 
   (if w__1 then
      and_boolM (return ((bit_to_bool super)))
        (and_boolM ((haveNExt () ))
           (read_reg sedeleg_ref \<bind> (\<lambda> (w__3 :: Sedeleg) . 
            return ((bit_to_bool ((access_vec_dec ((get_Sedeleg_bits w__3  ::  32 Word.word)) idx)))))))
    else and_boolM (return ((bit_to_bool super))) ((haveNExt () ))) \<bind> (\<lambda> user . 
   and_boolM ((haveUsrMode () )) (return user) \<bind> (\<lambda> w__9 . 
   (if w__9 then return User
    else
      and_boolM ((haveSupMode () )) (return ((bit_to_bool super))) \<bind> (\<lambda> (w__11 :: bool) . 
      return (if w__11 then Supervisor
              else Machine))) \<bind> (\<lambda> deleg . 
   return (if ((zopz0zI_u ((privLevel_to_bits deleg  ::  2 Word.word))
                  ((privLevel_to_bits p  ::  2 Word.word)))) then
             p
           else deleg)))))))))" 
  for  e  :: " ExceptionType " 
  and  p  :: " Privilege "


\<comment> \<open>\<open>val findPendingInterrupt : mword ty32 -> maybe InterruptType\<close>\<close>

definition findPendingInterrupt  :: "(32)Word.word \<Rightarrow>(InterruptType)option "  where 
     " findPendingInterrupt ip = (
   (let ip = (Mk_Minterrupts ip) in
   if (((((get_Minterrupts_MEI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
     Some I_M_External
   else if (((((get_Minterrupts_MSI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_M_Software
   else if (((((get_Minterrupts_MTI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_M_Timer
   else if (((((get_Minterrupts_SEI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_S_External
   else if (((((get_Minterrupts_SSI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_S_Software
   else if (((((get_Minterrupts_STI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_S_Timer
   else if (((((get_Minterrupts_UEI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_U_External
   else if (((((get_Minterrupts_USI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_U_Software
   else if (((((get_Minterrupts_UTI ip  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
   then
     Some I_U_Timer
   else None))" 
  for  ip  :: "(32)Word.word "


\<comment> \<open>\<open>val processPending : Minterrupts -> Minterrupts -> mword ty32 -> bool -> interrupt_set\<close>\<close>

definition processPending  :: " Minterrupts \<Rightarrow> Minterrupts \<Rightarrow>(32)Word.word \<Rightarrow> bool \<Rightarrow> interrupt_set "  where 
     " processPending (xip :: Minterrupts) (xie :: Minterrupts) (xideleg :: xlenbits) (priv_enabled :: bool) = (
   (let effective_pend =
     ((and_vec ((get_Minterrupts_bits xip  ::  32 Word.word))
        ((and_vec ((get_Minterrupts_bits xie  ::  32 Word.word)) ((not_vec xideleg  ::  32 Word.word))
           ::  32 Word.word))
       ::  32 Word.word)) in
   (let effective_delg = ((and_vec ((get_Minterrupts_bits xip  ::  32 Word.word)) xideleg  ::  32 Word.word)) in
   if (((priv_enabled \<and> (((effective_pend \<noteq> ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))))))))
   then
     Ints_Pending effective_pend
   else if (((effective_delg \<noteq> ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)))))
   then
     Ints_Delegated effective_delg
   else Ints_Empty () )))" 
  for  xip  :: " Minterrupts " 
  and  xie  :: " Minterrupts " 
  and  xideleg  :: "(32)Word.word " 
  and  priv_enabled  :: " bool "


\<comment> \<open>\<open>val getPendingSet : Privilege -> M (maybe ((mword ty32 * Privilege)))\<close>\<close>

definition getPendingSet  :: " Privilege \<Rightarrow>((register_value),(((32)Word.word*Privilege)option),(exception))monad "  where 
     " getPendingSet priv = (
   haveUsrMode ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (assert_exp w__0 (''no user mode: M/U or M/S/U system required'') \<then>
   read_reg mip_ref) \<bind> (\<lambda> (w__1 :: Minterrupts) . 
   read_reg mie_ref \<bind> (\<lambda> (w__2 :: Minterrupts) . 
   (let effective_pending =
     ((and_vec ((get_Minterrupts_bits w__1  ::  32 Word.word))
        ((get_Minterrupts_bits w__2  ::  32 Word.word))
       ::  32 Word.word)) in
   if (((effective_pending = ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)))))
   then
     return None
   else
     or_boolM
       (return (((((privLevel_to_bits priv  ::  2 Word.word)) \<noteq> ((privLevel_to_bits Machine  ::  2 Word.word))))))
       (and_boolM
          (return (((((privLevel_to_bits priv  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))))
          (read_reg mstatus_ref \<bind> (\<lambda> (w__3 :: Mstatus) . 
           return (((((get_Mstatus_MIE w__3  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))) \<bind> (\<lambda> mIE . 
     and_boolM ((haveSupMode () ))
       (or_boolM
          (return (((((privLevel_to_bits priv  ::  2 Word.word)) = ((privLevel_to_bits User  ::  2 Word.word))))))
          (and_boolM
             (return (((((privLevel_to_bits priv  ::  2 Word.word)) = ((privLevel_to_bits Supervisor  ::  2 Word.word))))))
             (read_reg mstatus_ref \<bind> (\<lambda> (w__6 :: Mstatus) . 
              return (((((get_Mstatus_SIE w__6  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))))))) \<bind> (\<lambda> sIE . 
     and_boolM ((haveNExt () ))
       (and_boolM
          (return (((((privLevel_to_bits priv  ::  2 Word.word)) = ((privLevel_to_bits User  ::  2 Word.word))))))
          (read_reg mstatus_ref \<bind> (\<lambda> (w__10 :: Mstatus) . 
           return (((((get_Mstatus_UIE w__10  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))) \<bind> (\<lambda> uIE . 
     read_reg mip_ref \<bind> (\<lambda> (w__12 :: Minterrupts) . 
     read_reg mie_ref \<bind> (\<lambda> (w__13 :: Minterrupts) . 
     read_reg mideleg_ref \<bind> (\<lambda> (w__14 :: Minterrupts) . 
     (case  ((processPending w__12 w__13 ((get_Minterrupts_bits w__14  ::  32 Word.word)) mIE)) of
       Ints_Empty (_) => return None
     | Ints_Pending (p) =>
        (let r = (p, Machine) in
        return (Some r))
     | Ints_Delegated (d) =>
        haveSupMode ()  \<bind> (\<lambda> (w__15 :: bool) . 
        if ((\<not> w__15)) then
          return (if uIE then
                    (let r = (d, User) in
                    Some r)
                  else None)
        else
          read_reg mie_ref \<bind> (\<lambda> (w__16 :: Minterrupts) . 
          read_reg sideleg_ref \<bind> (\<lambda> (w__17 :: Sinterrupts) . 
          return ((case  ((processPending ((Mk_Minterrupts d)) w__16
                            ((get_Sinterrupts_bits w__17  ::  32 Word.word)) sIE)) of
            Ints_Empty (_) => None
          | Ints_Pending (p) =>
             (let r = (p, Supervisor) in
             Some r)
          | Ints_Delegated (d) =>
             if uIE then
               (let r = (d, User) in
               Some r)
             else None
          )))))
     ))))))))))))" 
  for  priv  :: " Privilege "


\<comment> \<open>\<open>val dispatchInterrupt : Privilege -> M (maybe ((InterruptType * Privilege)))\<close>\<close>

definition dispatchInterrupt  :: " Privilege \<Rightarrow>((register_value),((InterruptType*Privilege)option),(exception))monad "  where 
     " dispatchInterrupt priv = (
   or_boolM (haveUsrMode ()  \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0))))
     (and_boolM (haveSupMode ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1))))
        (haveNExt ()  \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) \<bind> (\<lambda> (w__4 :: bool) . 
   if w__4 then
     (assert_exp (((((privLevel_to_bits priv  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word))))) (''invalid current privilege'') \<then>
     read_reg mip_ref) \<bind> (\<lambda> (w__5 :: Minterrupts) . 
     read_reg mie_ref \<bind> (\<lambda> (w__6 :: Minterrupts) . 
     (let enabled_pending =
       ((and_vec ((get_Minterrupts_bits w__5  ::  32 Word.word))
          ((get_Minterrupts_bits w__6  ::  32 Word.word))
         ::  32 Word.word)) in
     return ((case  ((findPendingInterrupt enabled_pending)) of
       Some (i) =>
        (let r = (i, Machine) in
        Some r)
     | None => None
     )))))
   else
     (getPendingSet priv  :: ( (( 32 Word.word * Privilege))option) M) \<bind> (\<lambda> (w__7 ::
        (( 32 Word.word * Privilege))option) . 
     return ((case  w__7 of
       None => None
     | Some ((ip, p)) =>
        (case  ((findPendingInterrupt ip)) of
          None => None
        | Some (i) =>
           (let r = (i, p) in
           Some r)
        )
     )))))" 
  for  priv  :: " Privilege "


\<comment> \<open>\<open>val tval : maybe (mword ty32) -> mword ty32\<close>\<close>

fun tval  :: "((32)Word.word)option \<Rightarrow>(32)Word.word "  where 
     " tval (Some (e)) = ( e )" 
  for  e  :: "(32)Word.word "
|" tval None = ( (EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))"


\<comment> \<open>\<open>val rvfi_trap : unit -> unit\<close>\<close>

definition rvfi_trap  :: " unit \<Rightarrow> unit "  where 
     " rvfi_trap _ = ( ()  )"


\<comment> \<open>\<open>val trap_handler : Privilege -> bool -> mword ty8 -> mword ty32 -> maybe (mword ty32) -> maybe unit -> M (mword ty32)\<close>\<close>

definition trap_handler  :: " Privilege \<Rightarrow> bool \<Rightarrow>(8)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(xlenbits)option \<Rightarrow>(ext_exception)option \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " trap_handler (del_priv :: Privilege) (intr :: bool) (c :: exc_code) (pc :: xlenbits) (info ::
   xlenbits option) (ext ::  ext_exception option) = (
   (let (_ :: unit) = (rvfi_trap () ) in
   (let (_ :: unit) =
     (if ((get_config_print_platform () )) then
       print_dbg
         (((@) (''handling '')
             (((@) (if intr then (''int#'') else (''exc#''))
                 (((@) ((string_of_bits c))
                     (((@) ('' at priv '')
                         (((@) ((privLevel_to_str del_priv))
                             (((@) ('' with tval '')
                                 ((string_of_bits ((tval info  ::  32 Word.word))))))))))))))))
     else () ) in
   (let (_ :: unit) = (cancel_reservation () ) in
   (case  del_priv of
     Machine =>
      ((set_Mcause_IsInterrupt mcause_ref ((bool_to_bits intr  ::  1 Word.word)) \<then>
      set_Mcause_Cause mcause_ref ((EXTZ (( 31 :: int)::ii) c  ::  31 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__0 :: Mstatus) . 
      ((set_Mstatus_MPIE mstatus_ref ((get_Mstatus_MIE w__0  ::  1 Word.word)) \<then>
      set_Mstatus_MIE mstatus_ref ((bool_to_bits False  ::  1 Word.word))) \<then>
      read_reg cur_privilege_ref) \<bind> (\<lambda> (w__1 :: Privilege) . 
      (((set_Mstatus_MPP mstatus_ref ((privLevel_to_bits w__1  ::  2 Word.word)) \<then>
      write_reg mtval_ref ((tval info  ::  32 Word.word))) \<then>
      write_reg mepc_ref pc) \<then>
      write_reg cur_privilege_ref del_priv) \<then>
      ((let (_ :: unit) = (handle_trap_extension del_priv pc ext) in
      ((if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> (\<lambda> (w__2 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__2  ::  32 Word.word)))))))))
       else return () ) \<then>
      read_reg mcause_ref) \<bind> (\<lambda> (w__3 :: Mcause) . 
      (prepare_trap_vector del_priv w__3  :: ( 32 Word.word) M))))))
   | Supervisor =>
      haveSupMode ()  \<bind> (\<lambda> (w__5 :: bool) . 
      (((assert_exp w__5 (''no supervisor mode present for delegation'') \<then>
      set_Mcause_IsInterrupt scause_ref ((bool_to_bits intr  ::  1 Word.word))) \<then>
      set_Mcause_Cause scause_ref ((EXTZ (( 31 :: int)::ii) c  ::  31 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__6 :: Mstatus) . 
      ((set_Mstatus_SPIE mstatus_ref ((get_Mstatus_SIE w__6  ::  1 Word.word)) \<then>
      set_Mstatus_SIE mstatus_ref ((bool_to_bits False  ::  1 Word.word))) \<then>
      read_reg cur_privilege_ref) \<bind> (\<lambda> (w__7 :: Privilege) . 
      (case  w__7 of
        User => return ((bool_to_bits False  ::  1 Word.word))
      | Supervisor => return ((bool_to_bits True  ::  1 Word.word))
      | Machine => (internal_error (''invalid privilege for s-mode trap'')  :: ( 1 Word.word) M)
      ) \<bind> (\<lambda> (w__9 ::  1 Word.word) . 
      (((set_Mstatus_SPP mstatus_ref w__9 \<then>
      write_reg stval_ref ((tval info  ::  32 Word.word))) \<then>
      write_reg sepc_ref pc) \<then>
      write_reg cur_privilege_ref del_priv) \<then>
      ((let (_ :: unit) = (handle_trap_extension del_priv pc ext) in
      ((if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> (\<lambda> (w__10 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__10  ::  32 Word.word)))))))))
       else return () ) \<then>
      read_reg scause_ref) \<bind> (\<lambda> (w__11 :: Mcause) . 
      (prepare_trap_vector del_priv w__11  :: ( 32 Word.word) M))))))))
   | User =>
      haveUsrMode ()  \<bind> (\<lambda> (w__13 :: bool) . 
      (((assert_exp w__13 (''no user mode present for delegation'') \<then>
      set_Mcause_IsInterrupt ucause_ref ((bool_to_bits intr  ::  1 Word.word))) \<then>
      set_Mcause_Cause ucause_ref ((EXTZ (( 31 :: int)::ii) c  ::  31 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__14 :: Mstatus) . 
      ((((set_Mstatus_UPIE mstatus_ref ((get_Mstatus_UIE w__14  ::  1 Word.word)) \<then>
      set_Mstatus_UIE mstatus_ref ((bool_to_bits False  ::  1 Word.word))) \<then>
      write_reg utval_ref ((tval info  ::  32 Word.word))) \<then>
      write_reg uepc_ref pc) \<then>
      write_reg cur_privilege_ref del_priv) \<then>
      ((let (_ :: unit) = (handle_trap_extension del_priv pc ext) in
      ((if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> (\<lambda> (w__15 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__15  ::  32 Word.word)))))))))
       else return () ) \<then>
      read_reg ucause_ref) \<bind> (\<lambda> (w__16 :: Mcause) . 
      (prepare_trap_vector del_priv w__16  :: ( 32 Word.word) M))))))
   )))))" 
  for  del_priv  :: " Privilege " 
  and  intr  :: " bool " 
  and  c  :: "(8)Word.word " 
  and  pc  :: "(32)Word.word " 
  and  info  :: "(xlenbits)option " 
  and  ext  :: "(ext_exception)option "


\<comment> \<open>\<open>val exception_handler : Privilege -> ctl_result -> mword ty32 -> M (mword ty32)\<close>\<close>

definition exception_handler  :: " Privilege \<Rightarrow> ctl_result \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " exception_handler (cur_priv :: Privilege) (ctl :: ctl_result) (pc :: xlenbits) = (
   (case  (cur_priv, ctl) of
     (_, CTL_TRAP (e)) =>
      exception_delegatee(sync_exception_trap   e) cur_priv \<bind> (\<lambda> del_priv . 
      (let (_ :: unit) =
        (if ((get_config_print_platform () )) then
          print_dbg
            (((@) (''trapping from '')
                (((@) ((privLevel_to_str cur_priv))
                    (((@) ('' to '')
                        (((@) ((privLevel_to_str del_priv))
                            (((@) ('' to handle '')
                                ((exceptionType_to_str(sync_exception_trap   e)))))))))))))
        else () ) in
      (trap_handler del_priv False ((exceptionType_to_bits(sync_exception_trap   e)  ::  8 Word.word)) pc(sync_exception_excinfo  
         e)(sync_exception_ext_exception   e)
        :: ( 32 Word.word) M)))
   | (_, CTL_MRET (_)) =>
      read_reg cur_privilege_ref \<bind> (\<lambda> prev_priv . 
      read_reg mstatus_ref \<bind> (\<lambda> (w__1 :: Mstatus) . 
      ((set_Mstatus_MIE mstatus_ref ((get_Mstatus_MPIE w__1  ::  1 Word.word)) \<then>
      set_Mstatus_MPIE mstatus_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__2 :: Mstatus) . 
      privLevel_of_bits ((get_Mstatus_MPP w__2  ::  2 Word.word)) \<bind> (\<lambda> (w__3 :: Privilege) . 
      (write_reg cur_privilege_ref w__3 \<then>
      haveUsrMode () ) \<bind> (\<lambda> (w__4 :: bool) . 
      ((set_Mstatus_MPP mstatus_ref
        ((privLevel_to_bits (if w__4 then User else Machine)  ::  2 Word.word)) \<then>
      (if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> (\<lambda> (w__5 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__5  ::  32 Word.word)))))))))
       else return () )) \<then>
      (if ((get_config_print_platform () )) then
         read_reg cur_privilege_ref \<bind> (\<lambda> (w__6 :: Privilege) . 
         return ((print_dbg
                    (((@) (''ret-ing from '')
                        (((@) ((privLevel_to_str prev_priv))
                            (((@) ('' to '') ((privLevel_to_str w__6)))))))))))
       else return () )) \<then>
      ((let (_ :: unit) = (cancel_reservation () ) in
      (prepare_xret_target Machine  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 ::  32 Word.word) . 
      (pc_alignment_mask ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__8 ::  32 Word.word) . 
      return ((and_vec w__7 w__8  ::  32 Word.word)))))))))))
   | (_, CTL_SRET (_)) =>
      read_reg cur_privilege_ref \<bind> (\<lambda> prev_priv . 
      read_reg mstatus_ref \<bind> (\<lambda> (w__9 :: Mstatus) . 
      ((set_Mstatus_SIE mstatus_ref ((get_Mstatus_SPIE w__9  ::  1 Word.word)) \<then>
      set_Mstatus_SPIE mstatus_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
      read_reg mstatus_ref) \<bind> (\<lambda> (w__10 :: Mstatus) . 
      (((write_reg
        cur_privilege_ref
        (if (((((get_Mstatus_SPP w__10  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))
         then
           Supervisor
         else User) \<then>
      set_Mstatus_SPP mstatus_ref ((bool_to_bits False  ::  1 Word.word))) \<then>
      (if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> (\<lambda> (w__11 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__11  ::  32 Word.word)))))))))
       else return () )) \<then>
      (if ((get_config_print_platform () )) then
         read_reg cur_privilege_ref \<bind> (\<lambda> (w__12 :: Privilege) . 
         return ((print_dbg
                    (((@) (''ret-ing from '')
                        (((@) ((privLevel_to_str prev_priv))
                            (((@) ('' to '') ((privLevel_to_str w__12)))))))))))
       else return () )) \<then>
      ((let (_ :: unit) = (cancel_reservation () ) in
      (prepare_xret_target Supervisor  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 ::  32 Word.word) . 
      (pc_alignment_mask ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__14 ::  32 Word.word) . 
      return ((and_vec w__13 w__14  ::  32 Word.word)))))))))
   | (_, CTL_URET (_)) =>
      read_reg cur_privilege_ref \<bind> (\<lambda> prev_priv . 
      read_reg mstatus_ref \<bind> (\<lambda> (w__15 :: Mstatus) . 
      ((((set_Mstatus_UIE mstatus_ref ((get_Mstatus_UPIE w__15  ::  1 Word.word)) \<then>
      set_Mstatus_UPIE mstatus_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
      write_reg cur_privilege_ref User) \<then>
      (if ((get_config_print_reg () )) then
         read_reg mstatus_ref \<bind> (\<lambda> (w__16 :: Mstatus) . 
         return ((print_dbg
                    (((@) (''CSR mstatus <- '')
                        ((string_of_bits ((get_Mstatus_bits w__16  ::  32 Word.word)))))))))
       else return () )) \<then>
      (if ((get_config_print_platform () )) then
         read_reg cur_privilege_ref \<bind> (\<lambda> (w__17 :: Privilege) . 
         return ((print_dbg
                    (((@) (''ret-ing from '')
                        (((@) ((privLevel_to_str prev_priv))
                            (((@) ('' to '') ((privLevel_to_str w__17)))))))))))
       else return () )) \<then>
      ((let (_ :: unit) = (cancel_reservation () ) in
      (prepare_xret_target User  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__18 ::  32 Word.word) . 
      (pc_alignment_mask ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__19 ::  32 Word.word) . 
      return ((and_vec w__18 w__19  ::  32 Word.word))))))))
   ))" 
  for  cur_priv  :: " Privilege " 
  and  ctl  :: " ctl_result " 
  and  pc  :: "(32)Word.word "


\<comment> \<open>\<open>val handle_mem_exception : mword ty32 -> ExceptionType -> M unit\<close>\<close>

definition handle_mem_exception  :: "(32)Word.word \<Rightarrow> ExceptionType \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " handle_mem_exception (addr :: xlenbits) (e :: ExceptionType) = (
   (let (t :: sync_exception) =
     ((| sync_exception_trap = e, 
        sync_exception_excinfo = (Some addr), 
        sync_exception_ext_exception = None |)) in
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
   (exception_handler w__0 (CTL_TRAP t) w__1  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
   set_next_pc w__2)))))" 
  for  addr  :: "(32)Word.word " 
  and  e  :: " ExceptionType "


\<comment> \<open>\<open>val handle_interrupt : InterruptType -> Privilege -> M unit\<close>\<close>

definition handle_interrupt  :: " InterruptType \<Rightarrow> Privilege \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " handle_interrupt (i :: InterruptType) (del_priv :: Privilege) = (
   (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   (trap_handler del_priv True ((interruptType_to_bits i  ::  8 Word.word)) w__0 None None
     :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
   set_next_pc w__1)))" 
  for  i  :: " InterruptType " 
  and  del_priv  :: " Privilege "


\<comment> \<open>\<open>val init_sys : unit -> M unit\<close>\<close>

definition init_sys  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " init_sys _ = (
   (((((((((write_reg cur_privilege_ref Machine \<then>
   write_reg mhartid_ref ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) \<then>
   set_Misa_MXL misa_ref ((arch_to_bits RV32  ::  2 Word.word))) \<then>
   set_Misa_A misa_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
   set_Misa_C misa_ref ((bool_to_bits ((sys_enable_rvc () ))  ::  1 Word.word))) \<then>
   set_Misa_I misa_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
   set_Misa_M misa_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
   set_Misa_U misa_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
   set_Misa_S misa_ref ((bool_to_bits True  ::  1 Word.word))) \<then>
   read_reg mstatus_ref) \<bind> (\<lambda> (w__0 :: Mstatus) . 
   read_reg misa_ref \<bind> (\<lambda> (w__1 :: Misa) . 
   (write_reg mstatus_ref ((set_mstatus_SXL w__0 ((get_Misa_MXL w__1  ::  2 Word.word)))) \<then>
   read_reg mstatus_ref) \<bind> (\<lambda> (w__2 :: Mstatus) . 
   read_reg misa_ref \<bind> (\<lambda> (w__3 :: Misa) . 
   ((((((((((((((((write_reg mstatus_ref ((set_mstatus_UXL w__2 ((get_Misa_MXL w__3  ::  2 Word.word)))) \<then>
   set_Mstatus_SD mstatus_ref ((bool_to_bits False  ::  1 Word.word))) \<then>
   set_Minterrupts_bits mip_ref ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) \<then>
   set_Minterrupts_bits mie_ref ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) \<then>
   set_Minterrupts_bits mideleg_ref ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) \<then>
   set_Medeleg_bits medeleg_ref ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) \<then>
   set_Mtvec_bits mtvec_ref ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) \<then>
   set_Mcause_bits mcause_ref ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) \<then>
   write_reg mepc_ref ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) \<then>
   write_reg mtval_ref ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) \<then>
   write_reg mscratch_ref ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) \<then>
   write_reg mcycle_ref ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))) \<then>
   write_reg mtime_ref ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))) \<then>
   set_Counteren_bits mcounteren_ref ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))) \<then>
   write_reg minstret_ref ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word))) \<then>
   write_reg minstret_written_ref False) \<then>
   init_pmp () ) \<then>
   (if ((get_config_print_reg () )) then
     read_reg mstatus_ref \<bind> (\<lambda> (w__4 :: Mstatus) . 
     return ((print_dbg
                (((@) (''CSR mstatus <- '')
                    (((@) ((string_of_bits ((get_Mstatus_bits w__4  ::  32 Word.word))))
                        (((@) ('' (input: '')
                            (((@)
                                ((string_of_bits
                                    ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word))))
                                ('')''))))))))))))
   else return () ))))))"


\<comment> \<open>\<open>val elf_tohost : unit -> ii\<close>\<close>

\<comment> \<open>\<open>val elf_entry : unit -> ii\<close>\<close>



\<comment> \<open>\<open>val phys_mem_segments : unit -> list ((mword ty32 * mword ty32))\<close>\<close>

definition phys_mem_segments  :: " unit \<Rightarrow>((32)Word.word*(32)Word.word)list "  where 
     " phys_mem_segments _ = (
   ((plat_rom_base ()   ::  32 Word.word), (plat_rom_size ()   ::  32 Word.word)) #
     (((plat_ram_base ()   ::  32 Word.word), (plat_ram_size ()   ::  32 Word.word)) # []))"


\<comment> \<open>\<open>val within_phys_mem : mword ty32 -> integer -> bool\<close>\<close>

definition within_phys_mem  :: "(32)Word.word \<Rightarrow> int \<Rightarrow> bool "  where 
     " within_phys_mem (addr :: xlenbits) (width :: int) = (
   (let addr_int = (Word.uint addr) in
   (let ram_base_int = (Word.uint ((plat_ram_base ()   ::  32 Word.word))) in
   (let rom_base_int = (Word.uint ((plat_rom_base ()   ::  32 Word.word))) in
   (let ram_size_int = (Word.uint ((plat_ram_size ()   ::  32 Word.word))) in
   (let rom_size_int = (Word.uint ((plat_rom_size ()   ::  32 Word.word))) in
   if (((((ram_base_int \<le> addr_int)) \<and> ((((addr_int + ((id0 width)))) \<le> ((ram_base_int + ram_size_int)))))))
   then
     True
   else if (((((rom_base_int \<le> addr_int)) \<and> ((((addr_int + ((id0 width)))) \<le>
                   ((rom_base_int + rom_size_int))))))) then
     True
   else
     (let (_ :: unit) =
       (print_dbg
         (((@) (''within_phys_mem: '')
             (((@) ((string_of_bits addr)) ('' not within phys-mem:'')))))) in
     (let (_ :: unit) =
       (print_dbg
         (((@) (''  plat_rom_base: '') ((string_of_bits ((plat_rom_base ()   ::  32 Word.word))))))) in
     (let (_ :: unit) =
       (print_dbg
         (((@) (''  plat_rom_size: '') ((string_of_bits ((plat_rom_size ()   ::  32 Word.word))))))) in
     (let (_ :: unit) =
       (print_dbg
         (((@) (''  plat_ram_base: '') ((string_of_bits ((plat_ram_base ()   ::  32 Word.word))))))) in
     (let (_ :: unit) =
       (print_dbg
         (((@) (''  plat_ram_size: '') ((string_of_bits ((plat_ram_size ()   ::  32 Word.word))))))) in
     False)))))))))))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val within_clint : mword ty32 -> integer -> bool\<close>\<close>

definition within_clint  :: "(32)Word.word \<Rightarrow> int \<Rightarrow> bool "  where 
     " within_clint (addr :: xlenbits) (width :: int) = (
   (let addr_int = (Word.uint addr) in
   (let clint_base_int = (Word.uint ((plat_clint_base ()   ::  32 Word.word))) in
   (let clint_size_int = (Word.uint ((plat_clint_size ()   ::  32 Word.word))) in
   (((clint_base_int \<le> addr_int)) \<and> ((((addr_int + ((id0 width)))) \<le> ((clint_base_int + clint_size_int)))))))))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val within_htif_writable : mword ty32 -> integer -> bool\<close>\<close>

definition within_htif_writable  :: "(32)Word.word \<Rightarrow> int \<Rightarrow> bool "  where 
     " within_htif_writable (addr :: xlenbits) (width :: int) = (
   ((((((plat_htif_tohost ()   ::  32 Word.word)) = addr))) \<or> ((((((((add_vec_int ((plat_htif_tohost ()   ::  32 Word.word)) (( 4 :: int)::ii)  ::  32 Word.word)) = addr))) \<and> (((width = (( 4 :: int)::ii)))))))))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val within_htif_readable : mword ty32 -> integer -> bool\<close>\<close>

definition within_htif_readable  :: "(32)Word.word \<Rightarrow> int \<Rightarrow> bool "  where 
     " within_htif_readable (addr :: xlenbits) (width :: int) = (
   ((((((plat_htif_tohost ()   ::  32 Word.word)) = addr))) \<or> ((((((((add_vec_int ((plat_htif_tohost ()   ::  32 Word.word)) (( 4 :: int)::ii)  ::  32 Word.word)) = addr))) \<and> (((width = (( 4 :: int)::ii)))))))))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int "


definition MSIP_BASE  :: "(32)Word.word "  where 
     " MSIP_BASE = (
  (EXTZ (( 32 :: int)::ii)
     (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  20 Word.word)
    ::  32 Word.word))"


definition MTIMECMP_BASE  :: "(32)Word.word "  where 
     " MTIMECMP_BASE = (
  (EXTZ (( 32 :: int)::ii)
     (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  20 Word.word)
    ::  32 Word.word))"


definition MTIMECMP_BASE_HI  :: "(32)Word.word "  where 
     " MTIMECMP_BASE_HI = (
  (EXTZ (( 32 :: int)::ii)
     (vec_of_bits [B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0]  ::  20 Word.word)
    ::  32 Word.word))"


definition MTIME_BASE  :: "(32)Word.word "  where 
     " MTIME_BASE = (
  (EXTZ (( 32 :: int)::ii)
     (vec_of_bits [B0,B0,B0,B0,B1,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B0,B0,B0]  ::  20 Word.word)
    ::  32 Word.word))"


definition MTIME_BASE_HI  :: "(32)Word.word "  where 
     " MTIME_BASE_HI = (
  (EXTZ (( 32 :: int)::ii)
     (vec_of_bits [B0,B0,B0,B0,B1,B0,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B1,B0,B0]  ::  20 Word.word)
    ::  32 Word.word))"


\<comment> \<open>\<open>val clint_load : forall 'int8_times_n. Size 'int8_times_n => mword ty32 -> integer -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

definition clint_load  :: "(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " clint_load addr width = (
   (let addr = ((sub_vec addr ((plat_clint_base ()   ::  32 Word.word))  ::  32 Word.word)) in
   if ((((((addr = MSIP_BASE))) \<and> ((((((((id0 width)) = (( 8 :: int)::ii)))) \<or> (((((id0 width)) = (( 4 :: int)::ii)))))))))) then
     ((if ((get_config_print_platform () )) then
        read_reg mip_ref \<bind> (\<lambda> (w__0 :: Minterrupts) . 
        return ((print_dbg
                   (((@) (''clint['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '')
                               ((string_of_bits ((get_Minterrupts_MSI w__0  ::  1 Word.word)))))))))))))
      else return () ) \<then>
     read_reg mip_ref) \<bind> (\<lambda> (w__1 :: Minterrupts) . 
     return (MemValue ((zero_extend ((get_Minterrupts_MSI w__1  ::  1 Word.word))
                          (((( 8 :: int)::ii) * ((id0 width))))
                         :: ( 'int8_times_n::len)Word.word))))
   else if ((((((addr = MTIMECMP_BASE))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint<4>['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '')
                               ((string_of_bits
                                   ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)))))))))))))
      else return () ) \<then>
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__3 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word))))
   else if ((((((addr = MTIMECMP_BASE))) \<and> (((((id0 width)) = (( 8 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__4 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint<8>['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '') ((string_of_bits w__4)))))))))))
      else return () ) \<then>
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__5 ::  64 Word.word) . 
     return (MemValue ((Word.ucast ((zero_extend w__5 (( 64 :: int)::ii)  ::  64 Word.word))  :: ( 'int8_times_n::len)Word.word))))
   else if ((((((addr = MTIMECMP_BASE_HI))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__6 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint-hi<4>['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '')
                               ((string_of_bits
                                   ((subrange_vec_dec w__6 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)))))))))))))
      else return () ) \<then>
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__7 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__7 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word))))
   else if ((((((addr = MTIME_BASE))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__8 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '') ((string_of_bits w__8)))))))))))
      else return () ) \<then>
     (read_reg mtime_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__9 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__9 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word))))
   else if ((((((addr = MTIME_BASE))) \<and> (((((id0 width)) = (( 8 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__10 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '') ((string_of_bits w__10)))))))))))
      else return () ) \<then>
     (read_reg mtime_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__11 ::  64 Word.word) . 
     return (MemValue ((Word.ucast ((zero_extend w__11 (( 64 :: int)::ii)  ::  64 Word.word))
                         :: ( 'int8_times_n::len)Word.word))))
   else if ((((((addr = MTIME_BASE_HI))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     ((if ((get_config_print_platform () )) then
        (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__12 ::  64 Word.word) . 
        return ((print_dbg
                   (((@) (''clint['')
                       (((@) ((string_of_bits addr))
                           (((@) (''] -> '') ((string_of_bits w__12)))))))))))
      else return () ) \<then>
     (read_reg mtime_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__13 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__13 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word))))
   else
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint['') (((@) ((string_of_bits addr)) (''] -> <not-mapped>'')))))
       else () ) in
     return (MemException E_Load_Access_Fault))))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val clint_dispatch : unit -> M unit\<close>\<close>

definition clint_dispatch  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " clint_dispatch _ = (
   (((if ((get_config_print_platform () )) then
      (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
      return ((print_dbg (((@) (''clint::tick mtime <- '') ((string_of_bits w__0)))))))
    else return () ) \<then>
   set_Minterrupts_MTI mip_ref ((bool_to_bits False  ::  1 Word.word))) \<then>
   (read_reg mtimecmp_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
   if ((zopz0zIzJ_u w__1 w__2)) then
     (if ((get_config_print_platform () )) then
        (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
        return ((print_dbg (((@) ('' clint timer pending at mtime '') ((string_of_bits w__3)))))))
      else return () ) \<then>
     set_Minterrupts_MTI mip_ref ((bool_to_bits True  ::  1 Word.word))
   else return () )))"


\<comment> \<open>\<open>val clint_store : forall 'int8_times_n. Size 'int8_times_n => mword ty32 -> integer -> mword 'int8_times_n -> M (MemoryOpResult bool)\<close>\<close>

definition clint_store  :: "(32)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad "  where 
     " clint_store addr width data = (
   (let addr = ((sub_vec addr ((plat_clint_base ()   ::  32 Word.word))  ::  32 Word.word)) in
   if ((((((addr = MSIP_BASE))) \<and> ((((((((id0 width)) = (( 8 :: int)::ii)))) \<or> (((((id0 width)) = (( 4 :: int)::ii)))))))))) then
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint['')
               (((@) ((string_of_bits addr))
                   (((@) (''] <- '')
                       (((@) ((string_of_bits data))
                           (((@) ('' (mip.MSI <- '')
                               (((@)
                                   ((string_of_bits
                                       ((cast_unit_vec0 ((access_vec_dec data (( 0 :: int)::ii)))  ::  1 Word.word))))
                                   ('')'')))))))))))))
       else () ) in
     (set_Minterrupts_MSI mip_ref
       ((bool_to_bits
           (((((cast_unit_vec0 ((access_vec_dec data (( 0 :: int)::ii)))  ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word))))
          ::  1 Word.word)) \<then>
     clint_dispatch () ) \<then> return (MemValue True))
   else if ((((((addr = MTIMECMP_BASE))) \<and> (((((id0 width)) = (( 8 :: int)::ii))))))) then
     (let (data ::  64 Word.word) = ((Word.ucast data  ::  64 Word.word)) in
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint<8>['')
               (((@) ((string_of_bits addr))
                   (((@) (''] <- '') (((@) ((string_of_bits data)) ('' (mtimecmp)'')))))))))
       else () ) in
     (write_reg mtimecmp_ref ((zero_extend data (( 64 :: int)::ii)  ::  64 Word.word)) \<then>
     clint_dispatch () ) \<then> return (MemValue True)))
   else if ((((((addr = MTIMECMP_BASE))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     (let (data ::  32 Word.word) = ((Word.ucast data  ::  32 Word.word)) in
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint<4>['')
               (((@) ((string_of_bits addr))
                   (((@) (''] <- '') (((@) ((string_of_bits data)) ('' (mtimecmp)'')))))))))
       else () ) in
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
     (write_reg
       mtimecmp_ref
       ((update_subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii) ((zero_extend data (( 32 :: int)::ii)  ::  32 Word.word))
          ::  64 Word.word)) \<then>
     clint_dispatch () ) \<then> return (MemValue True))))
   else if ((((((addr = MTIMECMP_BASE_HI))) \<and> (((((id0 width)) = (( 4 :: int)::ii))))))) then
     (let (data ::  32 Word.word) = ((Word.ucast data  ::  32 Word.word)) in
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint<4>['')
               (((@) ((string_of_bits addr))
                   (((@) (''] <- '') (((@) ((string_of_bits data)) ('' (mtimecmp)'')))))))))
       else () ) in
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     (write_reg
       mtimecmp_ref
       ((update_subrange_vec_dec w__1 (( 63 :: int)::ii) (( 32 :: int)::ii) ((zero_extend data (( 32 :: int)::ii)  ::  32 Word.word))
          ::  64 Word.word)) \<then>
     clint_dispatch () ) \<then> return (MemValue True))))
   else
     (let (_ :: unit) =
       (if ((get_config_print_platform () )) then
         print_dbg
           (((@) (''clint['')
               (((@) ((string_of_bits addr))
                   (((@) (''] <- '') (((@) ((string_of_bits data)) ('' (<unmapped>)'')))))))))
       else () ) in
     return (MemException E_SAMO_Access_Fault))))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word "


\<comment> \<open>\<open>val tick_clock : unit -> M unit\<close>\<close>

definition tick_clock  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " tick_clock _ = (
   (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (write_reg mcycle_ref ((add_vec_int w__0 (( 1 :: int)::ii)  ::  64 Word.word)) \<then>
   (read_reg mtime_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   write_reg mtime_ref ((add_vec_int w__1 (( 1 :: int)::ii)  ::  64 Word.word)) \<then> clint_dispatch () )))"


\<comment> \<open>\<open>val Mk_htif_cmd : mword ty64 -> htif_cmd\<close>\<close>

definition Mk_htif_cmd  :: "(64)Word.word \<Rightarrow> htif_cmd "  where 
     " Mk_htif_cmd v = (
   (| htif_cmd_htif_cmd_chunk_0 = ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) |) )" 
  for  v  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_htif_cmd_bits : htif_cmd -> mword ty64\<close>\<close>

definition get_htif_cmd_bits  :: " htif_cmd \<Rightarrow>(64)Word.word "  where 
     " get_htif_cmd_bits v = (
   (subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))" 
  for  v  :: " htif_cmd "


\<comment> \<open>\<open>val _set_htif_cmd_bits : register_ref regstate register_value htif_cmd -> mword ty64 -> M unit\<close>\<close>

definition set_htif_cmd_bits  :: "((regstate),(register_value),(htif_cmd))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_htif_cmd_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       htif_cmd_htif_cmd_chunk_0 :=
         ((update_subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   r) (( 63 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(htif_cmd))register_ref " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val _update_htif_cmd_bits : htif_cmd -> mword ty64 -> htif_cmd\<close>\<close>

definition update_htif_cmd_bits  :: " htif_cmd \<Rightarrow>(64)Word.word \<Rightarrow> htif_cmd "  where 
     " update_htif_cmd_bits v x = (
   (v (|
     htif_cmd_htif_cmd_chunk_0 :=
       ((update_subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " htif_cmd " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_htif_cmd_device : htif_cmd -> mword ty8\<close>\<close>

definition get_htif_cmd_device  :: " htif_cmd \<Rightarrow>(8)Word.word "  where 
     " get_htif_cmd_device v = (
   (subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   v) (( 63 :: int)::ii) (( 56 :: int)::ii)  ::  8 Word.word))" 
  for  v  :: " htif_cmd "


\<comment> \<open>\<open>val _set_htif_cmd_device : register_ref regstate register_value htif_cmd -> mword ty8 -> M unit\<close>\<close>

definition set_htif_cmd_device  :: "((regstate),(register_value),(htif_cmd))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_htif_cmd_device r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       htif_cmd_htif_cmd_chunk_0 :=
         ((update_subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   r) (( 63 :: int)::ii) (( 56 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(htif_cmd))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_htif_cmd_device : htif_cmd -> mword ty8 -> htif_cmd\<close>\<close>

definition update_htif_cmd_device  :: " htif_cmd \<Rightarrow>(8)Word.word \<Rightarrow> htif_cmd "  where 
     " update_htif_cmd_device v x = (
   (v (|
     htif_cmd_htif_cmd_chunk_0 :=
       ((update_subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   v) (( 63 :: int)::ii) (( 56 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " htif_cmd " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_htif_cmd_cmd : htif_cmd -> mword ty8\<close>\<close>

definition get_htif_cmd_cmd  :: " htif_cmd \<Rightarrow>(8)Word.word "  where 
     " get_htif_cmd_cmd v = (
   (subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   v) (( 55 :: int)::ii) (( 48 :: int)::ii)  ::  8 Word.word))" 
  for  v  :: " htif_cmd "


\<comment> \<open>\<open>val _set_htif_cmd_cmd : register_ref regstate register_value htif_cmd -> mword ty8 -> M unit\<close>\<close>

definition set_htif_cmd_cmd  :: "((regstate),(register_value),(htif_cmd))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_htif_cmd_cmd r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       htif_cmd_htif_cmd_chunk_0 :=
         ((update_subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   r) (( 55 :: int)::ii) (( 48 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(htif_cmd))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_htif_cmd_cmd : htif_cmd -> mword ty8 -> htif_cmd\<close>\<close>

definition update_htif_cmd_cmd  :: " htif_cmd \<Rightarrow>(8)Word.word \<Rightarrow> htif_cmd "  where 
     " update_htif_cmd_cmd v x = (
   (v (|
     htif_cmd_htif_cmd_chunk_0 :=
       ((update_subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   v) (( 55 :: int)::ii) (( 48 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " htif_cmd " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_htif_cmd_payload : htif_cmd -> mword ty48\<close>\<close>

definition get_htif_cmd_payload  :: " htif_cmd \<Rightarrow>(48)Word.word "  where 
     " get_htif_cmd_payload v = (
   (subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   v) (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))" 
  for  v  :: " htif_cmd "


\<comment> \<open>\<open>val _set_htif_cmd_payload : register_ref regstate register_value htif_cmd -> mword ty48 -> M unit\<close>\<close>

definition set_htif_cmd_payload  :: "((regstate),(register_value),(htif_cmd))register_ref \<Rightarrow>(48)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_htif_cmd_payload r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       htif_cmd_htif_cmd_chunk_0 :=
         ((update_subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   r) (( 47 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(htif_cmd))register_ref " 
  and  v  :: "(48)Word.word "


\<comment> \<open>\<open>val _update_htif_cmd_payload : htif_cmd -> mword ty48 -> htif_cmd\<close>\<close>

definition update_htif_cmd_payload  :: " htif_cmd \<Rightarrow>(48)Word.word \<Rightarrow> htif_cmd "  where 
     " update_htif_cmd_payload v x = (
   (v (|
     htif_cmd_htif_cmd_chunk_0 :=
       ((update_subrange_vec_dec(htif_cmd_htif_cmd_chunk_0   v) (( 47 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " htif_cmd " 
  and  x  :: "(48)Word.word "


\<comment> \<open>\<open>val htif_load : forall 'int8_times_n. Size 'int8_times_n => mword ty32 -> integer -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

definition htif_load  :: "(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " htif_load addr width = (
   (if ((get_config_print_platform () )) then
      (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
      return ((print_dbg
                 (((@) (''htif['')
                     (((@) ((string_of_bits addr))
                         (((@) (''] -> '') ((string_of_bits w__0)))))))))))
    else return () ) \<then>
   (if ((((((width = (( 8 :: int)::ii)))) \<and> (((addr = ((plat_htif_tohost ()   ::  32 Word.word)))))))) then
     (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
     return (MemValue ((Word.ucast ((zero_extend w__1 (( 64 :: int)::ii)  ::  64 Word.word))  :: ( 'int8_times_n::len)Word.word))))
   else if ((((((width = (( 4 :: int)::ii)))) \<and> (((addr = ((plat_htif_tohost ()   ::  32 Word.word))))))))
   then
     (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word))))
   else if ((((((width = (( 4 :: int)::ii)))) \<and> (((addr = ((add_vec_int ((plat_htif_tohost ()   ::  32 Word.word)) (( 4 :: int)::ii)  ::  32 Word.word))))))))
   then
     (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
     return (MemValue ((Word.ucast
                          ((zero_extend ((subrange_vec_dec w__3 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word))
                              (( 32 :: int)::ii)
                             ::  32 Word.word))
                         :: ( 'int8_times_n::len)Word.word))))
   else return (MemException E_Load_Access_Fault)))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val htif_store : forall 'int8_times_n. Size 'int8_times_n => mword ty32 -> integer -> mword 'int8_times_n -> M (MemoryOpResult bool)\<close>\<close>

definition htif_store  :: "(32)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad "  where 
     " htif_store addr width data = (
   (let (_ :: unit) =
     (if ((get_config_print_platform () )) then
       print_dbg
         (((@) (''htif['')
             (((@) ((string_of_bits addr)) (((@) (''] <- '') ((string_of_bits data))))))))
     else () ) in
   ((if (((width = (( 8 :: int)::ii)))) then
      (let (data ::  64 Word.word) = ((Word.ucast data  ::  64 Word.word)) in
      write_reg htif_tohost_ref ((EXTZ (( 64 :: int)::ii) data  ::  64 Word.word)))
    else if ((((((width = (( 4 :: int)::ii)))) \<and> (((addr = ((plat_htif_tohost ()   ::  32 Word.word))))))))
    then
      (let (data ::  32 Word.word) = ((Word.ucast data  ::  32 Word.word)) in
      (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
      write_reg htif_tohost_ref ((update_subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii) data  ::  64 Word.word))))
    else if ((((((width = (( 4 :: int)::ii)))) \<and> (((addr = ((add_vec_int ((plat_htif_tohost ()   ::  32 Word.word)) (( 4 :: int)::ii)  ::  32 Word.word))))))))
    then
      (let (data ::  32 Word.word) = ((Word.ucast data  ::  32 Word.word)) in
      (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
      write_reg htif_tohost_ref ((update_subrange_vec_dec w__1 (( 63 :: int)::ii) (( 32 :: int)::ii) data  ::  64 Word.word))))
    else write_reg htif_tohost_ref ((EXTZ (( 64 :: int)::ii) data  ::  64 Word.word))) \<then>
   (read_reg htif_tohost_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
   (let cmd = (Mk_htif_cmd w__2) in
   (let b__0 = ((get_htif_cmd_device cmd  ::  8 Word.word)) in
   (if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)))) then
      (let (_ :: unit) =
        (if ((get_config_print_platform () )) then
          print_dbg
            (((@) (''htif-syscall-proxy cmd: '')
                ((string_of_bits ((get_htif_cmd_payload cmd  ::  48 Word.word))))))
        else () ) in
      if (((((cast_unit_vec0 ((access_vec_dec ((get_htif_cmd_payload cmd  ::  48 Word.word)) (( 0 :: int)::ii)))
                ::  1 Word.word)) = (vec_of_bits [B1]  ::  1 Word.word)))) then
        write_reg htif_done_ref True \<then>
        write_reg
          htif_exit_code_ref
          ((shiftr ((zero_extend ((get_htif_cmd_payload cmd  ::  48 Word.word)) (( 64 :: int)::ii)  ::  64 Word.word))
              (( 1 :: int)::ii)
             ::  64 Word.word))
      else return () )
    else
      return (if (((b__0 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1]  ::  8 Word.word)))) then
                (let (_ :: unit) =
                  (if ((get_config_print_platform () )) then
                    print_dbg
                      (((@) (''htif-term cmd: '')
                          ((string_of_bits ((get_htif_cmd_payload cmd  ::  48 Word.word))))))
                  else () ) in
                (let b__2 = ((get_htif_cmd_cmd cmd  ::  8 Word.word)) in
                if (((b__2 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)))) then () 
                else if (((b__2 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B1]  ::  8 Word.word)))) then
                  plat_term_write
                    ((subrange_vec_dec ((get_htif_cmd_payload cmd  ::  48 Word.word)) (( 7 :: int)::ii) (( 0 :: int)::ii)
                       ::  8 Word.word))
                else print_endline (((@) (''Unknown term cmd: '') ((string_of_bits b__2))))))
              else print_endline (((@) (''htif-???? cmd: '') ((string_of_bits data)))))) \<then>
   return (MemValue True))))))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word "


\<comment> \<open>\<open>val htif_tick : unit -> M unit\<close>\<close>

definition htif_tick  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " htif_tick _ = (
   (if ((get_config_print_platform () )) then
      (read_reg htif_tohost_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
      return ((print_dbg (((@) (''htif::tick '') ((string_of_bits w__0)))))))
    else return () ) \<then>
   write_reg htif_tohost_ref ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word)))"


\<comment> \<open>\<open>val within_mmio_readable : mword ty32 -> integer -> bool\<close>\<close>

definition within_mmio_readable  :: "(32)Word.word \<Rightarrow> int \<Rightarrow> bool "  where 
     " within_mmio_readable (addr :: xlenbits) (width :: int) = (
   (((within_clint addr width)) \<or> (((((within_htif_readable addr width)) \<and> (((( 1 :: int)::ii) \<le> ((id0 width)))))))))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val within_mmio_writable : mword ty32 -> integer -> bool\<close>\<close>

definition within_mmio_writable  :: "(32)Word.word \<Rightarrow> int \<Rightarrow> bool "  where 
     " within_mmio_writable (addr :: xlenbits) (width :: int) = (
   (((within_clint addr width)) \<or> (((((within_htif_writable addr width)) \<and> ((((id0 width)) \<le> (( 8 :: int)::ii))))))))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val mmio_read : forall 'int8_times_n. Size 'int8_times_n => mword ty32 -> integer -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

definition mmio_read  :: "(32)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " mmio_read (addr :: xlenbits) (width :: int) = (
   if ((within_clint addr width)) then (clint_load addr width )
   else if (((((within_htif_readable addr width)) \<and> (((( 1 :: int)::ii) \<le> ((id0 width))))))) then
     (htif_load addr width )
   else return (MemException E_Load_Access_Fault))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val mmio_write : forall 'int8_times_n. Size 'int8_times_n => mword ty32 -> integer -> mword 'int8_times_n -> M (MemoryOpResult bool)\<close>\<close>

definition mmio_write  :: "(32)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad "  where 
     " mmio_write (addr :: xlenbits) (width :: int) data = (
   if ((within_clint addr width)) then clint_store addr width data
   else if (((((within_htif_writable addr width)) \<and> ((((id0 width)) \<le> (( 8 :: int)::ii)))))) then
     htif_store addr width data
   else return (MemException E_SAMO_Access_Fault))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word "


\<comment> \<open>\<open>val init_platform : unit -> M unit\<close>\<close>

definition init_platform  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " init_platform _ = (
   (write_reg htif_tohost_ref ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word)) \<then>
   write_reg htif_done_ref False) \<then>
   write_reg htif_exit_code_ref ((EXTZ (( 64 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  64 Word.word)))"


\<comment> \<open>\<open>val tick_platform : unit -> M unit\<close>\<close>

definition tick_platform  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " tick_platform _ = ( htif_tick ()  )"


\<comment> \<open>\<open>val handle_illegal : unit -> M unit\<close>\<close>

definition handle_illegal  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " handle_illegal _ = (
   (if ((plat_mtval_has_illegal_inst_bits () )) then
      (read_reg instbits_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) .  return (Some w__0))
    else return None) \<bind> (\<lambda> info . 
   (let (t :: sync_exception) =
     ((| sync_exception_trap = E_Illegal_Instr, 
        sync_exception_excinfo = info, 
        sync_exception_ext_exception = None |)) in
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__1 :: Privilege) . 
   (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
   (exception_handler w__1 (CTL_TRAP t) w__2  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 ::  32 Word.word) . 
   set_next_pc w__3))))))"


\<comment> \<open>\<open>val platform_wfi : unit -> M unit\<close>\<close>

definition platform_wfi  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " platform_wfi _ = (
   (let (_ :: unit) = (cancel_reservation () ) in
   (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__1 ::  64 Word.word) . 
   if ((zopz0zI_u w__0 w__1)) then
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
     (write_reg mtime_ref w__2 \<then>
     (read_reg mtimecmp_ref  :: ( 64 Word.word) M)) \<bind> (\<lambda> (w__3 ::  64 Word.word) . 
     write_reg mcycle_ref w__3))
   else return () ))))"


\<comment> \<open>\<open>val is_aligned_addr : mword ty32 -> integer -> bool\<close>\<close>

definition is_aligned_addr  :: "(32)Word.word \<Rightarrow> int \<Rightarrow> bool "  where 
     " is_aligned_addr (addr :: xlenbits) (width :: int) = (
   (((((Word.uint addr)) mod width)) = (( 0 :: int)::ii)))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int "


\<comment> \<open>\<open>val phys_mem_read : forall 'int8_times_n. Size 'int8_times_n => AccessType -> mword ty32 -> integer -> bool -> bool -> bool -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

definition phys_mem_read  :: " AccessType \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " phys_mem_read (t :: AccessType) (addr :: xlenbits) (width :: int) (aq :: bool) (rl :: bool) (res ::
  bool) = (
   (case  (aq, rl, res) of
     (False, False, False) =>
      (read_ram Read_plain addr width  :: (( 'int8_times_n::len)Word.word) M) \<bind> (\<lambda> (w__0 ::
        ( 'int8_times_n::len)Word.word) . 
      return (Some w__0))
   | (True, False, False) =>
      (read_ram Read_RISCV_acquire addr width  :: (( 'int8_times_n::len)Word.word) M) \<bind> (\<lambda> (w__1 ::
        ( 'int8_times_n::len)Word.word) . 
      return (Some w__1))
   | (True, True, False) =>
      (read_ram Read_RISCV_strong_acquire addr width  :: (( 'int8_times_n::len)Word.word) M) \<bind> (\<lambda> (w__2 ::
        ( 'int8_times_n::len)Word.word) . 
      return (Some w__2))
   | (False, False, True) =>
      (read_ram Read_RISCV_reserved addr width  :: (( 'int8_times_n::len)Word.word) M) \<bind> (\<lambda> (w__3 ::
        ( 'int8_times_n::len)Word.word) . 
      return (Some w__3))
   | (True, False, True) =>
      (read_ram Read_RISCV_reserved_acquire addr width  :: (( 'int8_times_n::len)Word.word) M) \<bind> (\<lambda> (w__4 ::
        ( 'int8_times_n::len)Word.word) . 
      return (Some w__4))
   | (True, True, True) =>
      (read_ram Read_RISCV_reserved_strong_acquire addr width  :: (( 'int8_times_n::len)Word.word) M) \<bind> (\<lambda> (w__5 ::
        ( 'int8_times_n::len)Word.word) . 
      return (Some w__5))
   | (False, True, False) => return None
   | (False, True, True) => return None
   ) \<bind> (\<lambda> w__6 . 
   (let result = w__6 in
   return ((case  (t, result) of
     (Execute, None) => MemException E_Fetch_Access_Fault
   | (Read, None) => MemException E_Load_Access_Fault
   | (_, None) => MemException E_SAMO_Access_Fault
   | (_, Some (v)) =>
      (let (_ :: unit) =
        (if ((get_config_print_mem () )) then
          print_dbg
            (((@) (''mem['')
                (((@) ((accessType_to_str t))
                    (((@) ('','')
                        (((@) ((string_of_bits addr))
                            (((@) (''] -> '') ((string_of_bits v))))))))))))
        else () ) in
      MemValue v)
   )))))" 
  for  t  :: " AccessType " 
  and  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  res  :: " bool "


\<comment> \<open>\<open>val checked_mem_read : forall 'int8_times_n. Size 'int8_times_n => AccessType -> mword ty32 -> integer -> bool -> bool -> bool -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

definition checked_mem_read  :: " AccessType \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " checked_mem_read (t :: AccessType) (addr :: xlenbits) (width :: int) (aq :: bool) (rl :: bool) (res ::
  bool) = (
   if ((within_mmio_readable addr width)) then (mmio_read addr width )
   else if ((within_phys_mem addr width)) then (phys_mem_read t addr width aq rl res )
   else return (MemException E_Load_Access_Fault))" 
  for  t  :: " AccessType " 
  and  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  res  :: " bool "


\<comment> \<open>\<open>val pmp_mem_read : forall 'int8_times_n. Size 'int8_times_n => AccessType -> mword ty32 -> integer -> bool -> bool -> bool -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

definition pmp_mem_read  :: " AccessType \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " pmp_mem_read (t :: AccessType) (addr :: xlenbits) (width :: int) (aq :: bool) (rl :: bool) (res ::
  bool) = (
   if ((\<not> ((plat_enable_pmp () )))) then (checked_mem_read t addr width aq rl res )
   else
     read_reg mstatus_ref \<bind> (\<lambda> (w__1 :: Mstatus) . 
     read_reg cur_privilege_ref \<bind> (\<lambda> (w__2 :: Privilege) . 
     effectivePrivilege w__1 w__2 \<bind> (\<lambda> (w__3 :: Privilege) . 
     pmpCheck addr width t w__3 \<bind> (\<lambda> (w__4 ::  ExceptionType option) . 
     (case  w__4 of
       None => (checked_mem_read t addr width aq rl res )
     | Some (e) => return (MemException e)
     ))))))" 
  for  t  :: " AccessType " 
  and  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  res  :: " bool "


\<comment> \<open>\<open>val rvfi_read : forall 'int8_times_n. Size 'int8_times_n => mword ty32 -> integer -> MemoryOpResult (mword 'int8_times_n) -> unit\<close>\<close>

definition rvfi_read  :: "(32)Word.word \<Rightarrow> int \<Rightarrow>(('int8_times_n::len)Word.word)MemoryOpResult \<Rightarrow> unit "  where 
     " rvfi_read addr width value1 = ( ()  )" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  value1  :: "(('int8_times_n::len)Word.word)MemoryOpResult "


\<comment> \<open>\<open>val mem_read : forall 'int8_times_n. Size 'int8_times_n => AccessType -> mword ty32 -> integer -> bool -> bool -> bool -> M (MemoryOpResult (mword 'int8_times_n))\<close>\<close>

definition mem_read  :: " AccessType \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((('int8_times_n::len)Word.word)MemoryOpResult),(exception))monad "  where 
     " mem_read typ1 addr width aq rl res = (
   (if ((((((aq \<or> res))) \<and> ((\<not> ((is_aligned_addr addr width))))))) then
      return (MemException E_Load_Addr_Align)
    else
      (case  (aq, rl, res) of
        (False, True, False) => throw (Error_not_implemented (''load.rl''))
      | (False, True, True) => throw (Error_not_implemented (''lr.rl''))
      | (_, _, _) => (pmp_mem_read typ1 addr width aq rl res )
      )) \<bind> (\<lambda> result . 
   (let (_ :: unit) = (rvfi_read addr width result) in
   return result)))" 
  for  typ1  :: " AccessType " 
  and  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  res  :: " bool "


\<comment> \<open>\<open>val mem_write_ea : mword ty32 -> integer -> bool -> bool -> bool -> M (MemoryOpResult unit)\<close>\<close>

definition mem_write_ea  :: "(32)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((unit)MemoryOpResult),(exception))monad "  where 
     " mem_write_ea addr width aq rl con = (
   if ((((((rl \<or> con))) \<and> ((\<not> ((is_aligned_addr addr width))))))) then
     return (MemException E_SAMO_Addr_Align)
   else
     (case  (aq, rl, con) of
       (False, False, False) => write_ram_ea Write_plain addr width \<then> return (MemValue () )
     | (False, True, False) => write_ram_ea Write_RISCV_release addr width \<then> return (MemValue () )
     | (False, False, True) =>
        write_ram_ea Write_RISCV_conditional addr width \<then> return (MemValue () )
     | (False, True, True) =>
        write_ram_ea Write_RISCV_conditional_release addr width \<then> return (MemValue () )
     | (True, False, False) => throw (Error_not_implemented (''store.aq''))
     | (True, True, False) =>
        write_ram_ea Write_RISCV_strong_release addr width \<then> return (MemValue () )
     | (True, False, True) => throw (Error_not_implemented (''sc.aq''))
     | (True, True, True) =>
        write_ram_ea Write_RISCV_conditional_strong_release addr width \<then> return (MemValue () )
     ))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  con  :: " bool "


\<comment> \<open>\<open>val rvfi_write : forall 'int8_times_n. Size 'int8_times_n => mword ty32 -> integer -> mword 'int8_times_n -> unit\<close>\<close>

definition rvfi_write  :: "(32)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> unit "  where 
     " rvfi_write addr width value1 = ( ()  )" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  value1  :: "('int8_times_n::len)Word.word "


\<comment> \<open>\<open>val phys_mem_write : forall 'int8_times_n. Size 'int8_times_n => write_kind -> mword ty32 -> integer -> mword 'int8_times_n -> unit -> M (MemoryOpResult bool)\<close>\<close>

definition phys_mem_write  :: " write_kind \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> unit \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad "  where 
     " phys_mem_write (wk :: write_kind) (addr :: xlenbits) (width :: int) data (meta :: mem_meta) = (
   (let (_ :: unit) = (rvfi_write addr width data) in
   write_ram wk addr width data meta \<bind> (\<lambda> (w__0 :: bool) . 
   (let result = (MemValue w__0) in
   (let (_ :: unit) =
     (if ((get_config_print_mem () )) then
       print_dbg
         (((@) (''mem['')
             (((@) ((string_of_bits addr)) (((@) (''] <- '') ((string_of_bits data))))))))
     else () ) in
   return result)))))" 
  for  wk  :: " write_kind " 
  and  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word " 
  and  meta  :: " unit "


\<comment> \<open>\<open>val checked_mem_write : forall 'int8_times_n. Size 'int8_times_n => write_kind -> mword ty32 -> integer -> mword 'int8_times_n -> unit -> M (MemoryOpResult bool)\<close>\<close>

definition checked_mem_write  :: " write_kind \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> unit \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad "  where 
     " checked_mem_write (wk :: write_kind) (addr :: xlenbits) (width :: int) data (meta :: mem_meta) = (
   if ((within_mmio_writable addr width)) then mmio_write addr width data
   else if ((within_phys_mem addr width)) then phys_mem_write wk addr width data meta
   else return (MemException E_SAMO_Access_Fault))" 
  for  wk  :: " write_kind " 
  and  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word " 
  and  meta  :: " unit "


\<comment> \<open>\<open>val pmp_mem_write : forall 'int8_times_n. Size 'int8_times_n => write_kind -> mword ty32 -> integer -> mword 'int8_times_n -> unit -> M (MemoryOpResult bool)\<close>\<close>

definition pmp_mem_write  :: " write_kind \<Rightarrow>(32)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> unit \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad "  where 
     " pmp_mem_write (wk :: write_kind) (addr :: xlenbits) (width :: int) data (meta :: mem_meta) = (
   if ((\<not> ((plat_enable_pmp () )))) then checked_mem_write wk addr width data meta
   else
     read_reg mstatus_ref \<bind> (\<lambda> (w__1 :: Mstatus) . 
     read_reg cur_privilege_ref \<bind> (\<lambda> (w__2 :: Privilege) . 
     effectivePrivilege w__1 w__2 \<bind> (\<lambda> (w__3 :: Privilege) . 
     pmpCheck addr width Write w__3 \<bind> (\<lambda> (w__4 ::  ExceptionType option) . 
     (case  w__4 of
       None => checked_mem_write wk addr width data meta
     | Some (e) => return (MemException e)
     ))))))" 
  for  wk  :: " write_kind " 
  and  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  data  :: "('int8_times_n::len)Word.word " 
  and  meta  :: " unit "


\<comment> \<open>\<open>val mem_write_value_meta : forall 'int8_times_n. Size 'int8_times_n => mword ty32 -> integer -> mword 'int8_times_n -> unit -> bool -> bool -> bool -> M (MemoryOpResult bool)\<close>\<close>

definition mem_write_value_meta  :: "(32)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> unit \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad "  where 
     " mem_write_value_meta addr width value1 meta aq rl con = (
   (let (_ :: unit) = (rvfi_write addr width value1) in
   if ((((((rl \<or> con))) \<and> ((\<not> ((is_aligned_addr addr width))))))) then
     return (MemException E_SAMO_Addr_Align)
   else
     (case  (aq, rl, con) of
       (False, False, False) => pmp_mem_write Write_plain addr width value1 meta
     | (False, True, False) => pmp_mem_write Write_RISCV_release addr width value1 meta
     | (False, False, True) => pmp_mem_write Write_RISCV_conditional addr width value1 meta
     | (False, True, True) => pmp_mem_write Write_RISCV_conditional_release addr width value1 meta
     | (True, True, False) => pmp_mem_write Write_RISCV_strong_release addr width value1 meta
     | (True, True, True) =>
        pmp_mem_write Write_RISCV_conditional_strong_release addr width value1 meta
     | (True, False, False) => throw (Error_not_implemented (''store.aq''))
     | (True, False, True) => throw (Error_not_implemented (''sc.aq''))
     )))" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  value1  :: "('int8_times_n::len)Word.word " 
  and  meta  :: " unit " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  con  :: " bool "


\<comment> \<open>\<open>val mem_write_value : forall 'int8_times_n. Size 'int8_times_n => mword ty32 -> integer -> mword 'int8_times_n -> bool -> bool -> bool -> M (MemoryOpResult bool)\<close>\<close>

definition mem_write_value  :: "(32)Word.word \<Rightarrow> int \<Rightarrow>('int8_times_n::len)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),((bool)MemoryOpResult),(exception))monad "  where 
     " mem_write_value addr width value1 aq rl con = (
   mem_write_value_meta addr width value1 default_meta aq rl con )" 
  for  addr  :: "(32)Word.word " 
  and  width  :: " int " 
  and  value1  :: "('int8_times_n::len)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  con  :: " bool "


definition PAGESIZE_BITS  :: " int "  where 
     " PAGESIZE_BITS = ( (( 12 :: int)::ii))"


\<comment> \<open>\<open>val Mk_PTE_Bits : mword ty8 -> PTE_Bits\<close>\<close>

definition Mk_PTE_Bits  :: "(8)Word.word \<Rightarrow> PTE_Bits "  where 
     " Mk_PTE_Bits v = (
   (| PTE_Bits_PTE_Bits_chunk_0 = ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word)) |) )" 
  for  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _get_PTE_Bits_bits : PTE_Bits -> mword ty8\<close>\<close>

definition get_PTE_Bits_bits  :: " PTE_Bits \<Rightarrow>(8)Word.word "  where 
     " get_PTE_Bits_bits v = ( (subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))" 
  for  v  :: " PTE_Bits "


\<comment> \<open>\<open>val _set_PTE_Bits_bits : register_ref regstate register_value PTE_Bits -> mword ty8 -> M unit\<close>\<close>

definition set_PTE_Bits_bits  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       PTE_Bits_PTE_Bits_chunk_0 :=
         ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   r) (( 7 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_PTE_Bits_bits : PTE_Bits -> mword ty8 -> PTE_Bits\<close>\<close>

definition update_PTE_Bits_bits  :: " PTE_Bits \<Rightarrow>(8)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_bits v x = (
   (v (|
     PTE_Bits_PTE_Bits_chunk_0 :=
       ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " PTE_Bits " 
  and  x  :: "(8)Word.word "


definition get_PTE_Bits_D  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_D v = ( (subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_D  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_D r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       PTE_Bits_PTE_Bits_chunk_0 :=
         ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   r) (( 7 :: int)::ii) (( 7 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_D  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_D v x = (
   (v (|
     PTE_Bits_PTE_Bits_chunk_0 :=
       ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 7 :: int)::ii) (( 7 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_A  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_A v = ( (subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_A  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_A r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       PTE_Bits_PTE_Bits_chunk_0 :=
         ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   r) (( 6 :: int)::ii) (( 6 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_A  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_A v x = (
   (v (|
     PTE_Bits_PTE_Bits_chunk_0 :=
       ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 6 :: int)::ii) (( 6 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_G  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_G v = ( (subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_G  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_G r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       PTE_Bits_PTE_Bits_chunk_0 :=
         ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   r) (( 5 :: int)::ii) (( 5 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_G  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_G v x = (
   (v (|
     PTE_Bits_PTE_Bits_chunk_0 :=
       ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 5 :: int)::ii) (( 5 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_U  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_U v = ( (subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_U  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_U r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       PTE_Bits_PTE_Bits_chunk_0 :=
         ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   r) (( 4 :: int)::ii) (( 4 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_U  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_U v x = (
   (v (|
     PTE_Bits_PTE_Bits_chunk_0 :=
       ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 4 :: int)::ii) (( 4 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_X  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_X v = ( (subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_X  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_X r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       PTE_Bits_PTE_Bits_chunk_0 :=
         ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   r) (( 3 :: int)::ii) (( 3 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_X  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_X v x = (
   (v (|
     PTE_Bits_PTE_Bits_chunk_0 :=
       ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 3 :: int)::ii) (( 3 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_W  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_W v = ( (subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_W  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_W r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       PTE_Bits_PTE_Bits_chunk_0 :=
         ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   r) (( 2 :: int)::ii) (( 2 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_W  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_W v x = (
   (v (|
     PTE_Bits_PTE_Bits_chunk_0 :=
       ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 2 :: int)::ii) (( 2 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_R  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_R v = ( (subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_R  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_R r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       PTE_Bits_PTE_Bits_chunk_0 :=
         ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   r) (( 1 :: int)::ii) (( 1 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_R  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_R v x = (
   (v (|
     PTE_Bits_PTE_Bits_chunk_0 :=
       ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 1 :: int)::ii) (( 1 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


definition get_PTE_Bits_V  :: " PTE_Bits \<Rightarrow>(1)Word.word "  where 
     " get_PTE_Bits_V v = ( (subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))" 
  for  v  :: " PTE_Bits "


definition set_PTE_Bits_V  :: "((regstate),(register_value),(PTE_Bits))register_ref \<Rightarrow>(1)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_PTE_Bits_V r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       PTE_Bits_PTE_Bits_chunk_0 :=
         ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   r) (( 0 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
            ::  8 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(PTE_Bits))register_ref " 
  and  v  :: "(1)Word.word "


definition update_PTE_Bits_V  :: " PTE_Bits \<Rightarrow>(1)Word.word \<Rightarrow> PTE_Bits "  where 
     " update_PTE_Bits_V v x = (
   (v (|
     PTE_Bits_PTE_Bits_chunk_0 :=
       ((update_subrange_vec_dec(PTE_Bits_PTE_Bits_chunk_0   v) (( 0 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word))
          ::  8 Word.word))|)))" 
  for  v  :: " PTE_Bits " 
  and  x  :: "(1)Word.word "


\<comment> \<open>\<open>val isPTEPtr : mword ty8 -> bool\<close>\<close>

definition isPTEPtr  :: "(8)Word.word \<Rightarrow> bool "  where 
     " isPTEPtr p = (
   (let a = (Mk_PTE_Bits p) in
   ((((((get_PTE_Bits_R a  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<and> ((((((((get_PTE_Bits_W a  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<and> (((((get_PTE_Bits_X a  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word)))))))))))" 
  for  p  :: "(8)Word.word "


\<comment> \<open>\<open>val isInvalidPTE : mword ty8 -> bool\<close>\<close>

definition isInvalidPTE  :: "(8)Word.word \<Rightarrow> bool "  where 
     " isInvalidPTE p = (
   (let a = (Mk_PTE_Bits p) in
   ((((((get_PTE_Bits_V a  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<or> ((((((((get_PTE_Bits_W a  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> (((((get_PTE_Bits_R a  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word)))))))))))" 
  for  p  :: "(8)Word.word "


\<comment> \<open>\<open>val checkPTEPermission : AccessType -> Privilege -> bool -> bool -> PTE_Bits -> M bool\<close>\<close>

fun checkPTEPermission  :: " AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> PTE_Bits \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " checkPTEPermission (Read :: AccessType) (User :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> mxr))))))))))" 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits "
|" checkPTEPermission (Write :: AccessType) (User :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> (((((get_PTE_Bits_W p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))))" 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits "
|" checkPTEPermission (ReadWrite :: AccessType) (User :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> ((((((((get_PTE_Bits_W p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> mxr)))))))))))))" 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits "
|" checkPTEPermission (Execute :: AccessType) (User :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> (((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))))" 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits "
|" checkPTEPermission (Read :: AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return (((((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<or> do_sum))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> mxr))))))))))" 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits "
|" checkPTEPermission (Write :: AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return (((((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<or> do_sum))) \<and> (((((get_PTE_Bits_W p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))))" 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits "
|" checkPTEPermission (ReadWrite :: AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return (((((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<or> do_sum))) \<and> ((((((((get_PTE_Bits_W p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> ((((((((get_PTE_Bits_R p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<or> ((((((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) \<and> mxr)))))))))))))" 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits "
|" checkPTEPermission (Execute :: AccessType) (Supervisor :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = (
      return ((((((((get_PTE_Bits_U p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))))) \<and> (((((get_PTE_Bits_X p  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))))))" 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits "
|" checkPTEPermission (_ :: AccessType) (Machine :: Privilege) (mxr :: bool) (do_sum :: bool) (p ::
  PTE_Bits) = ( internal_error (''m-mode mem perm check''))" 
  for  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  p  :: " PTE_Bits "


\<comment> \<open>\<open>val update_PTE_Bits : PTE_Bits -> AccessType -> maybe PTE_Bits\<close>\<close>

definition update_PTE_Bits  :: " PTE_Bits \<Rightarrow> AccessType \<Rightarrow>(PTE_Bits)option "  where 
     " update_PTE_Bits (p :: PTE_Bits) (a :: AccessType) = (
   (let update_d =
     (((((((a = Write))) \<or> (((a = ReadWrite)))))) \<and> (((((get_PTE_Bits_D p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word)))))) in
   (let update_a = (((get_PTE_Bits_A p  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word))) in
   if (((update_d \<or> update_a))) then
     (let np = (update_PTE_Bits_A p ((bool_to_bits True  ::  1 Word.word))) in
     (let np = (if update_d then update_PTE_Bits_D np ((bool_to_bits True  ::  1 Word.word)) else np) in
     Some np))
   else None)))" 
  for  p  :: " PTE_Bits " 
  and  a  :: " AccessType "


\<comment> \<open>\<open>val PTW_Error_of_num : integer -> PTW_Error\<close>\<close>

definition PTW_Error_of_num  :: " int \<Rightarrow> PTW_Error "  where 
     " PTW_Error_of_num arg1 = (
   (let p00 = arg1 in
   if (((p00 = (( 0 :: int)::ii)))) then PTW_Access
   else if (((p00 = (( 1 :: int)::ii)))) then PTW_Invalid_PTE
   else if (((p00 = (( 2 :: int)::ii)))) then PTW_No_Permission
   else if (((p00 = (( 3 :: int)::ii)))) then PTW_Misaligned
   else PTW_PTE_Update))" 
  for  arg1  :: " int "


\<comment> \<open>\<open>val num_of_PTW_Error : PTW_Error -> integer\<close>\<close>

fun num_of_PTW_Error  :: " PTW_Error \<Rightarrow> int "  where 
     " num_of_PTW_Error PTW_Access = ( (( 0 :: int)::ii))"
|" num_of_PTW_Error PTW_Invalid_PTE = ( (( 1 :: int)::ii))"
|" num_of_PTW_Error PTW_No_Permission = ( (( 2 :: int)::ii))"
|" num_of_PTW_Error PTW_Misaligned = ( (( 3 :: int)::ii))"
|" num_of_PTW_Error PTW_PTE_Update = ( (( 4 :: int)::ii))"


\<comment> \<open>\<open>val ptw_error_to_str : PTW_Error -> string\<close>\<close>

fun ptw_error_to_str  :: " PTW_Error \<Rightarrow> string "  where 
     " ptw_error_to_str PTW_Access = ( (''mem-access-error''))"
|" ptw_error_to_str PTW_Invalid_PTE = ( (''invalid-pte''))"
|" ptw_error_to_str PTW_No_Permission = ( (''no-permission''))"
|" ptw_error_to_str PTW_Misaligned = ( (''misaligned-superpage''))"
|" ptw_error_to_str PTW_PTE_Update = ( (''pte-update-needed''))"


\<comment> \<open>\<open>val translationException : AccessType -> PTW_Error -> ExceptionType\<close>\<close>

fun translationException  :: " AccessType \<Rightarrow> PTW_Error \<Rightarrow> ExceptionType "  where 
     " translationException (ReadWrite :: AccessType) (PTW_Access :: PTW_Error) = ( E_SAMO_Access_Fault )"
|" translationException (ReadWrite :: AccessType) (_ :: PTW_Error) = ( E_SAMO_Page_Fault )"
|" translationException (Read :: AccessType) (PTW_Access :: PTW_Error) = ( E_Load_Access_Fault )"
|" translationException (Read :: AccessType) (_ :: PTW_Error) = ( E_Load_Page_Fault )"
|" translationException (Write :: AccessType) (PTW_Access :: PTW_Error) = ( E_SAMO_Access_Fault )"
|" translationException (Write :: AccessType) (_ :: PTW_Error) = ( E_SAMO_Page_Fault )"
|" translationException (Fetch :: AccessType) (PTW_Access :: PTW_Error) = ( E_Fetch_Access_Fault )" 
  for  Fetch  :: " AccessType "
|" translationException (Fetch :: AccessType) (_ :: PTW_Error) = ( E_Fetch_Page_Fault )" 
  for  Fetch  :: " AccessType "


\<comment> \<open>\<open>val curAsid32 : mword ty32 -> mword ty9\<close>\<close>

definition curAsid32  :: "(32)Word.word \<Rightarrow>(9)Word.word "  where 
     " curAsid32 satp1 = (
   (let s = (Mk_Satp32 satp1) in
   (get_Satp32_Asid s  ::  9 Word.word)))" 
  for  satp1  :: "(32)Word.word "


\<comment> \<open>\<open>val curPTB32 : mword ty32 -> mword ty34\<close>\<close>

definition curPTB32  :: "(32)Word.word \<Rightarrow>(34)Word.word "  where 
     " curPTB32 satp1 = (
   (let (s :: Satp32) = (Mk_Satp32 satp1) in
   (shiftl ((EXTZ (( 34 :: int)::ii) ((get_Satp32_PPN s  ::  22 Word.word))  ::  34 Word.word)) PAGESIZE_BITS
     ::  34 Word.word)))" 
  for  satp1  :: "(32)Word.word "


definition SV32_LEVEL_BITS  :: " int "  where 
     " SV32_LEVEL_BITS = ( (( 10 :: int)::ii))"


definition SV32_LEVELS  :: " int "  where 
     " SV32_LEVELS = ( (( 2 :: int)::ii))"


definition PTE32_LOG_SIZE  :: " int "  where 
     " PTE32_LOG_SIZE = ( (( 2 :: int)::ii))"


definition PTE32_SIZE  :: " int "  where 
     " PTE32_SIZE = ( (( 4 :: int)::ii))"


\<comment> \<open>\<open>val Mk_SV32_Vaddr : mword ty32 -> SV32_Vaddr\<close>\<close>

definition Mk_SV32_Vaddr  :: "(32)Word.word \<Rightarrow> SV32_Vaddr "  where 
     " Mk_SV32_Vaddr v = (
   (| SV32_Vaddr_SV32_Vaddr_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_SV32_Vaddr_bits : SV32_Vaddr -> mword ty32\<close>\<close>

definition get_SV32_Vaddr_bits  :: " SV32_Vaddr \<Rightarrow>(32)Word.word "  where 
     " get_SV32_Vaddr_bits v = (
   (subrange_vec_dec(SV32_Vaddr_SV32_Vaddr_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " SV32_Vaddr "


\<comment> \<open>\<open>val _set_SV32_Vaddr_bits : register_ref regstate register_value SV32_Vaddr -> mword ty32 -> M unit\<close>\<close>

definition set_SV32_Vaddr_bits  :: "((regstate),(register_value),(SV32_Vaddr))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV32_Vaddr_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV32_Vaddr_SV32_Vaddr_chunk_0 :=
         ((update_subrange_vec_dec(SV32_Vaddr_SV32_Vaddr_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV32_Vaddr))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_SV32_Vaddr_bits : SV32_Vaddr -> mword ty32 -> SV32_Vaddr\<close>\<close>

definition update_SV32_Vaddr_bits  :: " SV32_Vaddr \<Rightarrow>(32)Word.word \<Rightarrow> SV32_Vaddr "  where 
     " update_SV32_Vaddr_bits v x = (
   (v (|
     SV32_Vaddr_SV32_Vaddr_chunk_0 :=
       ((update_subrange_vec_dec(SV32_Vaddr_SV32_Vaddr_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " SV32_Vaddr " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_SV32_Vaddr_VPNi : SV32_Vaddr -> mword ty20\<close>\<close>

definition get_SV32_Vaddr_VPNi  :: " SV32_Vaddr \<Rightarrow>(20)Word.word "  where 
     " get_SV32_Vaddr_VPNi v = (
   (subrange_vec_dec(SV32_Vaddr_SV32_Vaddr_chunk_0   v) (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word))" 
  for  v  :: " SV32_Vaddr "


\<comment> \<open>\<open>val _set_SV32_Vaddr_VPNi : register_ref regstate register_value SV32_Vaddr -> mword ty20 -> M unit\<close>\<close>

definition set_SV32_Vaddr_VPNi  :: "((regstate),(register_value),(SV32_Vaddr))register_ref \<Rightarrow>(20)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV32_Vaddr_VPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV32_Vaddr_SV32_Vaddr_chunk_0 :=
         ((update_subrange_vec_dec(SV32_Vaddr_SV32_Vaddr_chunk_0   r) (( 31 :: int)::ii) (( 12 :: int)::ii)
             ((subrange_vec_dec v (( 19 :: int)::ii) (( 0 :: int)::ii)  ::  20 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV32_Vaddr))register_ref " 
  and  v  :: "(20)Word.word "


\<comment> \<open>\<open>val _update_SV32_Vaddr_VPNi : SV32_Vaddr -> mword ty20 -> SV32_Vaddr\<close>\<close>

definition update_SV32_Vaddr_VPNi  :: " SV32_Vaddr \<Rightarrow>(20)Word.word \<Rightarrow> SV32_Vaddr "  where 
     " update_SV32_Vaddr_VPNi v x = (
   (v (|
     SV32_Vaddr_SV32_Vaddr_chunk_0 :=
       ((update_subrange_vec_dec(SV32_Vaddr_SV32_Vaddr_chunk_0   v) (( 31 :: int)::ii) (( 12 :: int)::ii)
           ((subrange_vec_dec x (( 19 :: int)::ii) (( 0 :: int)::ii)  ::  20 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " SV32_Vaddr " 
  and  x  :: "(20)Word.word "


\<comment> \<open>\<open>val _update_SV48_Vaddr_VPNi : SV48_Vaddr -> mword ty27 -> SV48_Vaddr\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_Vaddr_VPNi : SV48_Vaddr -> mword ty27\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_Vaddr_VPNi : register_ref regstate register_value SV48_Vaddr -> mword ty27 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_SV32_Vaddr_PgOfs : SV32_Vaddr -> mword ty12\<close>\<close>

definition get_SV32_Vaddr_PgOfs  :: " SV32_Vaddr \<Rightarrow>(12)Word.word "  where 
     " get_SV32_Vaddr_PgOfs v = (
   (subrange_vec_dec(SV32_Vaddr_SV32_Vaddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))" 
  for  v  :: " SV32_Vaddr "


\<comment> \<open>\<open>val _set_SV32_Vaddr_PgOfs : register_ref regstate register_value SV32_Vaddr -> mword ty12 -> M unit\<close>\<close>

definition set_SV32_Vaddr_PgOfs  :: "((regstate),(register_value),(SV32_Vaddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV32_Vaddr_PgOfs r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV32_Vaddr_SV32_Vaddr_chunk_0 :=
         ((update_subrange_vec_dec(SV32_Vaddr_SV32_Vaddr_chunk_0   r) (( 11 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV32_Vaddr))register_ref " 
  and  v  :: "(12)Word.word "


\<comment> \<open>\<open>val _update_SV32_Vaddr_PgOfs : SV32_Vaddr -> mword ty12 -> SV32_Vaddr\<close>\<close>

definition update_SV32_Vaddr_PgOfs  :: " SV32_Vaddr \<Rightarrow>(12)Word.word \<Rightarrow> SV32_Vaddr "  where 
     " update_SV32_Vaddr_PgOfs v x = (
   (v (|
     SV32_Vaddr_SV32_Vaddr_chunk_0 :=
       ((update_subrange_vec_dec(SV32_Vaddr_SV32_Vaddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " SV32_Vaddr " 
  and  x  :: "(12)Word.word "


\<comment> \<open>\<open>val _update_SV48_Paddr_PgOfs : SV48_Paddr -> mword ty12 -> SV48_Paddr\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_Paddr_PgOfs : SV48_Paddr -> mword ty12\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_Paddr_PgOfs : register_ref regstate register_value SV48_Paddr -> mword ty12 -> M unit\<close>\<close>

\<comment> \<open>\<open>val Mk_SV32_Paddr : mword ty34 -> SV32_Paddr\<close>\<close>

definition Mk_SV32_Paddr  :: "(34)Word.word \<Rightarrow> SV32_Paddr "  where 
     " Mk_SV32_Paddr v = (
   (| SV32_Paddr_SV32_Paddr_chunk_0 = ((subrange_vec_dec v (( 33 :: int)::ii) (( 0 :: int)::ii)  ::  34 Word.word)) |) )" 
  for  v  :: "(34)Word.word "


\<comment> \<open>\<open>val _get_SV32_Paddr_bits : SV32_Paddr -> mword ty34\<close>\<close>

definition get_SV32_Paddr_bits  :: " SV32_Paddr \<Rightarrow>(34)Word.word "  where 
     " get_SV32_Paddr_bits v = (
   (subrange_vec_dec(SV32_Paddr_SV32_Paddr_chunk_0   v) (( 33 :: int)::ii) (( 0 :: int)::ii)  ::  34 Word.word))" 
  for  v  :: " SV32_Paddr "


\<comment> \<open>\<open>val _set_SV32_Paddr_bits : register_ref regstate register_value SV32_Paddr -> mword ty34 -> M unit\<close>\<close>

definition set_SV32_Paddr_bits  :: "((regstate),(register_value),(SV32_Paddr))register_ref \<Rightarrow>(34)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV32_Paddr_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV32_Paddr_SV32_Paddr_chunk_0 :=
         ((update_subrange_vec_dec(SV32_Paddr_SV32_Paddr_chunk_0   r) (( 33 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 33 :: int)::ii) (( 0 :: int)::ii)  ::  34 Word.word))
            ::  34 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV32_Paddr))register_ref " 
  and  v  :: "(34)Word.word "


\<comment> \<open>\<open>val _update_SV32_Paddr_bits : SV32_Paddr -> mword ty34 -> SV32_Paddr\<close>\<close>

definition update_SV32_Paddr_bits  :: " SV32_Paddr \<Rightarrow>(34)Word.word \<Rightarrow> SV32_Paddr "  where 
     " update_SV32_Paddr_bits v x = (
   (v (|
     SV32_Paddr_SV32_Paddr_chunk_0 :=
       ((update_subrange_vec_dec(SV32_Paddr_SV32_Paddr_chunk_0   v) (( 33 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 33 :: int)::ii) (( 0 :: int)::ii)  ::  34 Word.word))
          ::  34 Word.word))|)))" 
  for  v  :: " SV32_Paddr " 
  and  x  :: "(34)Word.word "


\<comment> \<open>\<open>val _get_SV32_Paddr_PPNi : SV32_Paddr -> mword ty22\<close>\<close>

definition get_SV32_Paddr_PPNi  :: " SV32_Paddr \<Rightarrow>(22)Word.word "  where 
     " get_SV32_Paddr_PPNi v = (
   (subrange_vec_dec(SV32_Paddr_SV32_Paddr_chunk_0   v) (( 33 :: int)::ii) (( 12 :: int)::ii)  ::  22 Word.word))" 
  for  v  :: " SV32_Paddr "


\<comment> \<open>\<open>val _set_SV32_Paddr_PPNi : register_ref regstate register_value SV32_Paddr -> mword ty22 -> M unit\<close>\<close>

definition set_SV32_Paddr_PPNi  :: "((regstate),(register_value),(SV32_Paddr))register_ref \<Rightarrow>(22)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV32_Paddr_PPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV32_Paddr_SV32_Paddr_chunk_0 :=
         ((update_subrange_vec_dec(SV32_Paddr_SV32_Paddr_chunk_0   r) (( 33 :: int)::ii) (( 12 :: int)::ii)
             ((subrange_vec_dec v (( 21 :: int)::ii) (( 0 :: int)::ii)  ::  22 Word.word))
            ::  34 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV32_Paddr))register_ref " 
  and  v  :: "(22)Word.word "


\<comment> \<open>\<open>val _update_SV32_Paddr_PPNi : SV32_Paddr -> mword ty22 -> SV32_Paddr\<close>\<close>

definition update_SV32_Paddr_PPNi  :: " SV32_Paddr \<Rightarrow>(22)Word.word \<Rightarrow> SV32_Paddr "  where 
     " update_SV32_Paddr_PPNi v x = (
   (v (|
     SV32_Paddr_SV32_Paddr_chunk_0 :=
       ((update_subrange_vec_dec(SV32_Paddr_SV32_Paddr_chunk_0   v) (( 33 :: int)::ii) (( 12 :: int)::ii)
           ((subrange_vec_dec x (( 21 :: int)::ii) (( 0 :: int)::ii)  ::  22 Word.word))
          ::  34 Word.word))|)))" 
  for  v  :: " SV32_Paddr " 
  and  x  :: "(22)Word.word "


\<comment> \<open>\<open>val _update_SV48_PTE_PPNi : SV48_PTE -> mword ty44 -> SV48_PTE\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_PTE_PPNi : SV48_PTE -> mword ty44\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_PTE_PPNi : register_ref regstate register_value SV48_PTE -> mword ty44 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_SV32_Paddr_PgOfs : SV32_Paddr -> mword ty12\<close>\<close>

definition get_SV32_Paddr_PgOfs  :: " SV32_Paddr \<Rightarrow>(12)Word.word "  where 
     " get_SV32_Paddr_PgOfs v = (
   (subrange_vec_dec(SV32_Paddr_SV32_Paddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))" 
  for  v  :: " SV32_Paddr "


\<comment> \<open>\<open>val _set_SV32_Paddr_PgOfs : register_ref regstate register_value SV32_Paddr -> mword ty12 -> M unit\<close>\<close>

definition set_SV32_Paddr_PgOfs  :: "((regstate),(register_value),(SV32_Paddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV32_Paddr_PgOfs r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV32_Paddr_SV32_Paddr_chunk_0 :=
         ((update_subrange_vec_dec(SV32_Paddr_SV32_Paddr_chunk_0   r) (( 11 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
            ::  34 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV32_Paddr))register_ref " 
  and  v  :: "(12)Word.word "


\<comment> \<open>\<open>val _update_SV32_Paddr_PgOfs : SV32_Paddr -> mword ty12 -> SV32_Paddr\<close>\<close>

definition update_SV32_Paddr_PgOfs  :: " SV32_Paddr \<Rightarrow>(12)Word.word \<Rightarrow> SV32_Paddr "  where 
     " update_SV32_Paddr_PgOfs v x = (
   (v (|
     SV32_Paddr_SV32_Paddr_chunk_0 :=
       ((update_subrange_vec_dec(SV32_Paddr_SV32_Paddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
          ::  34 Word.word))|)))" 
  for  v  :: " SV32_Paddr " 
  and  x  :: "(12)Word.word "


\<comment> \<open>\<open>val Mk_SV32_PTE : mword ty32 -> SV32_PTE\<close>\<close>

definition Mk_SV32_PTE  :: "(32)Word.word \<Rightarrow> SV32_PTE "  where 
     " Mk_SV32_PTE v = (
   (| SV32_PTE_SV32_PTE_chunk_0 = ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) |) )" 
  for  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_SV32_PTE_bits : SV32_PTE -> mword ty32\<close>\<close>

definition get_SV32_PTE_bits  :: " SV32_PTE \<Rightarrow>(32)Word.word "  where 
     " get_SV32_PTE_bits v = (
   (subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  v  :: " SV32_PTE "


\<comment> \<open>\<open>val _set_SV32_PTE_bits : register_ref regstate register_value SV32_PTE -> mword ty32 -> M unit\<close>\<close>

definition set_SV32_PTE_bits  :: "((regstate),(register_value),(SV32_PTE))register_ref \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV32_PTE_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV32_PTE_SV32_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   r) (( 31 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV32_PTE))register_ref " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val _update_SV32_PTE_bits : SV32_PTE -> mword ty32 -> SV32_PTE\<close>\<close>

definition update_SV32_PTE_bits  :: " SV32_PTE \<Rightarrow>(32)Word.word \<Rightarrow> SV32_PTE "  where 
     " update_SV32_PTE_bits v x = (
   (v (|
     SV32_PTE_SV32_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   v) (( 31 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " SV32_PTE " 
  and  x  :: "(32)Word.word "


\<comment> \<open>\<open>val _get_SV32_PTE_PPNi : SV32_PTE -> mword ty22\<close>\<close>

definition get_SV32_PTE_PPNi  :: " SV32_PTE \<Rightarrow>(22)Word.word "  where 
     " get_SV32_PTE_PPNi v = (
   (subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   v) (( 31 :: int)::ii) (( 10 :: int)::ii)  ::  22 Word.word))" 
  for  v  :: " SV32_PTE "


\<comment> \<open>\<open>val _set_SV32_PTE_PPNi : register_ref regstate register_value SV32_PTE -> mword ty22 -> M unit\<close>\<close>

definition set_SV32_PTE_PPNi  :: "((regstate),(register_value),(SV32_PTE))register_ref \<Rightarrow>(22)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV32_PTE_PPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV32_PTE_SV32_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   r) (( 31 :: int)::ii) (( 10 :: int)::ii)
             ((subrange_vec_dec v (( 21 :: int)::ii) (( 0 :: int)::ii)  ::  22 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV32_PTE))register_ref " 
  and  v  :: "(22)Word.word "


\<comment> \<open>\<open>val _update_SV32_PTE_PPNi : SV32_PTE -> mword ty22 -> SV32_PTE\<close>\<close>

definition update_SV32_PTE_PPNi  :: " SV32_PTE \<Rightarrow>(22)Word.word \<Rightarrow> SV32_PTE "  where 
     " update_SV32_PTE_PPNi v x = (
   (v (|
     SV32_PTE_SV32_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   v) (( 31 :: int)::ii) (( 10 :: int)::ii)
           ((subrange_vec_dec x (( 21 :: int)::ii) (( 0 :: int)::ii)  ::  22 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " SV32_PTE " 
  and  x  :: "(22)Word.word "


\<comment> \<open>\<open>val _get_SV32_PTE_RSW : SV32_PTE -> mword ty2\<close>\<close>

definition get_SV32_PTE_RSW  :: " SV32_PTE \<Rightarrow>(2)Word.word "  where 
     " get_SV32_PTE_RSW v = ( (subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   v) (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))" 
  for  v  :: " SV32_PTE "


\<comment> \<open>\<open>val _set_SV32_PTE_RSW : register_ref regstate register_value SV32_PTE -> mword ty2 -> M unit\<close>\<close>

definition set_SV32_PTE_RSW  :: "((regstate),(register_value),(SV32_PTE))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV32_PTE_RSW r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV32_PTE_SV32_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   r) (( 9 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV32_PTE))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_SV32_PTE_RSW : SV32_PTE -> mword ty2 -> SV32_PTE\<close>\<close>

definition update_SV32_PTE_RSW  :: " SV32_PTE \<Rightarrow>(2)Word.word \<Rightarrow> SV32_PTE "  where 
     " update_SV32_PTE_RSW v x = (
   (v (|
     SV32_PTE_SV32_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   v) (( 9 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " SV32_PTE " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_SV48_PTE_RSW : SV48_PTE -> mword ty2 -> SV48_PTE\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_PTE_RSW : SV48_PTE -> mword ty2\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_PTE_RSW : register_ref regstate register_value SV48_PTE -> mword ty2 -> M unit\<close>\<close>

\<comment> \<open>\<open>val _get_SV32_PTE_BITS : SV32_PTE -> mword ty8\<close>\<close>

definition get_SV32_PTE_BITS  :: " SV32_PTE \<Rightarrow>(8)Word.word "  where 
     " get_SV32_PTE_BITS v = ( (subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))" 
  for  v  :: " SV32_PTE "


\<comment> \<open>\<open>val _set_SV32_PTE_BITS : register_ref regstate register_value SV32_PTE -> mword ty8 -> M unit\<close>\<close>

definition set_SV32_PTE_BITS  :: "((regstate),(register_value),(SV32_PTE))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV32_PTE_BITS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV32_PTE_SV32_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   r) (( 7 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  32 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV32_PTE))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_SV32_PTE_BITS : SV32_PTE -> mword ty8 -> SV32_PTE\<close>\<close>

definition update_SV32_PTE_BITS  :: " SV32_PTE \<Rightarrow>(8)Word.word \<Rightarrow> SV32_PTE "  where 
     " update_SV32_PTE_BITS v x = (
   (v (|
     SV32_PTE_SV32_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV32_PTE_SV32_PTE_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  32 Word.word))|)))" 
  for  v  :: " SV32_PTE " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_SV48_PTE_BITS : SV48_PTE -> mword ty8 -> SV48_PTE\<close>\<close>

\<comment> \<open>\<open>val _get_SV48_PTE_BITS : SV48_PTE -> mword ty8\<close>\<close>

\<comment> \<open>\<open>val _set_SV48_PTE_BITS : register_ref regstate register_value SV48_PTE -> mword ty8 -> M unit\<close>\<close>

\<comment> \<open>\<open>val curAsid64 : mword ty64 -> mword ty16\<close>\<close>

definition curAsid64  :: "(64)Word.word \<Rightarrow>(16)Word.word "  where 
     " curAsid64 satp1 = (
   (let s = (Mk_Satp64 satp1) in
   (get_Satp64_Asid s  ::  16 Word.word)))" 
  for  satp1  :: "(64)Word.word "


\<comment> \<open>\<open>val curPTB64 : mword ty64 -> mword ty56\<close>\<close>

definition curPTB64  :: "(64)Word.word \<Rightarrow>(56)Word.word "  where 
     " curPTB64 satp1 = (
   (let s = (Mk_Satp64 satp1) in
   (shiftl ((EXTZ (( 56 :: int)::ii) ((get_Satp64_PPN s  ::  44 Word.word))  ::  56 Word.word)) PAGESIZE_BITS
     ::  56 Word.word)))" 
  for  satp1  :: "(64)Word.word "


definition SV39_LEVEL_BITS  :: " int "  where 
     " SV39_LEVEL_BITS = ( (( 9 :: int)::ii))"


definition SV39_LEVELS  :: " int "  where 
     " SV39_LEVELS = ( (( 3 :: int)::ii))"


definition PTE39_LOG_SIZE  :: " int "  where 
     " PTE39_LOG_SIZE = ( (( 3 :: int)::ii))"


definition PTE39_SIZE  :: " int "  where 
     " PTE39_SIZE = ( (( 8 :: int)::ii))"


\<comment> \<open>\<open>val Mk_SV39_Vaddr : mword ty39 -> SV39_Vaddr\<close>\<close>

definition Mk_SV39_Vaddr  :: "(39)Word.word \<Rightarrow> SV39_Vaddr "  where 
     " Mk_SV39_Vaddr v = (
   (| SV39_Vaddr_SV39_Vaddr_chunk_0 = ((subrange_vec_dec v (( 38 :: int)::ii) (( 0 :: int)::ii)  ::  39 Word.word)) |) )" 
  for  v  :: "(39)Word.word "


\<comment> \<open>\<open>val _get_SV39_Vaddr_bits : SV39_Vaddr -> mword ty39\<close>\<close>

definition get_SV39_Vaddr_bits  :: " SV39_Vaddr \<Rightarrow>(39)Word.word "  where 
     " get_SV39_Vaddr_bits v = (
   (subrange_vec_dec(SV39_Vaddr_SV39_Vaddr_chunk_0   v) (( 38 :: int)::ii) (( 0 :: int)::ii)  ::  39 Word.word))" 
  for  v  :: " SV39_Vaddr "


\<comment> \<open>\<open>val _set_SV39_Vaddr_bits : register_ref regstate register_value SV39_Vaddr -> mword ty39 -> M unit\<close>\<close>

definition set_SV39_Vaddr_bits  :: "((regstate),(register_value),(SV39_Vaddr))register_ref \<Rightarrow>(39)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Vaddr_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV39_Vaddr_SV39_Vaddr_chunk_0 :=
         ((update_subrange_vec_dec(SV39_Vaddr_SV39_Vaddr_chunk_0   r) (( 38 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 38 :: int)::ii) (( 0 :: int)::ii)  ::  39 Word.word))
            ::  39 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV39_Vaddr))register_ref " 
  and  v  :: "(39)Word.word "


\<comment> \<open>\<open>val _update_SV39_Vaddr_bits : SV39_Vaddr -> mword ty39 -> SV39_Vaddr\<close>\<close>

definition update_SV39_Vaddr_bits  :: " SV39_Vaddr \<Rightarrow>(39)Word.word \<Rightarrow> SV39_Vaddr "  where 
     " update_SV39_Vaddr_bits v x = (
   (v (|
     SV39_Vaddr_SV39_Vaddr_chunk_0 :=
       ((update_subrange_vec_dec(SV39_Vaddr_SV39_Vaddr_chunk_0   v) (( 38 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 38 :: int)::ii) (( 0 :: int)::ii)  ::  39 Word.word))
          ::  39 Word.word))|)))" 
  for  v  :: " SV39_Vaddr " 
  and  x  :: "(39)Word.word "


\<comment> \<open>\<open>val _get_SV39_Vaddr_VPNi : SV39_Vaddr -> mword ty27\<close>\<close>

definition get_SV39_Vaddr_VPNi  :: " SV39_Vaddr \<Rightarrow>(27)Word.word "  where 
     " get_SV39_Vaddr_VPNi v = (
   (subrange_vec_dec(SV39_Vaddr_SV39_Vaddr_chunk_0   v) (( 38 :: int)::ii) (( 12 :: int)::ii)  ::  27 Word.word))" 
  for  v  :: " SV39_Vaddr "


\<comment> \<open>\<open>val _set_SV39_Vaddr_VPNi : register_ref regstate register_value SV39_Vaddr -> mword ty27 -> M unit\<close>\<close>

definition set_SV39_Vaddr_VPNi  :: "((regstate),(register_value),(SV39_Vaddr))register_ref \<Rightarrow>(27)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Vaddr_VPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV39_Vaddr_SV39_Vaddr_chunk_0 :=
         ((update_subrange_vec_dec(SV39_Vaddr_SV39_Vaddr_chunk_0   r) (( 38 :: int)::ii) (( 12 :: int)::ii)
             ((subrange_vec_dec v (( 26 :: int)::ii) (( 0 :: int)::ii)  ::  27 Word.word))
            ::  39 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV39_Vaddr))register_ref " 
  and  v  :: "(27)Word.word "


\<comment> \<open>\<open>val _update_SV39_Vaddr_VPNi : SV39_Vaddr -> mword ty27 -> SV39_Vaddr\<close>\<close>

definition update_SV39_Vaddr_VPNi  :: " SV39_Vaddr \<Rightarrow>(27)Word.word \<Rightarrow> SV39_Vaddr "  where 
     " update_SV39_Vaddr_VPNi v x = (
   (v (|
     SV39_Vaddr_SV39_Vaddr_chunk_0 :=
       ((update_subrange_vec_dec(SV39_Vaddr_SV39_Vaddr_chunk_0   v) (( 38 :: int)::ii) (( 12 :: int)::ii)
           ((subrange_vec_dec x (( 26 :: int)::ii) (( 0 :: int)::ii)  ::  27 Word.word))
          ::  39 Word.word))|)))" 
  for  v  :: " SV39_Vaddr " 
  and  x  :: "(27)Word.word "


\<comment> \<open>\<open>val _get_SV39_Vaddr_PgOfs : SV39_Vaddr -> mword ty12\<close>\<close>

definition get_SV39_Vaddr_PgOfs  :: " SV39_Vaddr \<Rightarrow>(12)Word.word "  where 
     " get_SV39_Vaddr_PgOfs v = (
   (subrange_vec_dec(SV39_Vaddr_SV39_Vaddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))" 
  for  v  :: " SV39_Vaddr "


\<comment> \<open>\<open>val _set_SV39_Vaddr_PgOfs : register_ref regstate register_value SV39_Vaddr -> mword ty12 -> M unit\<close>\<close>

definition set_SV39_Vaddr_PgOfs  :: "((regstate),(register_value),(SV39_Vaddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Vaddr_PgOfs r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV39_Vaddr_SV39_Vaddr_chunk_0 :=
         ((update_subrange_vec_dec(SV39_Vaddr_SV39_Vaddr_chunk_0   r) (( 11 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
            ::  39 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV39_Vaddr))register_ref " 
  and  v  :: "(12)Word.word "


\<comment> \<open>\<open>val _update_SV39_Vaddr_PgOfs : SV39_Vaddr -> mword ty12 -> SV39_Vaddr\<close>\<close>

definition update_SV39_Vaddr_PgOfs  :: " SV39_Vaddr \<Rightarrow>(12)Word.word \<Rightarrow> SV39_Vaddr "  where 
     " update_SV39_Vaddr_PgOfs v x = (
   (v (|
     SV39_Vaddr_SV39_Vaddr_chunk_0 :=
       ((update_subrange_vec_dec(SV39_Vaddr_SV39_Vaddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
          ::  39 Word.word))|)))" 
  for  v  :: " SV39_Vaddr " 
  and  x  :: "(12)Word.word "


\<comment> \<open>\<open>val Mk_SV39_Paddr : mword ty56 -> SV39_Paddr\<close>\<close>

definition Mk_SV39_Paddr  :: "(56)Word.word \<Rightarrow> SV39_Paddr "  where 
     " Mk_SV39_Paddr v = (
   (| SV39_Paddr_SV39_Paddr_chunk_0 = ((subrange_vec_dec v (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word)) |) )" 
  for  v  :: "(56)Word.word "


\<comment> \<open>\<open>val _get_SV39_Paddr_bits : SV39_Paddr -> mword ty56\<close>\<close>

definition get_SV39_Paddr_bits  :: " SV39_Paddr \<Rightarrow>(56)Word.word "  where 
     " get_SV39_Paddr_bits v = (
   (subrange_vec_dec(SV39_Paddr_SV39_Paddr_chunk_0   v) (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))" 
  for  v  :: " SV39_Paddr "


\<comment> \<open>\<open>val _set_SV39_Paddr_bits : register_ref regstate register_value SV39_Paddr -> mword ty56 -> M unit\<close>\<close>

definition set_SV39_Paddr_bits  :: "((regstate),(register_value),(SV39_Paddr))register_ref \<Rightarrow>(56)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Paddr_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV39_Paddr_SV39_Paddr_chunk_0 :=
         ((update_subrange_vec_dec(SV39_Paddr_SV39_Paddr_chunk_0   r) (( 55 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))
            ::  56 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV39_Paddr))register_ref " 
  and  v  :: "(56)Word.word "


\<comment> \<open>\<open>val _update_SV39_Paddr_bits : SV39_Paddr -> mword ty56 -> SV39_Paddr\<close>\<close>

definition update_SV39_Paddr_bits  :: " SV39_Paddr \<Rightarrow>(56)Word.word \<Rightarrow> SV39_Paddr "  where 
     " update_SV39_Paddr_bits v x = (
   (v (|
     SV39_Paddr_SV39_Paddr_chunk_0 :=
       ((update_subrange_vec_dec(SV39_Paddr_SV39_Paddr_chunk_0   v) (( 55 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))
          ::  56 Word.word))|)))" 
  for  v  :: " SV39_Paddr " 
  and  x  :: "(56)Word.word "


\<comment> \<open>\<open>val _get_SV39_Paddr_PPNi : SV39_Paddr -> mword ty44\<close>\<close>

definition get_SV39_Paddr_PPNi  :: " SV39_Paddr \<Rightarrow>(44)Word.word "  where 
     " get_SV39_Paddr_PPNi v = (
   (subrange_vec_dec(SV39_Paddr_SV39_Paddr_chunk_0   v) (( 55 :: int)::ii) (( 12 :: int)::ii)  ::  44 Word.word))" 
  for  v  :: " SV39_Paddr "


\<comment> \<open>\<open>val _set_SV39_Paddr_PPNi : register_ref regstate register_value SV39_Paddr -> mword ty44 -> M unit\<close>\<close>

definition set_SV39_Paddr_PPNi  :: "((regstate),(register_value),(SV39_Paddr))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Paddr_PPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV39_Paddr_SV39_Paddr_chunk_0 :=
         ((update_subrange_vec_dec(SV39_Paddr_SV39_Paddr_chunk_0   r) (( 55 :: int)::ii) (( 12 :: int)::ii)
             ((subrange_vec_dec v (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))
            ::  56 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV39_Paddr))register_ref " 
  and  v  :: "(44)Word.word "


\<comment> \<open>\<open>val _update_SV39_Paddr_PPNi : SV39_Paddr -> mword ty44 -> SV39_Paddr\<close>\<close>

definition update_SV39_Paddr_PPNi  :: " SV39_Paddr \<Rightarrow>(44)Word.word \<Rightarrow> SV39_Paddr "  where 
     " update_SV39_Paddr_PPNi v x = (
   (v (|
     SV39_Paddr_SV39_Paddr_chunk_0 :=
       ((update_subrange_vec_dec(SV39_Paddr_SV39_Paddr_chunk_0   v) (( 55 :: int)::ii) (( 12 :: int)::ii)
           ((subrange_vec_dec x (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))
          ::  56 Word.word))|)))" 
  for  v  :: " SV39_Paddr " 
  and  x  :: "(44)Word.word "


\<comment> \<open>\<open>val _get_SV39_Paddr_PgOfs : SV39_Paddr -> mword ty12\<close>\<close>

definition get_SV39_Paddr_PgOfs  :: " SV39_Paddr \<Rightarrow>(12)Word.word "  where 
     " get_SV39_Paddr_PgOfs v = (
   (subrange_vec_dec(SV39_Paddr_SV39_Paddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))" 
  for  v  :: " SV39_Paddr "


\<comment> \<open>\<open>val _set_SV39_Paddr_PgOfs : register_ref regstate register_value SV39_Paddr -> mword ty12 -> M unit\<close>\<close>

definition set_SV39_Paddr_PgOfs  :: "((regstate),(register_value),(SV39_Paddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_Paddr_PgOfs r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV39_Paddr_SV39_Paddr_chunk_0 :=
         ((update_subrange_vec_dec(SV39_Paddr_SV39_Paddr_chunk_0   r) (( 11 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
            ::  56 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV39_Paddr))register_ref " 
  and  v  :: "(12)Word.word "


\<comment> \<open>\<open>val _update_SV39_Paddr_PgOfs : SV39_Paddr -> mword ty12 -> SV39_Paddr\<close>\<close>

definition update_SV39_Paddr_PgOfs  :: " SV39_Paddr \<Rightarrow>(12)Word.word \<Rightarrow> SV39_Paddr "  where 
     " update_SV39_Paddr_PgOfs v x = (
   (v (|
     SV39_Paddr_SV39_Paddr_chunk_0 :=
       ((update_subrange_vec_dec(SV39_Paddr_SV39_Paddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
          ::  56 Word.word))|)))" 
  for  v  :: " SV39_Paddr " 
  and  x  :: "(12)Word.word "


\<comment> \<open>\<open>val Mk_SV39_PTE : mword ty64 -> SV39_PTE\<close>\<close>

definition Mk_SV39_PTE  :: "(64)Word.word \<Rightarrow> SV39_PTE "  where 
     " Mk_SV39_PTE v = (
   (| SV39_PTE_SV39_PTE_chunk_0 = ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) |) )" 
  for  v  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_SV39_PTE_bits : SV39_PTE -> mword ty64\<close>\<close>

definition get_SV39_PTE_bits  :: " SV39_PTE \<Rightarrow>(64)Word.word "  where 
     " get_SV39_PTE_bits v = (
   (subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))" 
  for  v  :: " SV39_PTE "


\<comment> \<open>\<open>val _set_SV39_PTE_bits : register_ref regstate register_value SV39_PTE -> mword ty64 -> M unit\<close>\<close>

definition set_SV39_PTE_bits  :: "((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_PTE_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV39_PTE_SV39_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   r) (( 63 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV39_PTE))register_ref " 
  and  v  :: "(64)Word.word "


\<comment> \<open>\<open>val _update_SV39_PTE_bits : SV39_PTE -> mword ty64 -> SV39_PTE\<close>\<close>

definition update_SV39_PTE_bits  :: " SV39_PTE \<Rightarrow>(64)Word.word \<Rightarrow> SV39_PTE "  where 
     " update_SV39_PTE_bits v x = (
   (v (|
     SV39_PTE_SV39_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " SV39_PTE " 
  and  x  :: "(64)Word.word "


\<comment> \<open>\<open>val _get_SV39_PTE_PPNi : SV39_PTE -> mword ty44\<close>\<close>

definition get_SV39_PTE_PPNi  :: " SV39_PTE \<Rightarrow>(44)Word.word "  where 
     " get_SV39_PTE_PPNi v = (
   (subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   v) (( 53 :: int)::ii) (( 10 :: int)::ii)  ::  44 Word.word))" 
  for  v  :: " SV39_PTE "


\<comment> \<open>\<open>val _set_SV39_PTE_PPNi : register_ref regstate register_value SV39_PTE -> mword ty44 -> M unit\<close>\<close>

definition set_SV39_PTE_PPNi  :: "((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_PTE_PPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV39_PTE_SV39_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   r) (( 53 :: int)::ii) (( 10 :: int)::ii)
             ((subrange_vec_dec v (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV39_PTE))register_ref " 
  and  v  :: "(44)Word.word "


\<comment> \<open>\<open>val _update_SV39_PTE_PPNi : SV39_PTE -> mword ty44 -> SV39_PTE\<close>\<close>

definition update_SV39_PTE_PPNi  :: " SV39_PTE \<Rightarrow>(44)Word.word \<Rightarrow> SV39_PTE "  where 
     " update_SV39_PTE_PPNi v x = (
   (v (|
     SV39_PTE_SV39_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   v) (( 53 :: int)::ii) (( 10 :: int)::ii)
           ((subrange_vec_dec x (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " SV39_PTE " 
  and  x  :: "(44)Word.word "


\<comment> \<open>\<open>val _get_SV39_PTE_RSW : SV39_PTE -> mword ty2\<close>\<close>

definition get_SV39_PTE_RSW  :: " SV39_PTE \<Rightarrow>(2)Word.word "  where 
     " get_SV39_PTE_RSW v = ( (subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   v) (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))" 
  for  v  :: " SV39_PTE "


\<comment> \<open>\<open>val _set_SV39_PTE_RSW : register_ref regstate register_value SV39_PTE -> mword ty2 -> M unit\<close>\<close>

definition set_SV39_PTE_RSW  :: "((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_PTE_RSW r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV39_PTE_SV39_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   r) (( 9 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV39_PTE))register_ref " 
  and  v  :: "(2)Word.word "


\<comment> \<open>\<open>val _update_SV39_PTE_RSW : SV39_PTE -> mword ty2 -> SV39_PTE\<close>\<close>

definition update_SV39_PTE_RSW  :: " SV39_PTE \<Rightarrow>(2)Word.word \<Rightarrow> SV39_PTE "  where 
     " update_SV39_PTE_RSW v x = (
   (v (|
     SV39_PTE_SV39_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   v) (( 9 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " SV39_PTE " 
  and  x  :: "(2)Word.word "


\<comment> \<open>\<open>val _get_SV39_PTE_BITS : SV39_PTE -> mword ty8\<close>\<close>

definition get_SV39_PTE_BITS  :: " SV39_PTE \<Rightarrow>(8)Word.word "  where 
     " get_SV39_PTE_BITS v = ( (subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))" 
  for  v  :: " SV39_PTE "


\<comment> \<open>\<open>val _set_SV39_PTE_BITS : register_ref regstate register_value SV39_PTE -> mword ty8 -> M unit\<close>\<close>

definition set_SV39_PTE_BITS  :: "((regstate),(register_value),(SV39_PTE))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV39_PTE_BITS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV39_PTE_SV39_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   r) (( 7 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV39_PTE))register_ref " 
  and  v  :: "(8)Word.word "


\<comment> \<open>\<open>val _update_SV39_PTE_BITS : SV39_PTE -> mword ty8 -> SV39_PTE\<close>\<close>

definition update_SV39_PTE_BITS  :: " SV39_PTE \<Rightarrow>(8)Word.word \<Rightarrow> SV39_PTE "  where 
     " update_SV39_PTE_BITS v x = (
   (v (|
     SV39_PTE_SV39_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV39_PTE_SV39_PTE_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " SV39_PTE " 
  and  x  :: "(8)Word.word "


definition SV48_LEVEL_BITS  :: " int "  where 
     " SV48_LEVEL_BITS = ( (( 9 :: int)::ii))"


definition SV48_LEVELS  :: " int "  where 
     " SV48_LEVELS = ( (( 4 :: int)::ii))"


definition PTE48_LOG_SIZE  :: " int "  where 
     " PTE48_LOG_SIZE = ( (( 3 :: int)::ii))"


definition PTE48_SIZE  :: " int "  where 
     " PTE48_SIZE = ( (( 8 :: int)::ii))"


\<comment> \<open>\<open>val Mk_SV48_Vaddr : mword ty48 -> SV48_Vaddr\<close>\<close>

definition Mk_SV48_Vaddr  :: "(48)Word.word \<Rightarrow> SV48_Vaddr "  where 
     " Mk_SV48_Vaddr v = (
   (| SV48_Vaddr_SV48_Vaddr_chunk_0 = ((subrange_vec_dec v (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word)) |) )" 
  for  v  :: "(48)Word.word "


\<comment> \<open>\<open>val _get_SV48_Vaddr_bits : SV48_Vaddr -> mword ty48\<close>\<close>

definition get_SV48_Vaddr_bits  :: " SV48_Vaddr \<Rightarrow>(48)Word.word "  where 
     " get_SV48_Vaddr_bits v = (
   (subrange_vec_dec(SV48_Vaddr_SV48_Vaddr_chunk_0   v) (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))" 
  for  v  :: " SV48_Vaddr "


\<comment> \<open>\<open>val _set_SV48_Vaddr_bits : register_ref regstate register_value SV48_Vaddr -> mword ty48 -> M unit\<close>\<close>

definition set_SV48_Vaddr_bits  :: "((regstate),(register_value),(SV48_Vaddr))register_ref \<Rightarrow>(48)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV48_Vaddr_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV48_Vaddr_SV48_Vaddr_chunk_0 :=
         ((update_subrange_vec_dec(SV48_Vaddr_SV48_Vaddr_chunk_0   r) (( 47 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))
            ::  48 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV48_Vaddr))register_ref " 
  and  v  :: "(48)Word.word "


\<comment> \<open>\<open>val _update_SV48_Vaddr_bits : SV48_Vaddr -> mword ty48 -> SV48_Vaddr\<close>\<close>

definition update_SV48_Vaddr_bits  :: " SV48_Vaddr \<Rightarrow>(48)Word.word \<Rightarrow> SV48_Vaddr "  where 
     " update_SV48_Vaddr_bits v x = (
   (v (|
     SV48_Vaddr_SV48_Vaddr_chunk_0 :=
       ((update_subrange_vec_dec(SV48_Vaddr_SV48_Vaddr_chunk_0   v) (( 47 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 47 :: int)::ii) (( 0 :: int)::ii)  ::  48 Word.word))
          ::  48 Word.word))|)))" 
  for  v  :: " SV48_Vaddr " 
  and  x  :: "(48)Word.word "


definition get_SV48_Vaddr_VPNi  :: " SV48_Vaddr \<Rightarrow>(27)Word.word "  where 
     " get_SV48_Vaddr_VPNi v = (
   (subrange_vec_dec(SV48_Vaddr_SV48_Vaddr_chunk_0   v) (( 38 :: int)::ii) (( 12 :: int)::ii)  ::  27 Word.word))" 
  for  v  :: " SV48_Vaddr "


definition set_SV48_Vaddr_VPNi  :: "((regstate),(register_value),(SV48_Vaddr))register_ref \<Rightarrow>(27)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV48_Vaddr_VPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV48_Vaddr_SV48_Vaddr_chunk_0 :=
         ((update_subrange_vec_dec(SV48_Vaddr_SV48_Vaddr_chunk_0   r) (( 38 :: int)::ii) (( 12 :: int)::ii)
             ((subrange_vec_dec v (( 26 :: int)::ii) (( 0 :: int)::ii)  ::  27 Word.word))
            ::  48 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV48_Vaddr))register_ref " 
  and  v  :: "(27)Word.word "


definition update_SV48_Vaddr_VPNi  :: " SV48_Vaddr \<Rightarrow>(27)Word.word \<Rightarrow> SV48_Vaddr "  where 
     " update_SV48_Vaddr_VPNi v x = (
   (v (|
     SV48_Vaddr_SV48_Vaddr_chunk_0 :=
       ((update_subrange_vec_dec(SV48_Vaddr_SV48_Vaddr_chunk_0   v) (( 38 :: int)::ii) (( 12 :: int)::ii)
           ((subrange_vec_dec x (( 26 :: int)::ii) (( 0 :: int)::ii)  ::  27 Word.word))
          ::  48 Word.word))|)))" 
  for  v  :: " SV48_Vaddr " 
  and  x  :: "(27)Word.word "


\<comment> \<open>\<open>val _get_SV48_Vaddr_PgOfs : SV48_Vaddr -> mword ty12\<close>\<close>

definition get_SV48_Vaddr_PgOfs  :: " SV48_Vaddr \<Rightarrow>(12)Word.word "  where 
     " get_SV48_Vaddr_PgOfs v = (
   (subrange_vec_dec(SV48_Vaddr_SV48_Vaddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))" 
  for  v  :: " SV48_Vaddr "


\<comment> \<open>\<open>val _set_SV48_Vaddr_PgOfs : register_ref regstate register_value SV48_Vaddr -> mword ty12 -> M unit\<close>\<close>

definition set_SV48_Vaddr_PgOfs  :: "((regstate),(register_value),(SV48_Vaddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV48_Vaddr_PgOfs r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV48_Vaddr_SV48_Vaddr_chunk_0 :=
         ((update_subrange_vec_dec(SV48_Vaddr_SV48_Vaddr_chunk_0   r) (( 11 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
            ::  48 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV48_Vaddr))register_ref " 
  and  v  :: "(12)Word.word "


\<comment> \<open>\<open>val _update_SV48_Vaddr_PgOfs : SV48_Vaddr -> mword ty12 -> SV48_Vaddr\<close>\<close>

definition update_SV48_Vaddr_PgOfs  :: " SV48_Vaddr \<Rightarrow>(12)Word.word \<Rightarrow> SV48_Vaddr "  where 
     " update_SV48_Vaddr_PgOfs v x = (
   (v (|
     SV48_Vaddr_SV48_Vaddr_chunk_0 :=
       ((update_subrange_vec_dec(SV48_Vaddr_SV48_Vaddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
          ::  48 Word.word))|)))" 
  for  v  :: " SV48_Vaddr " 
  and  x  :: "(12)Word.word "


\<comment> \<open>\<open>val Mk_SV48_Paddr : mword ty56 -> SV48_Paddr\<close>\<close>

definition Mk_SV48_Paddr  :: "(56)Word.word \<Rightarrow> SV48_Paddr "  where 
     " Mk_SV48_Paddr v = (
   (| SV48_Paddr_SV48_Paddr_chunk_0 = ((subrange_vec_dec v (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word)) |) )" 
  for  v  :: "(56)Word.word "


\<comment> \<open>\<open>val _get_SV48_Paddr_bits : SV48_Paddr -> mword ty56\<close>\<close>

definition get_SV48_Paddr_bits  :: " SV48_Paddr \<Rightarrow>(56)Word.word "  where 
     " get_SV48_Paddr_bits v = (
   (subrange_vec_dec(SV48_Paddr_SV48_Paddr_chunk_0   v) (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))" 
  for  v  :: " SV48_Paddr "


\<comment> \<open>\<open>val _set_SV48_Paddr_bits : register_ref regstate register_value SV48_Paddr -> mword ty56 -> M unit\<close>\<close>

definition set_SV48_Paddr_bits  :: "((regstate),(register_value),(SV48_Paddr))register_ref \<Rightarrow>(56)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV48_Paddr_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV48_Paddr_SV48_Paddr_chunk_0 :=
         ((update_subrange_vec_dec(SV48_Paddr_SV48_Paddr_chunk_0   r) (( 55 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))
            ::  56 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV48_Paddr))register_ref " 
  and  v  :: "(56)Word.word "


\<comment> \<open>\<open>val _update_SV48_Paddr_bits : SV48_Paddr -> mword ty56 -> SV48_Paddr\<close>\<close>

definition update_SV48_Paddr_bits  :: " SV48_Paddr \<Rightarrow>(56)Word.word \<Rightarrow> SV48_Paddr "  where 
     " update_SV48_Paddr_bits v x = (
   (v (|
     SV48_Paddr_SV48_Paddr_chunk_0 :=
       ((update_subrange_vec_dec(SV48_Paddr_SV48_Paddr_chunk_0   v) (( 55 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 55 :: int)::ii) (( 0 :: int)::ii)  ::  56 Word.word))
          ::  56 Word.word))|)))" 
  for  v  :: " SV48_Paddr " 
  and  x  :: "(56)Word.word "


\<comment> \<open>\<open>val _get_SV48_Paddr_PPNi : SV48_Paddr -> mword ty44\<close>\<close>

definition get_SV48_Paddr_PPNi  :: " SV48_Paddr \<Rightarrow>(44)Word.word "  where 
     " get_SV48_Paddr_PPNi v = (
   (subrange_vec_dec(SV48_Paddr_SV48_Paddr_chunk_0   v) (( 55 :: int)::ii) (( 12 :: int)::ii)  ::  44 Word.word))" 
  for  v  :: " SV48_Paddr "


\<comment> \<open>\<open>val _set_SV48_Paddr_PPNi : register_ref regstate register_value SV48_Paddr -> mword ty44 -> M unit\<close>\<close>

definition set_SV48_Paddr_PPNi  :: "((regstate),(register_value),(SV48_Paddr))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV48_Paddr_PPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV48_Paddr_SV48_Paddr_chunk_0 :=
         ((update_subrange_vec_dec(SV48_Paddr_SV48_Paddr_chunk_0   r) (( 55 :: int)::ii) (( 12 :: int)::ii)
             ((subrange_vec_dec v (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))
            ::  56 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV48_Paddr))register_ref " 
  and  v  :: "(44)Word.word "


\<comment> \<open>\<open>val _update_SV48_Paddr_PPNi : SV48_Paddr -> mword ty44 -> SV48_Paddr\<close>\<close>

definition update_SV48_Paddr_PPNi  :: " SV48_Paddr \<Rightarrow>(44)Word.word \<Rightarrow> SV48_Paddr "  where 
     " update_SV48_Paddr_PPNi v x = (
   (v (|
     SV48_Paddr_SV48_Paddr_chunk_0 :=
       ((update_subrange_vec_dec(SV48_Paddr_SV48_Paddr_chunk_0   v) (( 55 :: int)::ii) (( 12 :: int)::ii)
           ((subrange_vec_dec x (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))
          ::  56 Word.word))|)))" 
  for  v  :: " SV48_Paddr " 
  and  x  :: "(44)Word.word "


definition get_SV48_Paddr_PgOfs  :: " SV48_Paddr \<Rightarrow>(12)Word.word "  where 
     " get_SV48_Paddr_PgOfs v = (
   (subrange_vec_dec(SV48_Paddr_SV48_Paddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))" 
  for  v  :: " SV48_Paddr "


definition set_SV48_Paddr_PgOfs  :: "((regstate),(register_value),(SV48_Paddr))register_ref \<Rightarrow>(12)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV48_Paddr_PgOfs r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV48_Paddr_SV48_Paddr_chunk_0 :=
         ((update_subrange_vec_dec(SV48_Paddr_SV48_Paddr_chunk_0   r) (( 11 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
            ::  56 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV48_Paddr))register_ref " 
  and  v  :: "(12)Word.word "


definition update_SV48_Paddr_PgOfs  :: " SV48_Paddr \<Rightarrow>(12)Word.word \<Rightarrow> SV48_Paddr "  where 
     " update_SV48_Paddr_PgOfs v x = (
   (v (|
     SV48_Paddr_SV48_Paddr_chunk_0 :=
       ((update_subrange_vec_dec(SV48_Paddr_SV48_Paddr_chunk_0   v) (( 11 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 11 :: int)::ii) (( 0 :: int)::ii)  ::  12 Word.word))
          ::  56 Word.word))|)))" 
  for  v  :: " SV48_Paddr " 
  and  x  :: "(12)Word.word "


\<comment> \<open>\<open>val Mk_SV48_PTE : mword ty64 -> SV48_PTE\<close>\<close>

definition Mk_SV48_PTE  :: "(64)Word.word \<Rightarrow> SV48_PTE "  where 
     " Mk_SV48_PTE v = (
   (| SV48_PTE_SV48_PTE_chunk_0 = ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word)) |) )" 
  for  v  :: "(64)Word.word "


definition get_SV48_PTE_bits  :: " SV48_PTE \<Rightarrow>(64)Word.word "  where 
     " get_SV48_PTE_bits v = (
   (subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))" 
  for  v  :: " SV48_PTE "


definition set_SV48_PTE_bits  :: "((regstate),(register_value),(SV48_PTE))register_ref \<Rightarrow>(64)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV48_PTE_bits r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV48_PTE_SV48_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   r) (( 63 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV48_PTE))register_ref " 
  and  v  :: "(64)Word.word "


definition update_SV48_PTE_bits  :: " SV48_PTE \<Rightarrow>(64)Word.word \<Rightarrow> SV48_PTE "  where 
     " update_SV48_PTE_bits v x = (
   (v (|
     SV48_PTE_SV48_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   v) (( 63 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 63 :: int)::ii) (( 0 :: int)::ii)  ::  64 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " SV48_PTE " 
  and  x  :: "(64)Word.word "


definition get_SV48_PTE_PPNi  :: " SV48_PTE \<Rightarrow>(44)Word.word "  where 
     " get_SV48_PTE_PPNi v = (
   (subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   v) (( 53 :: int)::ii) (( 10 :: int)::ii)  ::  44 Word.word))" 
  for  v  :: " SV48_PTE "


definition set_SV48_PTE_PPNi  :: "((regstate),(register_value),(SV48_PTE))register_ref \<Rightarrow>(44)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV48_PTE_PPNi r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV48_PTE_SV48_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   r) (( 53 :: int)::ii) (( 10 :: int)::ii)
             ((subrange_vec_dec v (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV48_PTE))register_ref " 
  and  v  :: "(44)Word.word "


definition update_SV48_PTE_PPNi  :: " SV48_PTE \<Rightarrow>(44)Word.word \<Rightarrow> SV48_PTE "  where 
     " update_SV48_PTE_PPNi v x = (
   (v (|
     SV48_PTE_SV48_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   v) (( 53 :: int)::ii) (( 10 :: int)::ii)
           ((subrange_vec_dec x (( 43 :: int)::ii) (( 0 :: int)::ii)  ::  44 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " SV48_PTE " 
  and  x  :: "(44)Word.word "


definition get_SV48_PTE_RSW  :: " SV48_PTE \<Rightarrow>(2)Word.word "  where 
     " get_SV48_PTE_RSW v = ( (subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   v) (( 9 :: int)::ii) (( 8 :: int)::ii)  ::  2 Word.word))" 
  for  v  :: " SV48_PTE "


definition set_SV48_PTE_RSW  :: "((regstate),(register_value),(SV48_PTE))register_ref \<Rightarrow>(2)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV48_PTE_RSW r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV48_PTE_SV48_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   r) (( 9 :: int)::ii) (( 8 :: int)::ii)
             ((subrange_vec_dec v (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV48_PTE))register_ref " 
  and  v  :: "(2)Word.word "


definition update_SV48_PTE_RSW  :: " SV48_PTE \<Rightarrow>(2)Word.word \<Rightarrow> SV48_PTE "  where 
     " update_SV48_PTE_RSW v x = (
   (v (|
     SV48_PTE_SV48_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   v) (( 9 :: int)::ii) (( 8 :: int)::ii)
           ((subrange_vec_dec x (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " SV48_PTE " 
  and  x  :: "(2)Word.word "


definition get_SV48_PTE_BITS  :: " SV48_PTE \<Rightarrow>(8)Word.word "  where 
     " get_SV48_PTE_BITS v = ( (subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))" 
  for  v  :: " SV48_PTE "


definition set_SV48_PTE_BITS  :: "((regstate),(register_value),(SV48_PTE))register_ref \<Rightarrow>(8)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " set_SV48_PTE_BITS r_ref v = (
   reg_deref r_ref \<bind> (\<lambda> r . 
   (let r =
     ((r (|
       SV48_PTE_SV48_PTE_chunk_0 :=
         ((update_subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   r) (( 7 :: int)::ii) (( 0 :: int)::ii)
             ((subrange_vec_dec v (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
            ::  64 Word.word))|))) in
   write_reg r_ref r)))" 
  for  r_ref  :: "((regstate),(register_value),(SV48_PTE))register_ref " 
  and  v  :: "(8)Word.word "


definition update_SV48_PTE_BITS  :: " SV48_PTE \<Rightarrow>(8)Word.word \<Rightarrow> SV48_PTE "  where 
     " update_SV48_PTE_BITS v x = (
   (v (|
     SV48_PTE_SV48_PTE_chunk_0 :=
       ((update_subrange_vec_dec(SV48_PTE_SV48_PTE_chunk_0   v) (( 7 :: int)::ii) (( 0 :: int)::ii)
           ((subrange_vec_dec x (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
          ::  64 Word.word))|)))" 
  for  v  :: " SV48_PTE " 
  and  x  :: "(8)Word.word "


\<comment> \<open>\<open>val make_TLB_Entry : forall 'asidlen 'palen 'ptelen 'valen. Size 'asidlen, Size 'palen, Size 'ptelen, Size 'valen => mword 'asidlen -> bool -> mword 'valen -> mword 'palen -> mword 'ptelen -> ii -> mword 'palen -> ii -> M (TLB_Entry 'asidlen 'valen 'palen 'ptelen)\<close>\<close>

definition make_TLB_Entry  :: "('asidlen::len)Word.word \<Rightarrow> bool \<Rightarrow>('valen::len)Word.word \<Rightarrow>('palen::len)Word.word \<Rightarrow>('ptelen::len)Word.word \<Rightarrow> int \<Rightarrow>('palen::len)Word.word \<Rightarrow> int \<Rightarrow>((register_value),((('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry),(exception))monad "  where 
     " make_TLB_Entry asid global1 vAddr pAddr pte level pteAddr levelBitSize = (
   (let (shift :: ii) = (PAGESIZE_BITS + ((level * levelBitSize))) in
   (let vAddrMask =
     ((sub_vec_int
        ((shiftl
            ((xor_vec vAddr
                ((xor_vec vAddr
                    ((EXTZ ((int (size vAddr))) (vec_of_bits [B1]  ::  1 Word.word)  :: ( 'valen::len)Word.word))
                   :: ( 'valen::len)Word.word))
               :: ( 'valen::len)Word.word)) shift
           :: ( 'valen::len)Word.word)) (( 1 :: int)::ii)
       :: ( 'valen::len)Word.word)) in
   (let vMatchMask = ((not_vec vAddrMask  :: ( 'valen::len)Word.word)) in
   (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__0 ::  64 Word.word) . 
   return ((| TLB_Entry_asid = asid, 
              TLB_Entry_global = global1, 
              TLB_Entry_vAddr = ((and_vec vAddr vMatchMask  :: ( 'valen::len)Word.word)), 
              TLB_Entry_pAddr =
                ((shiftl ((shiftr pAddr shift  :: ( 'palen::len)Word.word)) shift  :: ( 'palen::len)Word.word)), 
              TLB_Entry_vMatchMask = vMatchMask, 
              TLB_Entry_vAddrMask = vAddrMask, 
              TLB_Entry_pte = pte, 
              TLB_Entry_pteAddr = pteAddr, 
              TLB_Entry_age = w__0  |)))))))" 
  for  asid  :: "('asidlen::len)Word.word " 
  and  global1  :: " bool " 
  and  vAddr  :: "('valen::len)Word.word " 
  and  pAddr  :: "('palen::len)Word.word " 
  and  pte  :: "('ptelen::len)Word.word " 
  and  level  :: " int " 
  and  pteAddr  :: "('palen::len)Word.word " 
  and  levelBitSize  :: " int "


\<comment> \<open>\<open>val match_TLB_Entry : forall 'asidlen 'palen 'ptelen 'valen. Size 'asidlen, Size 'valen => TLB_Entry 'asidlen 'valen 'palen 'ptelen -> mword 'asidlen -> mword 'valen -> bool\<close>\<close>

definition match_TLB_Entry  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry \<Rightarrow>('asidlen::len)Word.word \<Rightarrow>('valen::len)Word.word \<Rightarrow> bool "  where 
     " match_TLB_Entry ent asid vaddr = (
   (((((TLB_Entry_global   ent) \<or> ((((TLB_Entry_asid   ent) = asid)))))) \<and> ((((TLB_Entry_vAddr   ent) = ((and_vec(TLB_Entry_vMatchMask   ent) vaddr  :: ( 'valen::len)Word.word)))))))" 
  for  ent  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry " 
  and  asid  :: "('asidlen::len)Word.word " 
  and  vaddr  :: "('valen::len)Word.word "


\<comment> \<open>\<open>val flush_TLB_Entry : forall 'asidlen 'palen 'ptelen 'valen. Size 'asidlen, Size 'valen => TLB_Entry 'asidlen 'valen 'palen 'ptelen -> maybe (mword 'asidlen) -> maybe (mword 'valen) -> bool\<close>\<close>

fun flush_TLB_Entry  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry \<Rightarrow>(('asidlen::len)Word.word)option \<Rightarrow>(('valen::len)Word.word)option \<Rightarrow> bool "  where 
     " flush_TLB_Entry e None None = ( True )" 
  for  e  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry "
|" flush_TLB_Entry e None (Some (a)) = (
      ((TLB_Entry_vAddr   e) = ((and_vec(TLB_Entry_vMatchMask   e) a  :: ( 'valen::len)Word.word))))" 
  for  e  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry " 
  and  a  :: "('valen::len)Word.word "
|" flush_TLB_Entry e (Some (i)) None = ( (((((TLB_Entry_asid   e) = i))) \<and> ((\<not>(TLB_Entry_global   e)))))" 
  for  e  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry " 
  and  i  :: "('asidlen::len)Word.word "
|" flush_TLB_Entry e (Some (i)) (Some (a)) = (
      (((((TLB_Entry_asid   e) = i))) \<and> (((((((TLB_Entry_vAddr   e) = ((and_vec a(TLB_Entry_vMatchMask   e)  :: ( 'valen::len)Word.word))))) \<and> ((\<not>(TLB_Entry_global   e))))))))" 
  for  e  :: "(('asidlen::len),('valen::len),('palen::len),('ptelen::len))TLB_Entry " 
  and  i  :: "('asidlen::len)Word.word " 
  and  a  :: "('valen::len)Word.word "


\<comment> \<open>\<open>val to_phys_addr : mword ty34 -> mword ty32\<close>\<close>

definition to_phys_addr  :: "(34)Word.word \<Rightarrow>(32)Word.word "  where 
     " to_phys_addr a = ( (subrange_vec_dec a (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))" 
  for  a  :: "(34)Word.word "


\<comment> \<open>\<open>val walk32 : mword ty32 -> AccessType -> Privilege -> bool -> bool -> mword ty34 -> ii -> bool -> M (PTW_Result (mword ty34) SV32_PTE)\<close>\<close>

function (sequential,domintros)  walk32  :: "(32)Word.word \<Rightarrow> AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>(34)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),((((34)Word.word),(SV32_PTE))PTW_Result),(exception))monad "  where 
     " walk32 vaddr ac priv mxr do_sum ptb level global1 = (
   (let va = (Mk_SV32_Vaddr vaddr) in
   (let (pt_ofs :: paddr32) =
     ((shiftl
        ((EXTZ (( 34 :: int)::ii)
            ((subrange_vec_dec
                ((shiftr ((get_SV32_Vaddr_VPNi va  ::  20 Word.word))
                    ((level * SV32_LEVEL_BITS))
                   ::  20 Word.word)) ((SV32_LEVEL_BITS - (( 1 :: int)::ii))) (( 0 :: int)::ii)
               ::  10 Word.word))
           ::  34 Word.word)) PTE32_LOG_SIZE
       ::  34 Word.word)) in
   (let pte_addr = ((add_vec ptb pt_ofs  ::  34 Word.word)) in
   (mem_read ac ((to_phys_addr pte_addr  ::  32 Word.word)) (( 4 :: int)::ii) False False False
     :: ( ( 32 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__0 :: ( 32 Word.word) MemoryOpResult) . 
   (case  w__0 of
     MemException (_) => return (PTW_Failure PTW_Access)
   | MemValue (v) =>
      (let pte = (Mk_SV32_PTE v) in
      (let pbits = ((get_SV32_PTE_BITS pte  ::  8 Word.word)) in
      (let pattr = (Mk_PTE_Bits pbits) in
      (let is_global =
        (global1 \<or> (((((get_PTE_Bits_G pattr  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word)))))) in
      if ((isInvalidPTE pbits)) then return (PTW_Failure PTW_Invalid_PTE)
      else if ((isPTEPtr pbits)) then
        if (((level = (( 0 :: int)::ii)))) then return (PTW_Failure PTW_Invalid_PTE)
        else
          (walk32 vaddr ac priv mxr do_sum
             ((shiftl ((EXTZ (( 34 :: int)::ii) ((get_SV32_PTE_PPNi pte  ::  22 Word.word))  ::  34 Word.word))
                 PAGESIZE_BITS
                ::  34 Word.word)) ((level - (( 1 :: int)::ii))) is_global
            :: ( (( 34 Word.word), SV32_PTE)PTW_Result) M)
      else
        checkPTEPermission ac priv mxr do_sum pattr \<bind> (\<lambda> (w__3 :: bool) . 
        return (if ((\<not> w__3)) then PTW_Failure PTW_No_Permission
                else if ((level > (( 0 :: int)::ii))) then
                  (let mask1 =
                    ((sub_vec_int
                       ((shiftl
                           ((xor_vec ((get_SV32_PTE_PPNi pte  ::  22 Word.word))
                               ((xor_vec ((get_SV32_PTE_PPNi pte  ::  22 Word.word))
                                   ((EXTZ (( 22 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  22 Word.word))
                                  ::  22 Word.word))
                              ::  22 Word.word)) ((level * SV32_LEVEL_BITS))
                          ::  22 Word.word)) (( 1 :: int)::ii)
                      ::  22 Word.word)) in
                  if (((((and_vec ((get_SV32_PTE_PPNi pte  ::  22 Word.word)) mask1  ::  22 Word.word)) \<noteq> ((EXTZ (( 22 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  22 Word.word))))) then
                    PTW_Failure PTW_Misaligned
                  else
                    (let ppn =
                      ((or_vec ((get_SV32_PTE_PPNi pte  ::  22 Word.word))
                         ((and_vec
                             ((EXTZ (( 22 :: int)::ii) ((get_SV32_Vaddr_VPNi va  ::  20 Word.word))  ::  22 Word.word))
                             mask1
                            ::  22 Word.word))
                        ::  22 Word.word)) in
                    PTW_Success ((concat_vec ppn ((get_SV32_Vaddr_PgOfs va  ::  12 Word.word))
                                   ::  34 Word.word),
                                 pte,
                                 pte_addr,
                                 level,
                                 is_global)))
                else
                  PTW_Success ((concat_vec ((get_SV32_PTE_PPNi pte  ::  22 Word.word))
                                  ((get_SV32_Vaddr_PgOfs va  ::  12 Word.word))
                                 ::  34 Word.word),
                               pte,
                               pte_addr,
                               level,
                               is_global)))))))
   ))))))" 
  for  vaddr  :: "(32)Word.word " 
  and  ac  :: " AccessType " 
  and  priv  :: " Privilege " 
  and  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  ptb  :: "(34)Word.word " 
  and  level  :: " int " 
  and  global1  :: " bool " 
by pat_completeness auto


\<comment> \<open>\<open>val lookup_TLB32 : mword ty9 -> mword ty32 -> M (maybe ((ii * TLB_Entry ty9 ty32 ty34 ty32)))\<close>\<close>

definition lookup_TLB32  :: "(9)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),((int*((9),(32),(34),(32))TLB_Entry)option),(exception))monad "  where 
     " lookup_TLB32 asid vaddr = (
   read_reg tlb32_ref \<bind> (\<lambda> (w__0 ::  ( (9, 32, 34, 32)TLB_Entry)option) . 
   return ((case  w__0 of
     None => None
   | Some (e) => if ((match_TLB_Entry e asid vaddr)) then Some ((( 0 :: int)::ii), e) else None
   ))))" 
  for  asid  :: "(9)Word.word " 
  and  vaddr  :: "(32)Word.word "


\<comment> \<open>\<open>val add_to_TLB32 : mword ty9 -> mword ty32 -> mword ty34 -> SV32_PTE -> mword ty34 -> ii -> bool -> M unit\<close>\<close>

definition add_to_TLB32  :: "(9)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(34)Word.word \<Rightarrow> SV32_PTE \<Rightarrow>(34)Word.word \<Rightarrow> int \<Rightarrow> bool \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " add_to_TLB32 asid vAddr pAddr pte pteAddr level global1 = (
   make_TLB_Entry asid global1 vAddr pAddr ((get_SV32_PTE_bits pte  ::  32 Word.word)) level pteAddr
     SV32_LEVEL_BITS \<bind> (\<lambda> (ent :: TLB32_Entry) . 
   write_reg tlb32_ref (Some ent)))" 
  for  asid  :: "(9)Word.word " 
  and  vAddr  :: "(32)Word.word " 
  and  pAddr  :: "(34)Word.word " 
  and  pte  :: " SV32_PTE " 
  and  pteAddr  :: "(34)Word.word " 
  and  level  :: " int " 
  and  global1  :: " bool "


\<comment> \<open>\<open>val write_TLB32 : ii -> TLB_Entry ty9 ty32 ty34 ty32 -> M unit\<close>\<close>

definition write_TLB32  :: " int \<Rightarrow>((9),(32),(34),(32))TLB_Entry \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " write_TLB32 (idx :: ii) (ent :: TLB32_Entry) = ( write_reg tlb32_ref (Some ent))" 
  for  idx  :: " int " 
  and  ent  :: "((9),(32),(34),(32))TLB_Entry "


\<comment> \<open>\<open>val flush_TLB32 : maybe (mword ty9) -> maybe (mword ty32) -> M unit\<close>\<close>

definition flush_TLB32  :: "((9)Word.word)option \<Rightarrow>((32)Word.word)option \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " flush_TLB32 asid addr = (
   read_reg tlb32_ref \<bind> (\<lambda> (w__0 ::  ( (9, 32, 34, 32)TLB_Entry)option) . 
   (case  w__0 of
     None => return () 
   | Some (e) => if ((flush_TLB_Entry e asid addr)) then write_reg tlb32_ref None else return () 
   )))" 
  for  asid  :: "((9)Word.word)option " 
  and  addr  :: "((32)Word.word)option "


\<comment> \<open>\<open>val translate32 : mword ty9 -> mword ty34 -> mword ty32 -> AccessType -> Privilege -> bool -> bool -> ii -> M (TR_Result (mword ty34) PTW_Error)\<close>\<close>

definition translate32  :: "(9)Word.word \<Rightarrow>(34)Word.word \<Rightarrow>(32)Word.word \<Rightarrow> AccessType \<Rightarrow> Privilege \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> int \<Rightarrow>((register_value),((((34)Word.word),(PTW_Error))TR_Result),(exception))monad "  where 
     " translate32 asid ptb vAddr ac priv mxr do_sum level = (
   lookup_TLB32 asid vAddr \<bind> (\<lambda> (w__0 ::  ((ii * (9, 32, 34, 32) TLB_Entry))option) . 
   (case  w__0 of
     Some ((idx, ent)) =>
      (let pte = (Mk_SV32_PTE(TLB_Entry_pte   ent)) in
      (let pteBits = (Mk_PTE_Bits ((get_SV32_PTE_BITS pte  ::  8 Word.word))) in
      checkPTEPermission ac priv mxr do_sum pteBits \<bind> (\<lambda> (w__1 :: bool) . 
      if ((\<not> w__1)) then return (TR_Failure PTW_No_Permission)
      else
        (case  ((update_PTE_Bits pteBits ac)) of
          None =>
           return (TR_Address ((or_vec(TLB_Entry_pAddr   ent)
                                  ((EXTZ (( 34 :: int)::ii)
                                      ((and_vec vAddr(TLB_Entry_vAddrMask   ent)  ::  32 Word.word))
                                     ::  34 Word.word))
                                 ::  34 Word.word)))
        | Some (pbits) =>
           if ((\<not> ((plat_enable_dirty_update () )))) then return (TR_Failure PTW_PTE_Update)
           else
             (let n_pte = (update_SV32_PTE_BITS pte ((get_PTE_Bits_bits pbits  ::  8 Word.word))) in
             (let (n_ent :: TLB32_Entry) = ent in
             (let n_ent = ((n_ent (| TLB_Entry_pte := ((get_SV32_PTE_bits n_pte  ::  32 Word.word))|))) in
             (write_TLB32 idx n_ent \<then>
             mem_write_value
               ((to_phys_addr ((EXTZ (( 34 :: int)::ii)(TLB_Entry_pteAddr   ent)  ::  34 Word.word))  ::  32 Word.word))
               (( 4 :: int)::ii) ((get_SV32_PTE_bits n_pte  ::  32 Word.word)) False False False) \<bind> (\<lambda> (w__2 :: bool
               MemoryOpResult) . 
             (case  w__2 of
               MemValue (_) => return () 
             | MemException (e) => internal_error (''invalid physical address in TLB'')
             ) \<then>
             return (TR_Address ((or_vec(TLB_Entry_pAddr   ent)
                                    ((EXTZ (( 34 :: int)::ii)
                                        ((and_vec vAddr(TLB_Entry_vAddrMask   ent)  ::  32 Word.word))
                                       ::  34 Word.word))
                                   ::  34 Word.word)))))))
        ))))
   | None =>
      (walk32 vAddr ac priv mxr do_sum ptb level False  :: ( (( 34 Word.word), SV32_PTE)PTW_Result) M) \<bind> (\<lambda> (w__6 :: (( 34 Word.word), SV32_PTE)
        PTW_Result) . 
      (case  w__6 of
        PTW_Failure (f) => return (TR_Failure f)
      | PTW_Success ((pAddr, pte, pteAddr, level, global1)) =>
         (case  ((update_PTE_Bits ((Mk_PTE_Bits ((get_SV32_PTE_BITS pte  ::  8 Word.word)))) ac)) of
           None =>
            add_to_TLB32 asid vAddr pAddr pte pteAddr level global1 \<then> return (TR_Address pAddr)
         | Some (pbits) =>
            if ((\<not> ((plat_enable_dirty_update () )))) then return (TR_Failure PTW_PTE_Update)
            else
              (let (w_pte :: SV32_PTE) =
                (update_SV32_PTE_BITS pte ((get_PTE_Bits_bits pbits  ::  8 Word.word))) in
              mem_write_value ((to_phys_addr pteAddr  ::  32 Word.word)) (( 4 :: int)::ii)
                ((get_SV32_PTE_bits w_pte  ::  32 Word.word)) False False False \<bind> (\<lambda> (w__7 :: bool
                MemoryOpResult) . 
              (case  w__7 of
                MemValue (_) =>
                 add_to_TLB32 asid vAddr pAddr w_pte pteAddr level global1 \<then>
                 return (TR_Address pAddr)
              | MemException (e) => return (TR_Failure PTW_Access)
              )))
         )
      ))
   )))" 
  for  asid  :: "(9)Word.word " 
  and  ptb  :: "(34)Word.word " 
  and  vAddr  :: "(32)Word.word " 
  and  ac  :: " AccessType " 
  and  priv  :: " Privilege " 
  and  mxr  :: " bool " 
  and  do_sum  :: " bool " 
  and  level  :: " int "


\<comment> \<open>\<open>val init_vmem_sv32 : unit -> M unit\<close>\<close>

definition init_vmem_sv32  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " init_vmem_sv32 _ = ( write_reg tlb32_ref None )"


\<comment> \<open>\<open>val legalize_satp : Architecture -> mword ty32 -> mword ty32 -> mword ty32\<close>\<close>

definition legalize_satp  :: " Architecture \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(32)Word.word "  where 
     " legalize_satp (a :: Architecture) (o1 :: xlenbits) (v :: xlenbits) = (
   (legalize_satp32 a o1 v  ::  32 Word.word))" 
  for  a  :: " Architecture " 
  and  o1  :: "(32)Word.word " 
  and  v  :: "(32)Word.word "


\<comment> \<open>\<open>val translationMode : Privilege -> M SATPMode\<close>\<close>

definition translationMode  :: " Privilege \<Rightarrow>((register_value),(SATPMode),(exception))monad "  where 
     " translationMode priv = (
   if (((((privLevel_to_bits priv  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
   then
     return Sbare
   else
     read_reg mstatus_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
     (let arch = (architecture ((get_mstatus_SXL w__0  ::  2 Word.word))) in
     (case  arch of
       Some (RV32) =>
        (read_reg satp_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
        (let s = (Mk_Satp32 ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))) in
        return (if (((((get_Satp32_Mode s  ::  1 Word.word)) = ((bool_to_bits False  ::  1 Word.word)))))
                then
                  Sbare
                else Sv32)))
     | _ => internal_error (''unsupported address translation arch'')
     ))))" 
  for  priv  :: " Privilege "


\<comment> \<open>\<open>val translateAddr : mword ty32 -> AccessType -> M (TR_Result (mword ty32) ExceptionType)\<close>\<close>

definition translateAddr  :: "(32)Word.word \<Rightarrow> AccessType \<Rightarrow>((register_value),((((32)Word.word),(ExceptionType))TR_Result),(exception))monad "  where 
     " translateAddr vAddr ac = (
   (case  ac of
     Execute => read_reg cur_privilege_ref
   | _ =>
      read_reg mstatus_ref \<bind> (\<lambda> (w__1 :: Mstatus) . 
      read_reg cur_privilege_ref \<bind> (\<lambda> (w__2 :: Privilege) .  effectivePrivilege w__1 w__2))
   ) \<bind> (\<lambda> (effPriv :: Privilege) . 
   read_reg mstatus_ref \<bind> (\<lambda> (w__4 :: Mstatus) . 
   (let (mxr :: bool) =
     (((get_Mstatus_MXR w__4  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))) in
   read_reg mstatus_ref \<bind> (\<lambda> (w__5 :: Mstatus) . 
   (let (do_sum :: bool) =
     (((get_Mstatus_SUM w__5  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))) in
   translationMode effPriv \<bind> (\<lambda> (mode :: SATPMode) . 
   (read_reg satp_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 ::  32 Word.word) . 
   (let asid = ((curAsid32 w__6  ::  9 Word.word)) in
   (read_reg satp_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 ::  32 Word.word) . 
   (let ptb = ((curPTB32 w__7  ::  34 Word.word)) in
   (case  mode of
     Sbare => return (TR_Address vAddr)
   | Sv32 =>
      (translate32 asid ptb vAddr ac effPriv mxr do_sum ((SV32_LEVELS - (( 1 :: int)::ii)))
        :: ( (( 34 Word.word), PTW_Error)TR_Result) M) \<bind> (\<lambda> (w__8 :: (( 34 Word.word), PTW_Error) TR_Result) . 
      return ((case  w__8 of
        TR_Address (pa) => TR_Address ((to_phys_addr pa  ::  32 Word.word))
      | TR_Failure (f) => TR_Failure ((translationException ac f))
      )))
   | _ =>
      (internal_error (''unsupported address translation scheme'')
        :: ( (( 32 Word.word), ExceptionType)TR_Result) M)
   ))))))))))))" 
  for  vAddr  :: "(32)Word.word " 
  and  ac  :: " AccessType "


\<comment> \<open>\<open>val flush_TLB : maybe (mword ty32) -> maybe (mword ty32) -> M unit\<close>\<close>

definition flush_TLB  :: "((32)Word.word)option \<Rightarrow>((32)Word.word)option \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " flush_TLB asid_xlen addr_xlen = (
   (let (asid ::  asid32 option) =
     ((case  asid_xlen of
       None => None
     | Some (a) => Some ((subrange_vec_dec a (( 8 :: int)::ii) (( 0 :: int)::ii)  ::  9 Word.word))
     )) in
   flush_TLB32 asid addr_xlen))" 
  for  asid_xlen  :: "((32)Word.word)option " 
  and  addr_xlen  :: "((32)Word.word)option "


\<comment> \<open>\<open>val init_vmem : unit -> M unit\<close>\<close>

definition init_vmem  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " init_vmem _ = ( init_vmem_sv32 ()  )"


\<comment> \<open>\<open>val execute : ast -> M Retired\<close>\<close>

\<comment> \<open>\<open>val encdec_uop_forwards : uop -> mword ty7\<close>\<close>

fun encdec_uop_forwards  :: " uop \<Rightarrow>(7)Word.word "  where 
     " encdec_uop_forwards RISCV_LUI = ( (vec_of_bits [B0,B1,B1,B0,B1,B1,B1]  ::  7 Word.word))"
|" encdec_uop_forwards RISCV_AUIPC = ( (vec_of_bits [B0,B0,B1,B0,B1,B1,B1]  ::  7 Word.word))"


\<comment> \<open>\<open>val encdec_uop_backwards : mword ty7 -> M uop\<close>\<close>

definition encdec_uop_backwards  :: "(7)Word.word \<Rightarrow>((register_value),(uop),(exception))monad "  where 
     " encdec_uop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B1,B1,B0,B1,B1,B1]  ::  7 Word.word)))) then return RISCV_LUI
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B0,B1,B1,B1]  ::  7 Word.word)))) then return RISCV_AUIPC
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(7)Word.word "


\<comment> \<open>\<open>val encdec_uop_forwards_matches : uop -> bool\<close>\<close>

fun encdec_uop_forwards_matches  :: " uop \<Rightarrow> bool "  where 
     " encdec_uop_forwards_matches RISCV_LUI = ( True )"
|" encdec_uop_forwards_matches RISCV_AUIPC = ( True )"


\<comment> \<open>\<open>val encdec_uop_backwards_matches : mword ty7 -> bool\<close>\<close>

definition encdec_uop_backwards_matches  :: "(7)Word.word \<Rightarrow> bool "  where 
     " encdec_uop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B1,B1,B0,B1,B1,B1]  ::  7 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B0,B1,B0,B1,B1,B1]  ::  7 Word.word)))) then True
   else False))" 
  for  arg1  :: "(7)Word.word "


\<comment> \<open>\<open>val utype_mnemonic_forwards : uop -> string\<close>\<close>

fun utype_mnemonic_forwards  :: " uop \<Rightarrow> string "  where 
     " utype_mnemonic_forwards RISCV_LUI = ( (''lui''))"
|" utype_mnemonic_forwards RISCV_AUIPC = ( (''auipc''))"


\<comment> \<open>\<open>val utype_mnemonic_backwards : string -> M uop\<close>\<close>

definition utype_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(uop),(exception))monad "  where 
     " utype_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''lui'')))) then return RISCV_LUI
   else if (((p00 = (''auipc'')))) then return RISCV_AUIPC
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val utype_mnemonic_forwards_matches : uop -> bool\<close>\<close>

fun utype_mnemonic_forwards_matches  :: " uop \<Rightarrow> bool "  where 
     " utype_mnemonic_forwards_matches RISCV_LUI = ( True )"
|" utype_mnemonic_forwards_matches RISCV_AUIPC = ( True )"


\<comment> \<open>\<open>val utype_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition utype_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " utype_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''lui'')))) then True
   else if (((p00 = (''auipc'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val utype_mnemonic_matches_prefix : string -> maybe ((uop * ii))\<close>\<close>

\<comment> \<open>\<open>val _s496_ : string -> maybe string\<close>\<close>

definition s496  :: " string \<Rightarrow>(string)option "  where 
     " s496 s4970 = (
   (let s4980 = s4970 in
   if ((string_startswith s4980 (''auipc''))) then  
  (case  ((string_drop s4980 ((string_length (''auipc''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4970  :: " string "


\<comment> \<open>\<open>val _s492_ : string -> maybe string\<close>\<close>

definition s492  :: " string \<Rightarrow>(string)option "  where 
     " s492 s4930 = (
   (let s4940 = s4930 in
   if ((string_startswith s4940 (''lui''))) then  
  (case  ((string_drop s4940 ((string_length (''lui''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s4930  :: " string "


definition utype_mnemonic_matches_prefix  :: " string \<Rightarrow>(uop*int)option "  where 
     " utype_mnemonic_matches_prefix arg1 = (
   (let s4950 = arg1 in
   if ((case  ((s492 s4950)) of   Some (s1) => True | _ => False )) then  
  (case  s492 s4950 of
      (Some (s1)) =>
  Some (RISCV_LUI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s496 s4950)) of   Some (s1) => True | _ => False )) then  
  (case  s496 s4950 of
      (Some (s1)) =>
  Some (RISCV_AUIPC, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_bop_forwards : bop -> mword ty3\<close>\<close>

fun encdec_bop_forwards  :: " bop \<Rightarrow>(3)Word.word "  where 
     " encdec_bop_forwards RISCV_BEQ = ( (vec_of_bits [B0,B0,B0]  ::  3 Word.word))"
|" encdec_bop_forwards RISCV_BNE = ( (vec_of_bits [B0,B0,B1]  ::  3 Word.word))"
|" encdec_bop_forwards RISCV_BLT = ( (vec_of_bits [B1,B0,B0]  ::  3 Word.word))"
|" encdec_bop_forwards RISCV_BGE = ( (vec_of_bits [B1,B0,B1]  ::  3 Word.word))"
|" encdec_bop_forwards RISCV_BLTU = ( (vec_of_bits [B1,B1,B0]  ::  3 Word.word))"
|" encdec_bop_forwards RISCV_BGEU = ( (vec_of_bits [B1,B1,B1]  ::  3 Word.word))"


\<comment> \<open>\<open>val encdec_bop_backwards : mword ty3 -> M bop\<close>\<close>

definition encdec_bop_backwards  :: "(3)Word.word \<Rightarrow>((register_value),(bop),(exception))monad "  where 
     " encdec_bop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then return RISCV_BEQ
   else if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then return RISCV_BNE
   else if (((b__0 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then return RISCV_BLT
   else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then return RISCV_BGE
   else if (((b__0 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then return RISCV_BLTU
   else if (((b__0 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) then return RISCV_BGEU
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val encdec_bop_forwards_matches : bop -> bool\<close>\<close>

fun encdec_bop_forwards_matches  :: " bop \<Rightarrow> bool "  where 
     " encdec_bop_forwards_matches RISCV_BEQ = ( True )"
|" encdec_bop_forwards_matches RISCV_BNE = ( True )"
|" encdec_bop_forwards_matches RISCV_BLT = ( True )"
|" encdec_bop_forwards_matches RISCV_BGE = ( True )"
|" encdec_bop_forwards_matches RISCV_BLTU = ( True )"
|" encdec_bop_forwards_matches RISCV_BGEU = ( True )"


\<comment> \<open>\<open>val encdec_bop_backwards_matches : mword ty3 -> bool\<close>\<close>

definition encdec_bop_backwards_matches  :: "(3)Word.word \<Rightarrow> bool "  where 
     " encdec_bop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) then True
   else False))" 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val btype_mnemonic_forwards : bop -> string\<close>\<close>

fun btype_mnemonic_forwards  :: " bop \<Rightarrow> string "  where 
     " btype_mnemonic_forwards RISCV_BEQ = ( (''beq''))"
|" btype_mnemonic_forwards RISCV_BNE = ( (''bne''))"
|" btype_mnemonic_forwards RISCV_BLT = ( (''blt''))"
|" btype_mnemonic_forwards RISCV_BGE = ( (''bge''))"
|" btype_mnemonic_forwards RISCV_BLTU = ( (''bltu''))"
|" btype_mnemonic_forwards RISCV_BGEU = ( (''bgeu''))"


\<comment> \<open>\<open>val btype_mnemonic_backwards : string -> M bop\<close>\<close>

definition btype_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(bop),(exception))monad "  where 
     " btype_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''beq'')))) then return RISCV_BEQ
   else if (((p00 = (''bne'')))) then return RISCV_BNE
   else if (((p00 = (''blt'')))) then return RISCV_BLT
   else if (((p00 = (''bge'')))) then return RISCV_BGE
   else if (((p00 = (''bltu'')))) then return RISCV_BLTU
   else if (((p00 = (''bgeu'')))) then return RISCV_BGEU
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val btype_mnemonic_forwards_matches : bop -> bool\<close>\<close>

fun btype_mnemonic_forwards_matches  :: " bop \<Rightarrow> bool "  where 
     " btype_mnemonic_forwards_matches RISCV_BEQ = ( True )"
|" btype_mnemonic_forwards_matches RISCV_BNE = ( True )"
|" btype_mnemonic_forwards_matches RISCV_BLT = ( True )"
|" btype_mnemonic_forwards_matches RISCV_BGE = ( True )"
|" btype_mnemonic_forwards_matches RISCV_BLTU = ( True )"
|" btype_mnemonic_forwards_matches RISCV_BGEU = ( True )"


\<comment> \<open>\<open>val btype_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition btype_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " btype_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''beq'')))) then True
   else if (((p00 = (''bne'')))) then True
   else if (((p00 = (''blt'')))) then True
   else if (((p00 = (''bge'')))) then True
   else if (((p00 = (''bltu'')))) then True
   else if (((p00 = (''bgeu'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val btype_mnemonic_matches_prefix : string -> maybe ((bop * ii))\<close>\<close>

\<comment> \<open>\<open>val _s520_ : string -> maybe string\<close>\<close>

definition s520  :: " string \<Rightarrow>(string)option "  where 
     " s520 s5210 = (
   (let s5220 = s5210 in
   if ((string_startswith s5220 (''bgeu''))) then  
  (case  ((string_drop s5220 ((string_length (''bgeu''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5210  :: " string "


\<comment> \<open>\<open>val _s516_ : string -> maybe string\<close>\<close>

definition s516  :: " string \<Rightarrow>(string)option "  where 
     " s516 s5170 = (
   (let s5180 = s5170 in
   if ((string_startswith s5180 (''bltu''))) then  
  (case  ((string_drop s5180 ((string_length (''bltu''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5170  :: " string "


\<comment> \<open>\<open>val _s512_ : string -> maybe string\<close>\<close>

definition s512  :: " string \<Rightarrow>(string)option "  where 
     " s512 s5130 = (
   (let s5140 = s5130 in
   if ((string_startswith s5140 (''bge''))) then  
  (case  ((string_drop s5140 ((string_length (''bge''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5130  :: " string "


\<comment> \<open>\<open>val _s508_ : string -> maybe string\<close>\<close>

definition s508  :: " string \<Rightarrow>(string)option "  where 
     " s508 s5090 = (
   (let s5100 = s5090 in
   if ((string_startswith s5100 (''blt''))) then  
  (case  ((string_drop s5100 ((string_length (''blt''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5090  :: " string "


\<comment> \<open>\<open>val _s504_ : string -> maybe string\<close>\<close>

definition s504  :: " string \<Rightarrow>(string)option "  where 
     " s504 s5050 = (
   (let s5060 = s5050 in
   if ((string_startswith s5060 (''bne''))) then  
  (case  ((string_drop s5060 ((string_length (''bne''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5050  :: " string "


\<comment> \<open>\<open>val _s500_ : string -> maybe string\<close>\<close>

definition s500  :: " string \<Rightarrow>(string)option "  where 
     " s500 s5010 = (
   (let s5020 = s5010 in
   if ((string_startswith s5020 (''beq''))) then  
  (case  ((string_drop s5020 ((string_length (''beq''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5010  :: " string "


definition btype_mnemonic_matches_prefix  :: " string \<Rightarrow>(bop*int)option "  where 
     " btype_mnemonic_matches_prefix arg1 = (
   (let s5030 = arg1 in
   if ((case  ((s500 s5030)) of   Some (s1) => True | _ => False )) then  
  (case  s500 s5030 of
      (Some (s1)) =>
  Some (RISCV_BEQ, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s504 s5030)) of   Some (s1) => True | _ => False )) then  
  (case  s504 s5030 of
      (Some (s1)) =>
  Some (RISCV_BNE, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s508 s5030)) of   Some (s1) => True | _ => False )) then  
  (case  s508 s5030 of
      (Some (s1)) =>
  Some (RISCV_BLT, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s512 s5030)) of   Some (s1) => True | _ => False )) then  
  (case  s512 s5030 of
      (Some (s1)) =>
  Some (RISCV_BGE, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s516 s5030)) of   Some (s1) => True | _ => False )) then  
  (case  s516 s5030 of
      (Some (s1)) =>
  Some (RISCV_BLTU, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s520 s5030)) of   Some (s1) => True | _ => False )) then  
  (case  s520 s5030 of
      (Some (s1)) =>
  Some (RISCV_BGEU, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_iop_forwards : iop -> mword ty3\<close>\<close>

fun encdec_iop_forwards  :: " iop \<Rightarrow>(3)Word.word "  where 
     " encdec_iop_forwards RISCV_ADDI = ( (vec_of_bits [B0,B0,B0]  ::  3 Word.word))"
|" encdec_iop_forwards RISCV_SLTI = ( (vec_of_bits [B0,B1,B0]  ::  3 Word.word))"
|" encdec_iop_forwards RISCV_SLTIU = ( (vec_of_bits [B0,B1,B1]  ::  3 Word.word))"
|" encdec_iop_forwards RISCV_ANDI = ( (vec_of_bits [B1,B1,B1]  ::  3 Word.word))"
|" encdec_iop_forwards RISCV_ORI = ( (vec_of_bits [B1,B1,B0]  ::  3 Word.word))"
|" encdec_iop_forwards RISCV_XORI = ( (vec_of_bits [B1,B0,B0]  ::  3 Word.word))"


\<comment> \<open>\<open>val encdec_iop_backwards : mword ty3 -> M iop\<close>\<close>

definition encdec_iop_backwards  :: "(3)Word.word \<Rightarrow>((register_value),(iop),(exception))monad "  where 
     " encdec_iop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then return RISCV_ADDI
   else if (((b__0 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then return RISCV_SLTI
   else if (((b__0 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then return RISCV_SLTIU
   else if (((b__0 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) then return RISCV_ANDI
   else if (((b__0 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then return RISCV_ORI
   else if (((b__0 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then return RISCV_XORI
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val encdec_iop_forwards_matches : iop -> bool\<close>\<close>

fun encdec_iop_forwards_matches  :: " iop \<Rightarrow> bool "  where 
     " encdec_iop_forwards_matches RISCV_ADDI = ( True )"
|" encdec_iop_forwards_matches RISCV_SLTI = ( True )"
|" encdec_iop_forwards_matches RISCV_SLTIU = ( True )"
|" encdec_iop_forwards_matches RISCV_ANDI = ( True )"
|" encdec_iop_forwards_matches RISCV_ORI = ( True )"
|" encdec_iop_forwards_matches RISCV_XORI = ( True )"


\<comment> \<open>\<open>val encdec_iop_backwards_matches : mword ty3 -> bool\<close>\<close>

definition encdec_iop_backwards_matches  :: "(3)Word.word \<Rightarrow> bool "  where 
     " encdec_iop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) then True
   else False))" 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val itype_mnemonic_forwards : iop -> string\<close>\<close>

fun itype_mnemonic_forwards  :: " iop \<Rightarrow> string "  where 
     " itype_mnemonic_forwards RISCV_ADDI = ( (''addi''))"
|" itype_mnemonic_forwards RISCV_SLTI = ( (''slti''))"
|" itype_mnemonic_forwards RISCV_SLTIU = ( (''sltiu''))"
|" itype_mnemonic_forwards RISCV_XORI = ( (''xori''))"
|" itype_mnemonic_forwards RISCV_ORI = ( (''ori''))"
|" itype_mnemonic_forwards RISCV_ANDI = ( (''andi''))"


\<comment> \<open>\<open>val itype_mnemonic_backwards : string -> M iop\<close>\<close>

definition itype_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(iop),(exception))monad "  where 
     " itype_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''addi'')))) then return RISCV_ADDI
   else if (((p00 = (''slti'')))) then return RISCV_SLTI
   else if (((p00 = (''sltiu'')))) then return RISCV_SLTIU
   else if (((p00 = (''xori'')))) then return RISCV_XORI
   else if (((p00 = (''ori'')))) then return RISCV_ORI
   else if (((p00 = (''andi'')))) then return RISCV_ANDI
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val itype_mnemonic_forwards_matches : iop -> bool\<close>\<close>

fun itype_mnemonic_forwards_matches  :: " iop \<Rightarrow> bool "  where 
     " itype_mnemonic_forwards_matches RISCV_ADDI = ( True )"
|" itype_mnemonic_forwards_matches RISCV_SLTI = ( True )"
|" itype_mnemonic_forwards_matches RISCV_SLTIU = ( True )"
|" itype_mnemonic_forwards_matches RISCV_XORI = ( True )"
|" itype_mnemonic_forwards_matches RISCV_ORI = ( True )"
|" itype_mnemonic_forwards_matches RISCV_ANDI = ( True )"


\<comment> \<open>\<open>val itype_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition itype_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " itype_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''addi'')))) then True
   else if (((p00 = (''slti'')))) then True
   else if (((p00 = (''sltiu'')))) then True
   else if (((p00 = (''xori'')))) then True
   else if (((p00 = (''ori'')))) then True
   else if (((p00 = (''andi'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val itype_mnemonic_matches_prefix : string -> maybe ((iop * ii))\<close>\<close>

\<comment> \<open>\<open>val _s544_ : string -> maybe string\<close>\<close>

definition s544  :: " string \<Rightarrow>(string)option "  where 
     " s544 s5450 = (
   (let s5460 = s5450 in
   if ((string_startswith s5460 (''andi''))) then  
  (case  ((string_drop s5460 ((string_length (''andi''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5450  :: " string "


\<comment> \<open>\<open>val _s540_ : string -> maybe string\<close>\<close>

definition s540  :: " string \<Rightarrow>(string)option "  where 
     " s540 s5410 = (
   (let s5420 = s5410 in
   if ((string_startswith s5420 (''ori''))) then  
  (case  ((string_drop s5420 ((string_length (''ori''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5410  :: " string "


\<comment> \<open>\<open>val _s536_ : string -> maybe string\<close>\<close>

definition s536  :: " string \<Rightarrow>(string)option "  where 
     " s536 s5370 = (
   (let s5380 = s5370 in
   if ((string_startswith s5380 (''xori''))) then  
  (case  ((string_drop s5380 ((string_length (''xori''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5370  :: " string "


\<comment> \<open>\<open>val _s532_ : string -> maybe string\<close>\<close>

definition s532  :: " string \<Rightarrow>(string)option "  where 
     " s532 s5330 = (
   (let s5340 = s5330 in
   if ((string_startswith s5340 (''sltiu''))) then  
  (case  ((string_drop s5340 ((string_length (''sltiu''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5330  :: " string "


\<comment> \<open>\<open>val _s528_ : string -> maybe string\<close>\<close>

definition s528  :: " string \<Rightarrow>(string)option "  where 
     " s528 s5290 = (
   (let s5300 = s5290 in
   if ((string_startswith s5300 (''slti''))) then  
  (case  ((string_drop s5300 ((string_length (''slti''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5290  :: " string "


\<comment> \<open>\<open>val _s524_ : string -> maybe string\<close>\<close>

definition s524  :: " string \<Rightarrow>(string)option "  where 
     " s524 s5250 = (
   (let s5260 = s5250 in
   if ((string_startswith s5260 (''addi''))) then  
  (case  ((string_drop s5260 ((string_length (''addi''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5250  :: " string "


definition itype_mnemonic_matches_prefix  :: " string \<Rightarrow>(iop*int)option "  where 
     " itype_mnemonic_matches_prefix arg1 = (
   (let s5270 = arg1 in
   if ((case  ((s524 s5270)) of   Some (s1) => True | _ => False )) then  
  (case  s524 s5270 of
      (Some (s1)) =>
  Some (RISCV_ADDI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s528 s5270)) of   Some (s1) => True | _ => False )) then  
  (case  s528 s5270 of
      (Some (s1)) =>
  Some (RISCV_SLTI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s532 s5270)) of   Some (s1) => True | _ => False )) then  
  (case  s532 s5270 of
      (Some (s1)) =>
  Some (RISCV_SLTIU, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s536 s5270)) of   Some (s1) => True | _ => False )) then  
  (case  s536 s5270 of
      (Some (s1)) =>
  Some (RISCV_XORI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s540 s5270)) of   Some (s1) => True | _ => False )) then  
  (case  s540 s5270 of
      (Some (s1)) =>
  Some (RISCV_ORI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s544 s5270)) of   Some (s1) => True | _ => False )) then  
  (case  s544 s5270 of
      (Some (s1)) =>
  Some (RISCV_ANDI, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_sop_forwards : sop -> mword ty3\<close>\<close>

fun encdec_sop_forwards  :: " sop \<Rightarrow>(3)Word.word "  where 
     " encdec_sop_forwards RISCV_SLLI = ( (vec_of_bits [B0,B0,B1]  ::  3 Word.word))"
|" encdec_sop_forwards RISCV_SRLI = ( (vec_of_bits [B1,B0,B1]  ::  3 Word.word))"
|" encdec_sop_forwards RISCV_SRAI = ( (vec_of_bits [B1,B0,B1]  ::  3 Word.word))"


\<comment> \<open>\<open>val encdec_sop_backwards : mword ty3 -> M sop\<close>\<close>

definition encdec_sop_backwards  :: "(3)Word.word \<Rightarrow>((register_value),(sop),(exception))monad "  where 
     " encdec_sop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then return RISCV_SLLI
   else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then return RISCV_SRLI
   else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then return RISCV_SRAI
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val encdec_sop_forwards_matches : sop -> bool\<close>\<close>

fun encdec_sop_forwards_matches  :: " sop \<Rightarrow> bool "  where 
     " encdec_sop_forwards_matches RISCV_SLLI = ( True )"
|" encdec_sop_forwards_matches RISCV_SRLI = ( True )"
|" encdec_sop_forwards_matches RISCV_SRAI = ( True )"


\<comment> \<open>\<open>val encdec_sop_backwards_matches : mword ty3 -> bool\<close>\<close>

definition encdec_sop_backwards_matches  :: "(3)Word.word \<Rightarrow> bool "  where 
     " encdec_sop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) then True
   else False))" 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val shiftiop_mnemonic_forwards : sop -> string\<close>\<close>

fun shiftiop_mnemonic_forwards  :: " sop \<Rightarrow> string "  where 
     " shiftiop_mnemonic_forwards RISCV_SLLI = ( (''slli''))"
|" shiftiop_mnemonic_forwards RISCV_SRLI = ( (''srli''))"
|" shiftiop_mnemonic_forwards RISCV_SRAI = ( (''srai''))"


\<comment> \<open>\<open>val shiftiop_mnemonic_backwards : string -> M sop\<close>\<close>

definition shiftiop_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(sop),(exception))monad "  where 
     " shiftiop_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slli'')))) then return RISCV_SLLI
   else if (((p00 = (''srli'')))) then return RISCV_SRLI
   else if (((p00 = (''srai'')))) then return RISCV_SRAI
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val shiftiop_mnemonic_forwards_matches : sop -> bool\<close>\<close>

fun shiftiop_mnemonic_forwards_matches  :: " sop \<Rightarrow> bool "  where 
     " shiftiop_mnemonic_forwards_matches RISCV_SLLI = ( True )"
|" shiftiop_mnemonic_forwards_matches RISCV_SRLI = ( True )"
|" shiftiop_mnemonic_forwards_matches RISCV_SRAI = ( True )"


\<comment> \<open>\<open>val shiftiop_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition shiftiop_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " shiftiop_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slli'')))) then True
   else if (((p00 = (''srli'')))) then True
   else if (((p00 = (''srai'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val shiftiop_mnemonic_matches_prefix : string -> maybe ((sop * ii))\<close>\<close>

\<comment> \<open>\<open>val _s556_ : string -> maybe string\<close>\<close>

definition s556  :: " string \<Rightarrow>(string)option "  where 
     " s556 s5570 = (
   (let s5580 = s5570 in
   if ((string_startswith s5580 (''srai''))) then  
  (case  ((string_drop s5580 ((string_length (''srai''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5570  :: " string "


\<comment> \<open>\<open>val _s552_ : string -> maybe string\<close>\<close>

definition s552  :: " string \<Rightarrow>(string)option "  where 
     " s552 s5530 = (
   (let s5540 = s5530 in
   if ((string_startswith s5540 (''srli''))) then  
  (case  ((string_drop s5540 ((string_length (''srli''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5530  :: " string "


\<comment> \<open>\<open>val _s548_ : string -> maybe string\<close>\<close>

definition s548  :: " string \<Rightarrow>(string)option "  where 
     " s548 s5490 = (
   (let s5500 = s5490 in
   if ((string_startswith s5500 (''slli''))) then  
  (case  ((string_drop s5500 ((string_length (''slli''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5490  :: " string "


definition shiftiop_mnemonic_matches_prefix  :: " string \<Rightarrow>(sop*int)option "  where 
     " shiftiop_mnemonic_matches_prefix arg1 = (
   (let s5510 = arg1 in
   if ((case  ((s548 s5510)) of   Some (s1) => True | _ => False )) then  
  (case  s548 s5510 of
      (Some (s1)) =>
  Some (RISCV_SLLI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s552 s5510)) of   Some (s1) => True | _ => False )) then  
  (case  s552 s5510 of
      (Some (s1)) =>
  Some (RISCV_SRLI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s556 s5510)) of   Some (s1) => True | _ => False )) then  
  (case  s556 s5510 of
      (Some (s1)) =>
  Some (RISCV_SRAI, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val rtype_mnemonic_forwards : rop -> string\<close>\<close>

fun rtype_mnemonic_forwards  :: " rop \<Rightarrow> string "  where 
     " rtype_mnemonic_forwards RISCV_ADD = ( (''add''))"
|" rtype_mnemonic_forwards RISCV_SLT = ( (''slt''))"
|" rtype_mnemonic_forwards RISCV_SLTU = ( (''sltu''))"
|" rtype_mnemonic_forwards RISCV_AND = ( (''and''))"
|" rtype_mnemonic_forwards RISCV_OR = ( (''or''))"
|" rtype_mnemonic_forwards RISCV_XOR = ( (''xor''))"
|" rtype_mnemonic_forwards RISCV_SLL = ( (''sll''))"
|" rtype_mnemonic_forwards RISCV_SRL = ( (''srl''))"
|" rtype_mnemonic_forwards RISCV_SUB = ( (''sub''))"
|" rtype_mnemonic_forwards RISCV_SRA = ( (''sra''))"


\<comment> \<open>\<open>val rtype_mnemonic_backwards : string -> M rop\<close>\<close>

definition rtype_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(rop),(exception))monad "  where 
     " rtype_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''add'')))) then return RISCV_ADD
   else if (((p00 = (''slt'')))) then return RISCV_SLT
   else if (((p00 = (''sltu'')))) then return RISCV_SLTU
   else if (((p00 = (''and'')))) then return RISCV_AND
   else if (((p00 = (''or'')))) then return RISCV_OR
   else if (((p00 = (''xor'')))) then return RISCV_XOR
   else if (((p00 = (''sll'')))) then return RISCV_SLL
   else if (((p00 = (''srl'')))) then return RISCV_SRL
   else if (((p00 = (''sub'')))) then return RISCV_SUB
   else if (((p00 = (''sra'')))) then return RISCV_SRA
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val rtype_mnemonic_forwards_matches : rop -> bool\<close>\<close>

fun rtype_mnemonic_forwards_matches  :: " rop \<Rightarrow> bool "  where 
     " rtype_mnemonic_forwards_matches RISCV_ADD = ( True )"
|" rtype_mnemonic_forwards_matches RISCV_SLT = ( True )"
|" rtype_mnemonic_forwards_matches RISCV_SLTU = ( True )"
|" rtype_mnemonic_forwards_matches RISCV_AND = ( True )"
|" rtype_mnemonic_forwards_matches RISCV_OR = ( True )"
|" rtype_mnemonic_forwards_matches RISCV_XOR = ( True )"
|" rtype_mnemonic_forwards_matches RISCV_SLL = ( True )"
|" rtype_mnemonic_forwards_matches RISCV_SRL = ( True )"
|" rtype_mnemonic_forwards_matches RISCV_SUB = ( True )"
|" rtype_mnemonic_forwards_matches RISCV_SRA = ( True )"


\<comment> \<open>\<open>val rtype_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition rtype_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " rtype_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''add'')))) then True
   else if (((p00 = (''slt'')))) then True
   else if (((p00 = (''sltu'')))) then True
   else if (((p00 = (''and'')))) then True
   else if (((p00 = (''or'')))) then True
   else if (((p00 = (''xor'')))) then True
   else if (((p00 = (''sll'')))) then True
   else if (((p00 = (''srl'')))) then True
   else if (((p00 = (''sub'')))) then True
   else if (((p00 = (''sra'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val rtype_mnemonic_matches_prefix : string -> maybe ((rop * ii))\<close>\<close>

\<comment> \<open>\<open>val _s596_ : string -> maybe string\<close>\<close>

definition s596  :: " string \<Rightarrow>(string)option "  where 
     " s596 s5970 = (
   (let s5980 = s5970 in
   if ((string_startswith s5980 (''sra''))) then  
  (case  ((string_drop s5980 ((string_length (''sra''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5970  :: " string "


\<comment> \<open>\<open>val _s592_ : string -> maybe string\<close>\<close>

definition s592  :: " string \<Rightarrow>(string)option "  where 
     " s592 s5930 = (
   (let s5940 = s5930 in
   if ((string_startswith s5940 (''sub''))) then  
  (case  ((string_drop s5940 ((string_length (''sub''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5930  :: " string "


\<comment> \<open>\<open>val _s588_ : string -> maybe string\<close>\<close>

definition s588  :: " string \<Rightarrow>(string)option "  where 
     " s588 s5890 = (
   (let s5900 = s5890 in
   if ((string_startswith s5900 (''srl''))) then  
  (case  ((string_drop s5900 ((string_length (''srl''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5890  :: " string "


\<comment> \<open>\<open>val _s584_ : string -> maybe string\<close>\<close>

definition s584  :: " string \<Rightarrow>(string)option "  where 
     " s584 s5850 = (
   (let s5860 = s5850 in
   if ((string_startswith s5860 (''sll''))) then  
  (case  ((string_drop s5860 ((string_length (''sll''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5850  :: " string "


\<comment> \<open>\<open>val _s580_ : string -> maybe string\<close>\<close>

definition s580  :: " string \<Rightarrow>(string)option "  where 
     " s580 s5810 = (
   (let s5820 = s5810 in
   if ((string_startswith s5820 (''xor''))) then  
  (case  ((string_drop s5820 ((string_length (''xor''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5810  :: " string "


\<comment> \<open>\<open>val _s576_ : string -> maybe string\<close>\<close>

definition s576  :: " string \<Rightarrow>(string)option "  where 
     " s576 s5770 = (
   (let s5780 = s5770 in
   if ((string_startswith s5780 (''or''))) then  
  (case  ((string_drop s5780 ((string_length (''or''))))) of   s1 => Some s1 )
   else None))" 
  for  s5770  :: " string "


\<comment> \<open>\<open>val _s572_ : string -> maybe string\<close>\<close>

definition s572  :: " string \<Rightarrow>(string)option "  where 
     " s572 s5730 = (
   (let s5740 = s5730 in
   if ((string_startswith s5740 (''and''))) then  
  (case  ((string_drop s5740 ((string_length (''and''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5730  :: " string "


\<comment> \<open>\<open>val _s568_ : string -> maybe string\<close>\<close>

definition s568  :: " string \<Rightarrow>(string)option "  where 
     " s568 s5690 = (
   (let s5700 = s5690 in
   if ((string_startswith s5700 (''sltu''))) then  
  (case  ((string_drop s5700 ((string_length (''sltu''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5690  :: " string "


\<comment> \<open>\<open>val _s564_ : string -> maybe string\<close>\<close>

definition s564  :: " string \<Rightarrow>(string)option "  where 
     " s564 s5650 = (
   (let s5660 = s5650 in
   if ((string_startswith s5660 (''slt''))) then  
  (case  ((string_drop s5660 ((string_length (''slt''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5650  :: " string "


\<comment> \<open>\<open>val _s560_ : string -> maybe string\<close>\<close>

definition s560  :: " string \<Rightarrow>(string)option "  where 
     " s560 s5610 = (
   (let s5620 = s5610 in
   if ((string_startswith s5620 (''add''))) then  
  (case  ((string_drop s5620 ((string_length (''add''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s5610  :: " string "


definition rtype_mnemonic_matches_prefix  :: " string \<Rightarrow>(rop*int)option "  where 
     " rtype_mnemonic_matches_prefix arg1 = (
   (let s5630 = arg1 in
   if ((case  ((s560 s5630)) of   Some (s1) => True | _ => False )) then  
  (case  s560 s5630 of
      (Some (s1)) =>
  Some (RISCV_ADD, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s564 s5630)) of   Some (s1) => True | _ => False )) then  
  (case  s564 s5630 of
      (Some (s1)) =>
  Some (RISCV_SLT, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s568 s5630)) of   Some (s1) => True | _ => False )) then  
  (case  s568 s5630 of
      (Some (s1)) =>
  Some (RISCV_SLTU, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s572 s5630)) of   Some (s1) => True | _ => False )) then  
  (case  s572 s5630 of
      (Some (s1)) =>
  Some (RISCV_AND, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s576 s5630)) of   Some (s1) => True | _ => False )) then  
  (case  s576 s5630 of
      (Some (s1)) =>
  Some (RISCV_OR, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s580 s5630)) of   Some (s1) => True | _ => False )) then  
  (case  s580 s5630 of
      (Some (s1)) =>
  Some (RISCV_XOR, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s584 s5630)) of   Some (s1) => True | _ => False )) then  
  (case  s584 s5630 of
      (Some (s1)) =>
  Some (RISCV_SLL, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s588 s5630)) of   Some (s1) => True | _ => False )) then  
  (case  s588 s5630 of
      (Some (s1)) =>
  Some (RISCV_SRL, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s592 s5630)) of   Some (s1) => True | _ => False )) then  
  (case  s592 s5630 of
      (Some (s1)) =>
  Some (RISCV_SUB, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s596 s5630)) of   Some (s1) => True | _ => False )) then  
  (case  s596 s5630 of
      (Some (s1)) =>
  Some (RISCV_SRA, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val extend_value : forall 'int8_times_n. Size 'int8_times_n => bool -> MemoryOpResult (mword 'int8_times_n) -> MemoryOpResult (mword ty32)\<close>\<close>

fun extend_value  :: " bool \<Rightarrow>(('int8_times_n::len)Word.word)MemoryOpResult \<Rightarrow>((32)Word.word)MemoryOpResult "  where 
     " extend_value is_unsigned (MemValue (v)) = (
      MemValue (if is_unsigned then (EXTZ (( 32 :: int)::ii) v  ::  32 Word.word)
                else (EXTS (( 32 :: int)::ii) v  ::  32 Word.word)))" 
  for  is_unsigned  :: " bool " 
  and  v  :: "('int8_times_n::len)Word.word "
|" extend_value is_unsigned (MemException (e)) = ( MemException e )" 
  for  is_unsigned  :: " bool " 
  and  e  :: " ExceptionType "


\<comment> \<open>\<open>val process_load : forall 'int8_times_n. Size 'int8_times_n => mword ty5 -> mword ty32 -> MemoryOpResult (mword 'int8_times_n) -> bool -> M Retired\<close>\<close>

definition process_load  :: "(5)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(('int8_times_n::len)Word.word)MemoryOpResult \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " process_load rd addr value1 is_unsigned = (
   (case  ((extend_value is_unsigned value1  :: ( 32 Word.word) MemoryOpResult)) of
     MemValue (result) => wX ((regidx_to_regno rd)) result \<then> return RETIRE_SUCCESS
   | MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
   ))" 
  for  rd  :: "(5)Word.word " 
  and  addr  :: "(32)Word.word " 
  and  value1  :: "(('int8_times_n::len)Word.word)MemoryOpResult " 
  and  is_unsigned  :: " bool "


\<comment> \<open>\<open>val check_misaligned : mword ty32 -> word_width -> bool\<close>\<close>

definition check_misaligned  :: "(32)Word.word \<Rightarrow> word_width \<Rightarrow> bool "  where 
     " check_misaligned (vaddr :: xlenbits) (width :: word_width) = (
   if ((plat_enable_misaligned_access () )) then False
   else
     (case  width of
       BYTE => False
     | HALF => (((bit_to_bool ((access_vec_dec vaddr (( 0 :: int)::ii))))) = True)
     | WORD =>
        ((((((bit_to_bool ((access_vec_dec vaddr (( 0 :: int)::ii))))) = True))) \<or> (((((bit_to_bool ((access_vec_dec vaddr (( 1 :: int)::ii))))) = True))))
     | DOUBLE =>
        ((((((bit_to_bool ((access_vec_dec vaddr (( 0 :: int)::ii))))) = True))) \<or> ((((((((bit_to_bool ((access_vec_dec vaddr (( 1 :: int)::ii))))) = True))) \<or> (((((bit_to_bool ((access_vec_dec vaddr (( 2 :: int)::ii))))) = True)))))))
     ))" 
  for  vaddr  :: "(32)Word.word " 
  and  width  :: " word_width "


\<comment> \<open>\<open>val maybe_aq_forwards : bool -> string\<close>\<close>

fun maybe_aq_forwards  :: " bool \<Rightarrow> string "  where 
     " maybe_aq_forwards True = ( (''.aq''))"
|" maybe_aq_forwards False = ( (''''))"


\<comment> \<open>\<open>val maybe_aq_backwards : string -> M bool\<close>\<close>

definition maybe_aq_backwards  :: " string \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " maybe_aq_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''.aq'')))) then return True
   else if (((p00 = ('''')))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_aq_forwards_matches : bool -> bool\<close>\<close>

fun maybe_aq_forwards_matches  :: " bool \<Rightarrow> bool "  where 
     " maybe_aq_forwards_matches True = ( True )"
|" maybe_aq_forwards_matches False = ( True )"


\<comment> \<open>\<open>val maybe_aq_backwards_matches : string -> bool\<close>\<close>

definition maybe_aq_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " maybe_aq_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''.aq'')))) then True
   else if (((p00 = ('''')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_aq_matches_prefix : string -> maybe ((bool * ii))\<close>\<close>

\<comment> \<open>\<open>val _s604_ : string -> maybe string\<close>\<close>

definition s604  :: " string \<Rightarrow>(string)option "  where 
     " s604 s6050 = (
   (let s6060 = s6050 in
   if ((string_startswith s6060 (''''))) then  
  (case  ((string_drop s6060 ((string_length (''''))))) of   s1 => Some s1 )
   else None))" 
  for  s6050  :: " string "


\<comment> \<open>\<open>val _s600_ : string -> maybe string\<close>\<close>

definition s600  :: " string \<Rightarrow>(string)option "  where 
     " s600 s6010 = (
   (let s6020 = s6010 in
   if ((string_startswith s6020 (''.aq''))) then  
  (case  ((string_drop s6020 ((string_length (''.aq''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6010  :: " string "


definition maybe_aq_matches_prefix  :: " string \<Rightarrow>(bool*int)option "  where 
     " maybe_aq_matches_prefix arg1 = (
   (let s6030 = arg1 in
   if ((case  ((s600 s6030)) of   Some (s1) => True | _ => False )) then  
  (case  s600 s6030 of
      (Some (s1)) =>
  Some (True, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s604 s6030)) of   Some (s1) => True | _ => False )) then  
  (case  s604 s6030 of
      (Some (s1)) =>
  Some (False, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_rl_forwards : bool -> string\<close>\<close>

fun maybe_rl_forwards  :: " bool \<Rightarrow> string "  where 
     " maybe_rl_forwards True = ( (''.rl''))"
|" maybe_rl_forwards False = ( (''''))"


\<comment> \<open>\<open>val maybe_rl_backwards : string -> M bool\<close>\<close>

definition maybe_rl_backwards  :: " string \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " maybe_rl_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''.rl'')))) then return True
   else if (((p00 = ('''')))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_rl_forwards_matches : bool -> bool\<close>\<close>

fun maybe_rl_forwards_matches  :: " bool \<Rightarrow> bool "  where 
     " maybe_rl_forwards_matches True = ( True )"
|" maybe_rl_forwards_matches False = ( True )"


\<comment> \<open>\<open>val maybe_rl_backwards_matches : string -> bool\<close>\<close>

definition maybe_rl_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " maybe_rl_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''.rl'')))) then True
   else if (((p00 = ('''')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_rl_matches_prefix : string -> maybe ((bool * ii))\<close>\<close>

\<comment> \<open>\<open>val _s612_ : string -> maybe string\<close>\<close>

definition s612  :: " string \<Rightarrow>(string)option "  where 
     " s612 s6130 = (
   (let s6140 = s6130 in
   if ((string_startswith s6140 (''''))) then  
  (case  ((string_drop s6140 ((string_length (''''))))) of   s1 => Some s1 )
   else None))" 
  for  s6130  :: " string "


\<comment> \<open>\<open>val _s608_ : string -> maybe string\<close>\<close>

definition s608  :: " string \<Rightarrow>(string)option "  where 
     " s608 s6090 = (
   (let s6100 = s6090 in
   if ((string_startswith s6100 (''.rl''))) then  
  (case  ((string_drop s6100 ((string_length (''.rl''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6090  :: " string "


definition maybe_rl_matches_prefix  :: " string \<Rightarrow>(bool*int)option "  where 
     " maybe_rl_matches_prefix arg1 = (
   (let s6110 = arg1 in
   if ((case  ((s608 s6110)) of   Some (s1) => True | _ => False )) then  
  (case  s608 s6110 of
      (Some (s1)) =>
  Some (True, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s612 s6110)) of   Some (s1) => True | _ => False )) then  
  (case  s612 s6110 of
      (Some (s1)) =>
  Some (False, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_u_forwards : bool -> string\<close>\<close>

fun maybe_u_forwards  :: " bool \<Rightarrow> string "  where 
     " maybe_u_forwards True = ( (''u''))"
|" maybe_u_forwards False = ( (''''))"


\<comment> \<open>\<open>val maybe_u_backwards : string -> M bool\<close>\<close>

definition maybe_u_backwards  :: " string \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " maybe_u_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''u'')))) then return True
   else if (((p00 = ('''')))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_u_forwards_matches : bool -> bool\<close>\<close>

fun maybe_u_forwards_matches  :: " bool \<Rightarrow> bool "  where 
     " maybe_u_forwards_matches True = ( True )"
|" maybe_u_forwards_matches False = ( True )"


\<comment> \<open>\<open>val maybe_u_backwards_matches : string -> bool\<close>\<close>

definition maybe_u_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " maybe_u_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''u'')))) then True
   else if (((p00 = ('''')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_u_matches_prefix : string -> maybe ((bool * ii))\<close>\<close>

\<comment> \<open>\<open>val _s620_ : string -> maybe string\<close>\<close>

definition s620  :: " string \<Rightarrow>(string)option "  where 
     " s620 s6210 = (
   (let s6220 = s6210 in
   if ((string_startswith s6220 (''''))) then  
  (case  ((string_drop s6220 ((string_length (''''))))) of   s1 => Some s1 )
   else None))" 
  for  s6210  :: " string "


\<comment> \<open>\<open>val _s616_ : string -> maybe string\<close>\<close>

definition s616  :: " string \<Rightarrow>(string)option "  where 
     " s616 s6170 = (
   (let s6180 = s6170 in
   if ((string_startswith s6180 (''u''))) then  
  (case  ((string_drop s6180 ((string_length (''u''))))) of   s1 => Some s1 )
   else None))" 
  for  s6170  :: " string "


definition maybe_u_matches_prefix  :: " string \<Rightarrow>(bool*int)option "  where 
     " maybe_u_matches_prefix arg1 = (
   (let s6190 = arg1 in
   if ((case  ((s616 s6190)) of   Some (s1) => True | _ => False )) then  
  (case  s616 s6190 of
      (Some (s1)) =>
  Some (True, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s620 s6190)) of   Some (s1) => True | _ => False )) then  
  (case  s620 s6190 of
      (Some (s1)) =>
  Some (False, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val shiftw_mnemonic_forwards : sop -> string\<close>\<close>

fun shiftw_mnemonic_forwards  :: " sop \<Rightarrow> string "  where 
     " shiftw_mnemonic_forwards RISCV_SLLI = ( (''slli''))"
|" shiftw_mnemonic_forwards RISCV_SRLI = ( (''srli''))"
|" shiftw_mnemonic_forwards RISCV_SRAI = ( (''srai''))"


\<comment> \<open>\<open>val shiftw_mnemonic_backwards : string -> M sop\<close>\<close>

definition shiftw_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(sop),(exception))monad "  where 
     " shiftw_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slli'')))) then return RISCV_SLLI
   else if (((p00 = (''srli'')))) then return RISCV_SRLI
   else if (((p00 = (''srai'')))) then return RISCV_SRAI
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val shiftw_mnemonic_forwards_matches : sop -> bool\<close>\<close>

fun shiftw_mnemonic_forwards_matches  :: " sop \<Rightarrow> bool "  where 
     " shiftw_mnemonic_forwards_matches RISCV_SLLI = ( True )"
|" shiftw_mnemonic_forwards_matches RISCV_SRLI = ( True )"
|" shiftw_mnemonic_forwards_matches RISCV_SRAI = ( True )"


\<comment> \<open>\<open>val shiftw_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition shiftw_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " shiftw_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slli'')))) then True
   else if (((p00 = (''srli'')))) then True
   else if (((p00 = (''srai'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val shiftw_mnemonic_matches_prefix : string -> maybe ((sop * ii))\<close>\<close>

\<comment> \<open>\<open>val _s632_ : string -> maybe string\<close>\<close>

definition s632  :: " string \<Rightarrow>(string)option "  where 
     " s632 s6330 = (
   (let s6340 = s6330 in
   if ((string_startswith s6340 (''srai''))) then  
  (case  ((string_drop s6340 ((string_length (''srai''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6330  :: " string "


\<comment> \<open>\<open>val _s628_ : string -> maybe string\<close>\<close>

definition s628  :: " string \<Rightarrow>(string)option "  where 
     " s628 s6290 = (
   (let s6300 = s6290 in
   if ((string_startswith s6300 (''srli''))) then  
  (case  ((string_drop s6300 ((string_length (''srli''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6290  :: " string "


\<comment> \<open>\<open>val _s624_ : string -> maybe string\<close>\<close>

definition s624  :: " string \<Rightarrow>(string)option "  where 
     " s624 s6250 = (
   (let s6260 = s6250 in
   if ((string_startswith s6260 (''slli''))) then  
  (case  ((string_drop s6260 ((string_length (''slli''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6250  :: " string "


definition shiftw_mnemonic_matches_prefix  :: " string \<Rightarrow>(sop*int)option "  where 
     " shiftw_mnemonic_matches_prefix arg1 = (
   (let s6270 = arg1 in
   if ((case  ((s624 s6270)) of   Some (s1) => True | _ => False )) then  
  (case  s624 s6270 of
      (Some (s1)) =>
  Some (RISCV_SLLI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s628 s6270)) of   Some (s1) => True | _ => False )) then  
  (case  s628 s6270 of
      (Some (s1)) =>
  Some (RISCV_SRLI, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s632 s6270)) of   Some (s1) => True | _ => False )) then  
  (case  s632 s6270 of
      (Some (s1)) =>
  Some (RISCV_SRAI, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val rtypew_mnemonic_forwards : ropw -> string\<close>\<close>

fun rtypew_mnemonic_forwards  :: " ropw \<Rightarrow> string "  where 
     " rtypew_mnemonic_forwards RISCV_ADDW = ( (''addw''))"
|" rtypew_mnemonic_forwards RISCV_SUBW = ( (''subw''))"
|" rtypew_mnemonic_forwards RISCV_SLLW = ( (''sllw''))"
|" rtypew_mnemonic_forwards RISCV_SRLW = ( (''srlw''))"
|" rtypew_mnemonic_forwards RISCV_SRAW = ( (''sraw''))"


\<comment> \<open>\<open>val rtypew_mnemonic_backwards : string -> M ropw\<close>\<close>

definition rtypew_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(ropw),(exception))monad "  where 
     " rtypew_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''addw'')))) then return RISCV_ADDW
   else if (((p00 = (''subw'')))) then return RISCV_SUBW
   else if (((p00 = (''sllw'')))) then return RISCV_SLLW
   else if (((p00 = (''srlw'')))) then return RISCV_SRLW
   else if (((p00 = (''sraw'')))) then return RISCV_SRAW
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val rtypew_mnemonic_forwards_matches : ropw -> bool\<close>\<close>

fun rtypew_mnemonic_forwards_matches  :: " ropw \<Rightarrow> bool "  where 
     " rtypew_mnemonic_forwards_matches RISCV_ADDW = ( True )"
|" rtypew_mnemonic_forwards_matches RISCV_SUBW = ( True )"
|" rtypew_mnemonic_forwards_matches RISCV_SLLW = ( True )"
|" rtypew_mnemonic_forwards_matches RISCV_SRLW = ( True )"
|" rtypew_mnemonic_forwards_matches RISCV_SRAW = ( True )"


\<comment> \<open>\<open>val rtypew_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition rtypew_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " rtypew_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''addw'')))) then True
   else if (((p00 = (''subw'')))) then True
   else if (((p00 = (''sllw'')))) then True
   else if (((p00 = (''srlw'')))) then True
   else if (((p00 = (''sraw'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val rtypew_mnemonic_matches_prefix : string -> maybe ((ropw * ii))\<close>\<close>

\<comment> \<open>\<open>val _s652_ : string -> maybe string\<close>\<close>

definition s652  :: " string \<Rightarrow>(string)option "  where 
     " s652 s6530 = (
   (let s6540 = s6530 in
   if ((string_startswith s6540 (''sraw''))) then  
  (case  ((string_drop s6540 ((string_length (''sraw''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6530  :: " string "


\<comment> \<open>\<open>val _s648_ : string -> maybe string\<close>\<close>

definition s648  :: " string \<Rightarrow>(string)option "  where 
     " s648 s6490 = (
   (let s6500 = s6490 in
   if ((string_startswith s6500 (''srlw''))) then  
  (case  ((string_drop s6500 ((string_length (''srlw''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6490  :: " string "


\<comment> \<open>\<open>val _s644_ : string -> maybe string\<close>\<close>

definition s644  :: " string \<Rightarrow>(string)option "  where 
     " s644 s6450 = (
   (let s6460 = s6450 in
   if ((string_startswith s6460 (''sllw''))) then  
  (case  ((string_drop s6460 ((string_length (''sllw''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6450  :: " string "


\<comment> \<open>\<open>val _s640_ : string -> maybe string\<close>\<close>

definition s640  :: " string \<Rightarrow>(string)option "  where 
     " s640 s6410 = (
   (let s6420 = s6410 in
   if ((string_startswith s6420 (''subw''))) then  
  (case  ((string_drop s6420 ((string_length (''subw''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6410  :: " string "


\<comment> \<open>\<open>val _s636_ : string -> maybe string\<close>\<close>

definition s636  :: " string \<Rightarrow>(string)option "  where 
     " s636 s6370 = (
   (let s6380 = s6370 in
   if ((string_startswith s6380 (''addw''))) then  
  (case  ((string_drop s6380 ((string_length (''addw''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6370  :: " string "


definition rtypew_mnemonic_matches_prefix  :: " string \<Rightarrow>(ropw*int)option "  where 
     " rtypew_mnemonic_matches_prefix arg1 = (
   (let s6390 = arg1 in
   if ((case  ((s636 s6390)) of   Some (s1) => True | _ => False )) then  
  (case  s636 s6390 of
      (Some (s1)) =>
  Some (RISCV_ADDW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s640 s6390)) of   Some (s1) => True | _ => False )) then  
  (case  s640 s6390 of
      (Some (s1)) =>
  Some (RISCV_SUBW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s644 s6390)) of   Some (s1) => True | _ => False )) then  
  (case  s644 s6390 of
      (Some (s1)) =>
  Some (RISCV_SLLW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s648 s6390)) of   Some (s1) => True | _ => False )) then  
  (case  s648 s6390 of
      (Some (s1)) =>
  Some (RISCV_SRLW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s652 s6390)) of   Some (s1) => True | _ => False )) then  
  (case  s652 s6390 of
      (Some (s1)) =>
  Some (RISCV_SRAW, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val shiftiwop_mnemonic_forwards : sopw -> string\<close>\<close>

fun shiftiwop_mnemonic_forwards  :: " sopw \<Rightarrow> string "  where 
     " shiftiwop_mnemonic_forwards RISCV_SLLIW = ( (''slliw''))"
|" shiftiwop_mnemonic_forwards RISCV_SRLIW = ( (''srliw''))"
|" shiftiwop_mnemonic_forwards RISCV_SRAIW = ( (''sraiw''))"


\<comment> \<open>\<open>val shiftiwop_mnemonic_backwards : string -> M sopw\<close>\<close>

definition shiftiwop_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(sopw),(exception))monad "  where 
     " shiftiwop_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slliw'')))) then return RISCV_SLLIW
   else if (((p00 = (''srliw'')))) then return RISCV_SRLIW
   else if (((p00 = (''sraiw'')))) then return RISCV_SRAIW
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val shiftiwop_mnemonic_forwards_matches : sopw -> bool\<close>\<close>

fun shiftiwop_mnemonic_forwards_matches  :: " sopw \<Rightarrow> bool "  where 
     " shiftiwop_mnemonic_forwards_matches RISCV_SLLIW = ( True )"
|" shiftiwop_mnemonic_forwards_matches RISCV_SRLIW = ( True )"
|" shiftiwop_mnemonic_forwards_matches RISCV_SRAIW = ( True )"


\<comment> \<open>\<open>val shiftiwop_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition shiftiwop_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " shiftiwop_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''slliw'')))) then True
   else if (((p00 = (''srliw'')))) then True
   else if (((p00 = (''sraiw'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val shiftiwop_mnemonic_matches_prefix : string -> maybe ((sopw * ii))\<close>\<close>

\<comment> \<open>\<open>val _s664_ : string -> maybe string\<close>\<close>

definition s664  :: " string \<Rightarrow>(string)option "  where 
     " s664 s6650 = (
   (let s6660 = s6650 in
   if ((string_startswith s6660 (''sraiw''))) then  
  (case  ((string_drop s6660 ((string_length (''sraiw''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6650  :: " string "


\<comment> \<open>\<open>val _s660_ : string -> maybe string\<close>\<close>

definition s660  :: " string \<Rightarrow>(string)option "  where 
     " s660 s6610 = (
   (let s6620 = s6610 in
   if ((string_startswith s6620 (''srliw''))) then  
  (case  ((string_drop s6620 ((string_length (''srliw''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6610  :: " string "


\<comment> \<open>\<open>val _s656_ : string -> maybe string\<close>\<close>

definition s656  :: " string \<Rightarrow>(string)option "  where 
     " s656 s6570 = (
   (let s6580 = s6570 in
   if ((string_startswith s6580 (''slliw''))) then  
  (case  ((string_drop s6580 ((string_length (''slliw''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s6570  :: " string "


definition shiftiwop_mnemonic_matches_prefix  :: " string \<Rightarrow>(sopw*int)option "  where 
     " shiftiwop_mnemonic_matches_prefix arg1 = (
   (let s6590 = arg1 in
   if ((case  ((s656 s6590)) of   Some (s1) => True | _ => False )) then  
  (case  s656 s6590 of
      (Some (s1)) =>
  Some (RISCV_SLLIW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s660 s6590)) of   Some (s1) => True | _ => False )) then  
  (case  s660 s6590 of
      (Some (s1)) =>
  Some (RISCV_SRLIW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s664 s6590)) of   Some (s1) => True | _ => False )) then  
  (case  s664 s6590 of
      (Some (s1)) =>
  Some (RISCV_SRAIW, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_r_forwards : mword ty1 -> M string\<close>\<close>

definition bit_maybe_r_forwards  :: "(1)Word.word \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " bit_maybe_r_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then return (''r'')
   else if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then return ('''')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bit_maybe_r_backwards : string -> M (mword ty1)\<close>\<close>

definition bit_maybe_r_backwards  :: " string \<Rightarrow>((register_value),((1)Word.word),(exception))monad "  where 
     " bit_maybe_r_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''r'')))) then return (vec_of_bits [B1]  ::  1 Word.word)
   else if (((p00 = ('''')))) then return (vec_of_bits [B0]  ::  1 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_r_forwards_matches : mword ty1 -> bool\<close>\<close>

definition bit_maybe_r_forwards_matches  :: "(1)Word.word \<Rightarrow> bool "  where 
     " bit_maybe_r_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then True
   else False))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bit_maybe_r_backwards_matches : string -> bool\<close>\<close>

definition bit_maybe_r_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " bit_maybe_r_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''r'')))) then True
   else if (((p00 = ('''')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_r_matches_prefix : string -> maybe ((mword ty1 * ii))\<close>\<close>

\<comment> \<open>\<open>val _s672_ : string -> maybe string\<close>\<close>

definition s672  :: " string \<Rightarrow>(string)option "  where 
     " s672 s6730 = (
   (let s6740 = s6730 in
   if ((string_startswith s6740 (''''))) then  
  (case  ((string_drop s6740 ((string_length (''''))))) of   s1 => Some s1 )
   else None))" 
  for  s6730  :: " string "


\<comment> \<open>\<open>val _s668_ : string -> maybe string\<close>\<close>

definition s668  :: " string \<Rightarrow>(string)option "  where 
     " s668 s6690 = (
   (let s6700 = s6690 in
   if ((string_startswith s6700 (''r''))) then  
  (case  ((string_drop s6700 ((string_length (''r''))))) of   s1 => Some s1 )
   else None))" 
  for  s6690  :: " string "


definition bit_maybe_r_matches_prefix  :: " string \<Rightarrow>((1)Word.word*int)option "  where 
     " bit_maybe_r_matches_prefix arg1 = (
   (let s6710 = arg1 in
   if ((case  ((s668 s6710)) of   Some (s1) => True | _ => False )) then  
  (case  s668 s6710 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1] :: 1 Word.word), ((string_length arg1)) -
                                          ((string_length s1)))
  )
   else if ((case  ((s672 s6710)) of   Some (s1) => True | _ => False )) then  
  (case  s672 s6710 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0] :: 1 Word.word), ((string_length arg1)) -
                                          ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_w_forwards : mword ty1 -> M string\<close>\<close>

definition bit_maybe_w_forwards  :: "(1)Word.word \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " bit_maybe_w_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then return (''w'')
   else if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then return ('''')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bit_maybe_w_backwards : string -> M (mword ty1)\<close>\<close>

definition bit_maybe_w_backwards  :: " string \<Rightarrow>((register_value),((1)Word.word),(exception))monad "  where 
     " bit_maybe_w_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''w'')))) then return (vec_of_bits [B1]  ::  1 Word.word)
   else if (((p00 = ('''')))) then return (vec_of_bits [B0]  ::  1 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_w_forwards_matches : mword ty1 -> bool\<close>\<close>

definition bit_maybe_w_forwards_matches  :: "(1)Word.word \<Rightarrow> bool "  where 
     " bit_maybe_w_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then True
   else False))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bit_maybe_w_backwards_matches : string -> bool\<close>\<close>

definition bit_maybe_w_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " bit_maybe_w_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''w'')))) then True
   else if (((p00 = ('''')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_w_matches_prefix : string -> maybe ((mword ty1 * ii))\<close>\<close>

\<comment> \<open>\<open>val _s680_ : string -> maybe string\<close>\<close>

definition s680  :: " string \<Rightarrow>(string)option "  where 
     " s680 s6810 = (
   (let s6820 = s6810 in
   if ((string_startswith s6820 (''''))) then  
  (case  ((string_drop s6820 ((string_length (''''))))) of   s1 => Some s1 )
   else None))" 
  for  s6810  :: " string "


\<comment> \<open>\<open>val _s676_ : string -> maybe string\<close>\<close>

definition s676  :: " string \<Rightarrow>(string)option "  where 
     " s676 s6770 = (
   (let s6780 = s6770 in
   if ((string_startswith s6780 (''w''))) then  
  (case  ((string_drop s6780 ((string_length (''w''))))) of   s1 => Some s1 )
   else None))" 
  for  s6770  :: " string "


definition bit_maybe_w_matches_prefix  :: " string \<Rightarrow>((1)Word.word*int)option "  where 
     " bit_maybe_w_matches_prefix arg1 = (
   (let s6790 = arg1 in
   if ((case  ((s676 s6790)) of   Some (s1) => True | _ => False )) then  
  (case  s676 s6790 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1] :: 1 Word.word), ((string_length arg1)) -
                                          ((string_length s1)))
  )
   else if ((case  ((s680 s6790)) of   Some (s1) => True | _ => False )) then  
  (case  s680 s6790 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0] :: 1 Word.word), ((string_length arg1)) -
                                          ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_i_forwards : mword ty1 -> M string\<close>\<close>

definition bit_maybe_i_forwards  :: "(1)Word.word \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " bit_maybe_i_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then return (''i'')
   else if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then return ('''')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bit_maybe_i_backwards : string -> M (mword ty1)\<close>\<close>

definition bit_maybe_i_backwards  :: " string \<Rightarrow>((register_value),((1)Word.word),(exception))monad "  where 
     " bit_maybe_i_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''i'')))) then return (vec_of_bits [B1]  ::  1 Word.word)
   else if (((p00 = ('''')))) then return (vec_of_bits [B0]  ::  1 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_i_forwards_matches : mword ty1 -> bool\<close>\<close>

definition bit_maybe_i_forwards_matches  :: "(1)Word.word \<Rightarrow> bool "  where 
     " bit_maybe_i_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then True
   else False))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bit_maybe_i_backwards_matches : string -> bool\<close>\<close>

definition bit_maybe_i_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " bit_maybe_i_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''i'')))) then True
   else if (((p00 = ('''')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_i_matches_prefix : string -> maybe ((mword ty1 * ii))\<close>\<close>

\<comment> \<open>\<open>val _s688_ : string -> maybe string\<close>\<close>

definition s688  :: " string \<Rightarrow>(string)option "  where 
     " s688 s6890 = (
   (let s6900 = s6890 in
   if ((string_startswith s6900 (''''))) then  
  (case  ((string_drop s6900 ((string_length (''''))))) of   s1 => Some s1 )
   else None))" 
  for  s6890  :: " string "


\<comment> \<open>\<open>val _s684_ : string -> maybe string\<close>\<close>

definition s684  :: " string \<Rightarrow>(string)option "  where 
     " s684 s6850 = (
   (let s6860 = s6850 in
   if ((string_startswith s6860 (''i''))) then  
  (case  ((string_drop s6860 ((string_length (''i''))))) of   s1 => Some s1 )
   else None))" 
  for  s6850  :: " string "


definition bit_maybe_i_matches_prefix  :: " string \<Rightarrow>((1)Word.word*int)option "  where 
     " bit_maybe_i_matches_prefix arg1 = (
   (let s6870 = arg1 in
   if ((case  ((s684 s6870)) of   Some (s1) => True | _ => False )) then  
  (case  s684 s6870 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1] :: 1 Word.word), ((string_length arg1)) -
                                          ((string_length s1)))
  )
   else if ((case  ((s688 s6870)) of   Some (s1) => True | _ => False )) then  
  (case  s688 s6870 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0] :: 1 Word.word), ((string_length arg1)) -
                                          ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_o_forwards : mword ty1 -> M string\<close>\<close>

definition bit_maybe_o_forwards  :: "(1)Word.word \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " bit_maybe_o_forwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then return (''o'')
   else if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then return ('''')
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bit_maybe_o_backwards : string -> M (mword ty1)\<close>\<close>

definition bit_maybe_o_backwards  :: " string \<Rightarrow>((register_value),((1)Word.word),(exception))monad "  where 
     " bit_maybe_o_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''o'')))) then return (vec_of_bits [B1]  ::  1 Word.word)
   else if (((p00 = ('''')))) then return (vec_of_bits [B0]  ::  1 Word.word)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_o_forwards_matches : mword ty1 -> bool\<close>\<close>

definition bit_maybe_o_forwards_matches  :: "(1)Word.word \<Rightarrow> bool "  where 
     " bit_maybe_o_forwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B1]  ::  1 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0]  ::  1 Word.word)))) then True
   else False))" 
  for  arg1  :: "(1)Word.word "


\<comment> \<open>\<open>val bit_maybe_o_backwards_matches : string -> bool\<close>\<close>

definition bit_maybe_o_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " bit_maybe_o_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''o'')))) then True
   else if (((p00 = ('''')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val bit_maybe_o_matches_prefix : string -> maybe ((mword ty1 * ii))\<close>\<close>

\<comment> \<open>\<open>val _s696_ : string -> maybe string\<close>\<close>

definition s696  :: " string \<Rightarrow>(string)option "  where 
     " s696 s6970 = (
   (let s6980 = s6970 in
   if ((string_startswith s6980 (''''))) then  
  (case  ((string_drop s6980 ((string_length (''''))))) of   s1 => Some s1 )
   else None))" 
  for  s6970  :: " string "


\<comment> \<open>\<open>val _s692_ : string -> maybe string\<close>\<close>

definition s692  :: " string \<Rightarrow>(string)option "  where 
     " s692 s6930 = (
   (let s6940 = s6930 in
   if ((string_startswith s6940 (''o''))) then  
  (case  ((string_drop s6940 ((string_length (''o''))))) of   s1 => Some s1 )
   else None))" 
  for  s6930  :: " string "


definition bit_maybe_o_matches_prefix  :: " string \<Rightarrow>((1)Word.word*int)option "  where 
     " bit_maybe_o_matches_prefix arg1 = (
   (let s6950 = arg1 in
   if ((case  ((s692 s6950)) of   Some (s1) => True | _ => False )) then  
  (case  s692 s6950 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B1] :: 1 Word.word), ((string_length arg1)) -
                                          ((string_length s1)))
  )
   else if ((case  ((s696 s6950)) of   Some (s1) => True | _ => False )) then  
  (case  s696 s6950 of
      (Some (s1)) =>
  Some
    ((vec_of_bits [B0] :: 1 Word.word), ((string_length arg1)) -
                                          ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val fence_bits_forwards : mword ty4 -> M string\<close>\<close>

definition fence_bits_forwards  :: "(4)Word.word \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " fence_bits_forwards v__0 = (
      (let (i :: 1 bits) = ((subrange_vec_dec v__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) in
      (let (w :: 1 bits) = ((subrange_vec_dec v__0 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      (let (r :: 1 bits) = ((subrange_vec_dec v__0 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
      (let (o1 :: 1 bits) = ((subrange_vec_dec v__0 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
      (let (i :: 1 bits) = ((subrange_vec_dec v__0 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) in
      bit_maybe_i_forwards i \<bind> (\<lambda> (w__0 :: string) . 
      bit_maybe_o_forwards o1 \<bind> (\<lambda> (w__1 :: string) . 
      bit_maybe_r_forwards r \<bind> (\<lambda> (w__2 :: string) . 
      bit_maybe_w_forwards w \<bind> (\<lambda> (w__3 :: string) . 
      return ((string_append w__0
                 ((string_append w__1 ((string_append w__2 ((string_append w__3 ('''')))))))))))))))))))" 
  for  v__0  :: "(4)Word.word "


\<comment> \<open>\<open>val fence_bits_backwards : string -> M (mword ty4)\<close>\<close>

\<comment> \<open>\<open>val _s700_ : string -> maybe ((mword ty1 * mword ty1 * mword ty1 * mword ty1))\<close>\<close>

definition s700  :: " string \<Rightarrow>((1)Word.word*(1)Word.word*(1)Word.word*(1)Word.word)option "  where 
     " s700 s7020 = (
      (case  ((bit_maybe_i_matches_prefix s7020  ::  (( 1 Word.word * ii))option)) of
        Some ((i, s7030)) => 
  (case  ((string_drop s7020 s7030)) of
        s7040 =>
  (case  ((bit_maybe_o_matches_prefix s7040 :: (( 1 Word.word * ii)) option)) of
        Some ((o1, s7050)) =>
  (case  ((string_drop s7040 s7050)) of
        s7060 =>
  (case  ((bit_maybe_r_matches_prefix s7060 :: (( 1 Word.word * ii)) option)) of
        Some ((r, s7070)) =>
  (case  ((string_drop s7060 s7070)) of
        s7080 =>
  (case  ((bit_maybe_w_matches_prefix s7080 :: (( 1 Word.word * ii)) option)) of
        Some ((w, s7090)) =>
  (let p00 = (string_drop s7080 s7090) in
  if (((p00 = ('''')))) then Some (i, o1, r, w) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s7020  :: " string "


definition fence_bits_backwards  :: " string \<Rightarrow>((register_value),((4)Word.word),(exception))monad "  where 
     " fence_bits_backwards arg1 = (
   (let s7100 = arg1 in
   if ((case  ((s700 s7100  ::  (( 1 Word.word *  1 Word.word *  1 Word.word *  1 Word.word))option)) of
       Some ((i, o1, r, w)) => True
     | _ => False
     )) then  (case 
 (s700 s7100 :: (( 1 Word.word * 1 Word.word * 1 Word.word * 1 Word.word)) option) of
     (Some ((i, o1, r, w))) =>
 return
   ((concat_vec i
       ((concat_vec o1 ((concat_vec r w :: 2 Word.word)) :: 3 Word.word))
    :: 4 Word.word))
 )
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val fence_bits_forwards_matches : mword ty4 -> bool\<close>\<close>

definition fence_bits_forwards_matches  :: "(4)Word.word \<Rightarrow> bool "  where 
     " fence_bits_forwards_matches v__1 = ( True )" 
  for  v__1  :: "(4)Word.word "


\<comment> \<open>\<open>val fence_bits_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val _s711_ : string -> maybe ((mword ty1 * mword ty1 * mword ty1 * mword ty1))\<close>\<close>

definition s711  :: " string \<Rightarrow>((1)Word.word*(1)Word.word*(1)Word.word*(1)Word.word)option "  where 
     " s711 s7130 = (
      (case  ((bit_maybe_i_matches_prefix s7130  ::  (( 1 Word.word * ii))option)) of
        Some ((i, s7140)) => 
  (case  ((string_drop s7130 s7140)) of
        s7150 =>
  (case  ((bit_maybe_o_matches_prefix s7150 :: (( 1 Word.word * ii)) option)) of
        Some ((o1, s7160)) =>
  (case  ((string_drop s7150 s7160)) of
        s7170 =>
  (case  ((bit_maybe_r_matches_prefix s7170 :: (( 1 Word.word * ii)) option)) of
        Some ((r, s7180)) =>
  (case  ((string_drop s7170 s7180)) of
        s7190 =>
  (case  ((bit_maybe_w_matches_prefix s7190 :: (( 1 Word.word * ii)) option)) of
        Some ((w, s7200)) =>
  (let p00 = (string_drop s7190 s7200) in
  if (((p00 = ('''')))) then Some (i, o1, r, w) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s7130  :: " string "


definition fence_bits_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " fence_bits_backwards_matches arg1 = (
   (let s7210 = arg1 in
   if ((case  ((s711 s7210  ::  (( 1 Word.word *  1 Word.word *  1 Word.word *  1 Word.word))option)) of
       Some ((i, o1, r, w)) => True
     | _ => False
     )) then  (case 
 (s711 s7210 :: (( 1 Word.word * 1 Word.word * 1 Word.word * 1 Word.word)) option) of
     (Some ((i, o1, r, w))) =>
 True
 )
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val fence_bits_matches_prefix : string -> maybe ((mword ty4 * ii))\<close>\<close>

\<comment> \<open>\<open>val _s722_ : string -> maybe ((mword ty1 * mword ty1 * mword ty1 * mword ty1 * string))\<close>\<close>

definition s722  :: " string \<Rightarrow>((1)Word.word*(1)Word.word*(1)Word.word*(1)Word.word*string)option "  where 
     " s722 s7240 = (
      (case  ((bit_maybe_i_matches_prefix s7240  ::  (( 1 Word.word * ii))option)) of
        Some ((i, s7250)) => 
  (case  ((string_drop s7240 s7250)) of
        s7260 =>
  (case  ((bit_maybe_o_matches_prefix s7260 :: (( 1 Word.word * ii)) option)) of
        Some ((o1, s7270)) =>
  (case  ((string_drop s7260 s7270)) of
        s7280 =>
  (case  ((bit_maybe_r_matches_prefix s7280 :: (( 1 Word.word * ii)) option)) of
        Some ((r, s7290)) =>
  (case  ((string_drop s7280 s7290)) of
        s7300 =>
  (case  ((bit_maybe_w_matches_prefix s7300 :: (( 1 Word.word * ii)) option)) of
        Some ((w, s7310)) =>
  (case  ((string_drop s7300 s7310)) of   s1 => Some (i, o1, r, w, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s7240  :: " string "


definition fence_bits_matches_prefix  :: " string \<Rightarrow>((4)Word.word*int)option "  where 
     " fence_bits_matches_prefix arg1 = (
   (let s7320 = arg1 in
   if ((case  ((s722 s7320  ::  (( 1 Word.word *  1 Word.word *  1 Word.word *  1 Word.word * string))option)) of
       Some ((i, o1, r, w, s1)) => True
     | _ => False
     )) then  (case 
 (s722 s7320 :: (( 1 Word.word * 1 Word.word * 1 Word.word * 1 Word.word * string)) option) of
     (Some ((i, o1, r, w, s1))) =>
 Some
   ((concat_vec i
       ((concat_vec o1 ((concat_vec r w :: 2 Word.word)) :: 3 Word.word)) :: 4 Word.word),
   ((string_length arg1)) - ((string_length s1)))
 )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val aqrl_str : bool -> bool -> string\<close>\<close>

fun aqrl_str  :: " bool \<Rightarrow> bool \<Rightarrow> string "  where 
     " aqrl_str (False :: bool) (False :: bool) = ( (''''))"
|" aqrl_str (False :: bool) (True :: bool) = ( (''.rl''))"
|" aqrl_str (True :: bool) (False :: bool) = ( (''.aq''))"
|" aqrl_str (True :: bool) (True :: bool) = ( (''.aqrl''))"


\<comment> \<open>\<open>val lrsc_width_str : word_width -> string\<close>\<close>

fun lrsc_width_str  :: " word_width \<Rightarrow> string "  where 
     " lrsc_width_str BYTE = ( (''.b''))"
|" lrsc_width_str HALF = ( (''.h''))"
|" lrsc_width_str WORD = ( (''.w''))"
|" lrsc_width_str DOUBLE = ( (''.d''))"


\<comment> \<open>\<open>val process_loadres : forall 'int8_times_n. Size 'int8_times_n => mword ty5 -> mword ty32 -> MemoryOpResult (mword 'int8_times_n) -> bool -> M Retired\<close>\<close>

definition process_loadres  :: "(5)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>(('int8_times_n::len)Word.word)MemoryOpResult \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " process_loadres rd addr value1 is_unsigned = (
   (case  ((extend_value is_unsigned value1  :: ( 32 Word.word) MemoryOpResult)) of
     MemValue (result) =>
      (let (_ :: unit) = (load_reservation addr) in
      wX ((regidx_to_regno rd)) result \<then> return RETIRE_SUCCESS)
   | MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
   ))" 
  for  rd  :: "(5)Word.word " 
  and  addr  :: "(32)Word.word " 
  and  value1  :: "(('int8_times_n::len)Word.word)MemoryOpResult " 
  and  is_unsigned  :: " bool "


\<comment> \<open>\<open>val encdec_amoop_forwards : amoop -> mword ty5\<close>\<close>

fun encdec_amoop_forwards  :: " amoop \<Rightarrow>(5)Word.word "  where 
     " encdec_amoop_forwards AMOSWAP = ( (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word))"
|" encdec_amoop_forwards AMOADD = ( (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word))"
|" encdec_amoop_forwards AMOXOR = ( (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word))"
|" encdec_amoop_forwards AMOAND = ( (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word))"
|" encdec_amoop_forwards AMOOR = ( (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word))"
|" encdec_amoop_forwards AMOMIN = ( (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word))"
|" encdec_amoop_forwards AMOMAX = ( (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word))"
|" encdec_amoop_forwards AMOMINU = ( (vec_of_bits [B1,B1,B0,B0,B0]  ::  5 Word.word))"
|" encdec_amoop_forwards AMOMAXU = ( (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word))"


\<comment> \<open>\<open>val encdec_amoop_backwards : mword ty5 -> M amoop\<close>\<close>

definition encdec_amoop_backwards  :: "(5)Word.word \<Rightarrow>((register_value),(amoop),(exception))monad "  where 
     " encdec_amoop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word))))))
   then
     return AMOSWAP
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))))) then
     return AMOADD
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     return AMOXOR
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     return AMOAND
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     return AMOOR
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))))) then
     return AMOMIN
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     return AMOMAX
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     return AMOMINU
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     return AMOMAXU
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(5)Word.word "


\<comment> \<open>\<open>val encdec_amoop_forwards_matches : amoop -> bool\<close>\<close>

fun encdec_amoop_forwards_matches  :: " amoop \<Rightarrow> bool "  where 
     " encdec_amoop_forwards_matches AMOSWAP = ( True )"
|" encdec_amoop_forwards_matches AMOADD = ( True )"
|" encdec_amoop_forwards_matches AMOXOR = ( True )"
|" encdec_amoop_forwards_matches AMOAND = ( True )"
|" encdec_amoop_forwards_matches AMOOR = ( True )"
|" encdec_amoop_forwards_matches AMOMIN = ( True )"
|" encdec_amoop_forwards_matches AMOMAX = ( True )"
|" encdec_amoop_forwards_matches AMOMINU = ( True )"
|" encdec_amoop_forwards_matches AMOMAXU = ( True )"


\<comment> \<open>\<open>val encdec_amoop_backwards_matches : mword ty5 -> bool\<close>\<close>

definition encdec_amoop_backwards_matches  :: "(5)Word.word \<Rightarrow> bool "  where 
     " encdec_amoop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B1]  ::  5 Word.word))))))
   then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B0,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B0,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B0,B1,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B0,B0,B0]  ::  5 Word.word)))))) then
     True
   else if (((((regidx_to_regno b__0)) = ((regidx_to_regno (vec_of_bits [B1,B1,B1,B0,B0]  ::  5 Word.word)))))) then
     True
   else False))" 
  for  arg1  :: "(5)Word.word "


\<comment> \<open>\<open>val amo_mnemonic_forwards : amoop -> string\<close>\<close>

fun amo_mnemonic_forwards  :: " amoop \<Rightarrow> string "  where 
     " amo_mnemonic_forwards AMOSWAP = ( (''amoswap''))"
|" amo_mnemonic_forwards AMOADD = ( (''amoadd''))"
|" amo_mnemonic_forwards AMOXOR = ( (''amoxor''))"
|" amo_mnemonic_forwards AMOAND = ( (''amoand''))"
|" amo_mnemonic_forwards AMOOR = ( (''amoor''))"
|" amo_mnemonic_forwards AMOMIN = ( (''amomin''))"
|" amo_mnemonic_forwards AMOMAX = ( (''amomax''))"
|" amo_mnemonic_forwards AMOMINU = ( (''amominu''))"
|" amo_mnemonic_forwards AMOMAXU = ( (''amomaxu''))"


\<comment> \<open>\<open>val amo_mnemonic_backwards : string -> M amoop\<close>\<close>

definition amo_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(amoop),(exception))monad "  where 
     " amo_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''amoswap'')))) then return AMOSWAP
   else if (((p00 = (''amoadd'')))) then return AMOADD
   else if (((p00 = (''amoxor'')))) then return AMOXOR
   else if (((p00 = (''amoand'')))) then return AMOAND
   else if (((p00 = (''amoor'')))) then return AMOOR
   else if (((p00 = (''amomin'')))) then return AMOMIN
   else if (((p00 = (''amomax'')))) then return AMOMAX
   else if (((p00 = (''amominu'')))) then return AMOMINU
   else if (((p00 = (''amomaxu'')))) then return AMOMAXU
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val amo_mnemonic_forwards_matches : amoop -> bool\<close>\<close>

fun amo_mnemonic_forwards_matches  :: " amoop \<Rightarrow> bool "  where 
     " amo_mnemonic_forwards_matches AMOSWAP = ( True )"
|" amo_mnemonic_forwards_matches AMOADD = ( True )"
|" amo_mnemonic_forwards_matches AMOXOR = ( True )"
|" amo_mnemonic_forwards_matches AMOAND = ( True )"
|" amo_mnemonic_forwards_matches AMOOR = ( True )"
|" amo_mnemonic_forwards_matches AMOMIN = ( True )"
|" amo_mnemonic_forwards_matches AMOMAX = ( True )"
|" amo_mnemonic_forwards_matches AMOMINU = ( True )"
|" amo_mnemonic_forwards_matches AMOMAXU = ( True )"


\<comment> \<open>\<open>val amo_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition amo_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " amo_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''amoswap'')))) then True
   else if (((p00 = (''amoadd'')))) then True
   else if (((p00 = (''amoxor'')))) then True
   else if (((p00 = (''amoand'')))) then True
   else if (((p00 = (''amoor'')))) then True
   else if (((p00 = (''amomin'')))) then True
   else if (((p00 = (''amomax'')))) then True
   else if (((p00 = (''amominu'')))) then True
   else if (((p00 = (''amomaxu'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val amo_mnemonic_matches_prefix : string -> maybe ((amoop * ii))\<close>\<close>

\<comment> \<open>\<open>val _s765_ : string -> maybe string\<close>\<close>

definition s765  :: " string \<Rightarrow>(string)option "  where 
     " s765 s7660 = (
   (let s7670 = s7660 in
   if ((string_startswith s7670 (''amomaxu''))) then  
  (case  ((string_drop s7670 ((string_length (''amomaxu''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7660  :: " string "


\<comment> \<open>\<open>val _s761_ : string -> maybe string\<close>\<close>

definition s761  :: " string \<Rightarrow>(string)option "  where 
     " s761 s7620 = (
   (let s7630 = s7620 in
   if ((string_startswith s7630 (''amominu''))) then  
  (case  ((string_drop s7630 ((string_length (''amominu''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7620  :: " string "


\<comment> \<open>\<open>val _s757_ : string -> maybe string\<close>\<close>

definition s757  :: " string \<Rightarrow>(string)option "  where 
     " s757 s7580 = (
   (let s7590 = s7580 in
   if ((string_startswith s7590 (''amomax''))) then  
  (case  ((string_drop s7590 ((string_length (''amomax''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7580  :: " string "


\<comment> \<open>\<open>val _s753_ : string -> maybe string\<close>\<close>

definition s753  :: " string \<Rightarrow>(string)option "  where 
     " s753 s7540 = (
   (let s7550 = s7540 in
   if ((string_startswith s7550 (''amomin''))) then  
  (case  ((string_drop s7550 ((string_length (''amomin''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7540  :: " string "


\<comment> \<open>\<open>val _s749_ : string -> maybe string\<close>\<close>

definition s749  :: " string \<Rightarrow>(string)option "  where 
     " s749 s7500 = (
   (let s7510 = s7500 in
   if ((string_startswith s7510 (''amoor''))) then  
  (case  ((string_drop s7510 ((string_length (''amoor''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7500  :: " string "


\<comment> \<open>\<open>val _s745_ : string -> maybe string\<close>\<close>

definition s745  :: " string \<Rightarrow>(string)option "  where 
     " s745 s7460 = (
   (let s7470 = s7460 in
   if ((string_startswith s7470 (''amoand''))) then  
  (case  ((string_drop s7470 ((string_length (''amoand''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7460  :: " string "


\<comment> \<open>\<open>val _s741_ : string -> maybe string\<close>\<close>

definition s741  :: " string \<Rightarrow>(string)option "  where 
     " s741 s7420 = (
   (let s7430 = s7420 in
   if ((string_startswith s7430 (''amoxor''))) then  
  (case  ((string_drop s7430 ((string_length (''amoxor''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7420  :: " string "


\<comment> \<open>\<open>val _s737_ : string -> maybe string\<close>\<close>

definition s737  :: " string \<Rightarrow>(string)option "  where 
     " s737 s7380 = (
   (let s7390 = s7380 in
   if ((string_startswith s7390 (''amoadd''))) then  
  (case  ((string_drop s7390 ((string_length (''amoadd''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7380  :: " string "


\<comment> \<open>\<open>val _s733_ : string -> maybe string\<close>\<close>

definition s733  :: " string \<Rightarrow>(string)option "  where 
     " s733 s7340 = (
   (let s7350 = s7340 in
   if ((string_startswith s7350 (''amoswap''))) then  
  (case  ((string_drop s7350 ((string_length (''amoswap''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7340  :: " string "


definition amo_mnemonic_matches_prefix  :: " string \<Rightarrow>(amoop*int)option "  where 
     " amo_mnemonic_matches_prefix arg1 = (
   (let s7360 = arg1 in
   if ((case  ((s733 s7360)) of   Some (s1) => True | _ => False )) then  
  (case  s733 s7360 of
      (Some (s1)) =>
  Some (AMOSWAP, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s737 s7360)) of   Some (s1) => True | _ => False )) then  
  (case  s737 s7360 of
      (Some (s1)) =>
  Some (AMOADD, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s741 s7360)) of   Some (s1) => True | _ => False )) then  
  (case  s741 s7360 of
      (Some (s1)) =>
  Some (AMOXOR, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s745 s7360)) of   Some (s1) => True | _ => False )) then  
  (case  s745 s7360 of
      (Some (s1)) =>
  Some (AMOAND, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s749 s7360)) of   Some (s1) => True | _ => False )) then  
  (case  s749 s7360 of
      (Some (s1)) =>
  Some (AMOOR, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s753 s7360)) of   Some (s1) => True | _ => False )) then  
  (case  s753 s7360 of
      (Some (s1)) =>
  Some (AMOMIN, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s757 s7360)) of   Some (s1) => True | _ => False )) then  
  (case  s757 s7360 of
      (Some (s1)) =>
  Some (AMOMAX, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s761 s7360)) of   Some (s1) => True | _ => False )) then  
  (case  s761 s7360 of
      (Some (s1)) =>
  Some (AMOMINU, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s765 s7360)) of   Some (s1) => True | _ => False )) then  
  (case  s765 s7360 of
      (Some (s1)) =>
  Some (AMOMAXU, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_mul_op_forwards : (bool * bool * bool) -> mword ty3\<close>\<close>

fun encdec_mul_op_forwards  :: " bool*bool*bool \<Rightarrow>(3)Word.word "  where 
     " encdec_mul_op_forwards (False, True, True) = ( (vec_of_bits [B0,B0,B0]  ::  3 Word.word))"
|" encdec_mul_op_forwards (True, True, True) = ( (vec_of_bits [B0,B0,B1]  ::  3 Word.word))"
|" encdec_mul_op_forwards (True, True, False) = ( (vec_of_bits [B0,B1,B0]  ::  3 Word.word))"
|" encdec_mul_op_forwards (True, False, False) = ( (vec_of_bits [B0,B1,B1]  ::  3 Word.word))"


\<comment> \<open>\<open>val encdec_mul_op_backwards : mword ty3 -> M (bool * bool * bool)\<close>\<close>

definition encdec_mul_op_backwards  :: "(3)Word.word \<Rightarrow>((register_value),(bool*bool*bool),(exception))monad "  where 
     " encdec_mul_op_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then return (False, True, True)
   else if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then return (True, True, True)
   else if (((b__0 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then return (True, True, False)
   else if (((b__0 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then return (True, False, False)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val encdec_mul_op_forwards_matches : (bool * bool * bool) -> bool\<close>\<close>

fun encdec_mul_op_forwards_matches  :: " bool*bool*bool \<Rightarrow> bool "  where 
     " encdec_mul_op_forwards_matches (False, True, True) = ( True )"
|" encdec_mul_op_forwards_matches (True, True, True) = ( True )"
|" encdec_mul_op_forwards_matches (True, True, False) = ( True )"
|" encdec_mul_op_forwards_matches (True, False, False) = ( True )"
|" encdec_mul_op_forwards_matches _ = ( False )"


\<comment> \<open>\<open>val encdec_mul_op_backwards_matches : mword ty3 -> bool\<close>\<close>

definition encdec_mul_op_backwards_matches  :: "(3)Word.word \<Rightarrow> bool "  where 
     " encdec_mul_op_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) then True
   else False))" 
  for  arg1  :: "(3)Word.word "


\<comment> \<open>\<open>val mul_mnemonic_forwards : (bool * bool * bool) -> string\<close>\<close>

fun mul_mnemonic_forwards  :: " bool*bool*bool \<Rightarrow> string "  where 
     " mul_mnemonic_forwards (False, True, True) = ( (''mul''))"
|" mul_mnemonic_forwards (True, True, True) = ( (''mulh''))"
|" mul_mnemonic_forwards (True, True, False) = ( (''mulhsu''))"
|" mul_mnemonic_forwards (True, False, False) = ( (''mulhu''))"


\<comment> \<open>\<open>val mul_mnemonic_backwards : string -> M (bool * bool * bool)\<close>\<close>

definition mul_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(bool*bool*bool),(exception))monad "  where 
     " mul_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''mul'')))) then return (False, True, True)
   else if (((p00 = (''mulh'')))) then return (True, True, True)
   else if (((p00 = (''mulhsu'')))) then return (True, True, False)
   else if (((p00 = (''mulhu'')))) then return (True, False, False)
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val mul_mnemonic_forwards_matches : (bool * bool * bool) -> bool\<close>\<close>

fun mul_mnemonic_forwards_matches  :: " bool*bool*bool \<Rightarrow> bool "  where 
     " mul_mnemonic_forwards_matches (False, True, True) = ( True )"
|" mul_mnemonic_forwards_matches (True, True, True) = ( True )"
|" mul_mnemonic_forwards_matches (True, True, False) = ( True )"
|" mul_mnemonic_forwards_matches (True, False, False) = ( True )"
|" mul_mnemonic_forwards_matches _ = ( False )"


\<comment> \<open>\<open>val mul_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition mul_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " mul_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''mul'')))) then True
   else if (((p00 = (''mulh'')))) then True
   else if (((p00 = (''mulhsu'')))) then True
   else if (((p00 = (''mulhu'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val mul_mnemonic_matches_prefix : string -> maybe (((bool * bool * bool) * ii))\<close>\<close>

\<comment> \<open>\<open>val _s781_ : string -> maybe string\<close>\<close>

definition s781  :: " string \<Rightarrow>(string)option "  where 
     " s781 s7820 = (
   (let s7830 = s7820 in
   if ((string_startswith s7830 (''mulhu''))) then  
  (case  ((string_drop s7830 ((string_length (''mulhu''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7820  :: " string "


\<comment> \<open>\<open>val _s777_ : string -> maybe string\<close>\<close>

definition s777  :: " string \<Rightarrow>(string)option "  where 
     " s777 s7780 = (
   (let s7790 = s7780 in
   if ((string_startswith s7790 (''mulhsu''))) then  
  (case  ((string_drop s7790 ((string_length (''mulhsu''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7780  :: " string "


\<comment> \<open>\<open>val _s773_ : string -> maybe string\<close>\<close>

definition s773  :: " string \<Rightarrow>(string)option "  where 
     " s773 s7740 = (
   (let s7750 = s7740 in
   if ((string_startswith s7750 (''mulh''))) then  
  (case  ((string_drop s7750 ((string_length (''mulh''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7740  :: " string "


\<comment> \<open>\<open>val _s769_ : string -> maybe string\<close>\<close>

definition s769  :: " string \<Rightarrow>(string)option "  where 
     " s769 s7700 = (
   (let s7710 = s7700 in
   if ((string_startswith s7710 (''mul''))) then  
  (case  ((string_drop s7710 ((string_length (''mul''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s7700  :: " string "


definition mul_mnemonic_matches_prefix  :: " string \<Rightarrow>((bool*bool*bool)*int)option "  where 
     " mul_mnemonic_matches_prefix arg1 = (
   (let s7720 = arg1 in
   if ((case  ((s769 s7720)) of   Some (s1) => True | _ => False )) then  
  (case  s769 s7720 of
      (Some (s1)) =>
  Some ((False, True, True), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s773 s7720)) of   Some (s1) => True | _ => False )) then  
  (case  s773 s7720 of
      (Some (s1)) =>
  Some ((True, True, True), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s777 s7720)) of   Some (s1) => True | _ => False )) then  
  (case  s777 s7720 of
      (Some (s1)) =>
  Some ((True, True, False), ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s781 s7720)) of   Some (s1) => True | _ => False )) then  
  (case  s781 s7720 of
      (Some (s1)) =>
  Some ((True, False, False), ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_not_u_forwards : bool -> string\<close>\<close>

fun maybe_not_u_forwards  :: " bool \<Rightarrow> string "  where 
     " maybe_not_u_forwards False = ( (''u''))"
|" maybe_not_u_forwards True = ( (''''))"


\<comment> \<open>\<open>val maybe_not_u_backwards : string -> M bool\<close>\<close>

definition maybe_not_u_backwards  :: " string \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " maybe_not_u_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''u'')))) then return False
   else if (((p00 = ('''')))) then return True
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_not_u_forwards_matches : bool -> bool\<close>\<close>

fun maybe_not_u_forwards_matches  :: " bool \<Rightarrow> bool "  where 
     " maybe_not_u_forwards_matches False = ( True )"
|" maybe_not_u_forwards_matches True = ( True )"


\<comment> \<open>\<open>val maybe_not_u_backwards_matches : string -> bool\<close>\<close>

definition maybe_not_u_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " maybe_not_u_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''u'')))) then True
   else if (((p00 = ('''')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_not_u_matches_prefix : string -> maybe ((bool * ii))\<close>\<close>

\<comment> \<open>\<open>val _s789_ : string -> maybe string\<close>\<close>

definition s789  :: " string \<Rightarrow>(string)option "  where 
     " s789 s7900 = (
   (let s7910 = s7900 in
   if ((string_startswith s7910 (''''))) then  
  (case  ((string_drop s7910 ((string_length (''''))))) of   s1 => Some s1 )
   else None))" 
  for  s7900  :: " string "


\<comment> \<open>\<open>val _s785_ : string -> maybe string\<close>\<close>

definition s785  :: " string \<Rightarrow>(string)option "  where 
     " s785 s7860 = (
   (let s7870 = s7860 in
   if ((string_startswith s7870 (''u''))) then  
  (case  ((string_drop s7870 ((string_length (''u''))))) of   s1 => Some s1 )
   else None))" 
  for  s7860  :: " string "


definition maybe_not_u_matches_prefix  :: " string \<Rightarrow>(bool*int)option "  where 
     " maybe_not_u_matches_prefix arg1 = (
   (let s7880 = arg1 in
   if ((case  ((s785 s7880)) of   Some (s1) => True | _ => False )) then  
  (case  s785 s7880 of
      (Some (s1)) =>
  Some (False, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s789 s7880)) of   Some (s1) => True | _ => False )) then  
  (case  s789 s7880 of
      (Some (s1)) =>
  Some (True, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_csrop_forwards : csrop -> mword ty2\<close>\<close>

fun encdec_csrop_forwards  :: " csrop \<Rightarrow>(2)Word.word "  where 
     " encdec_csrop_forwards CSRRW = ( (vec_of_bits [B0,B1]  ::  2 Word.word))"
|" encdec_csrop_forwards CSRRS = ( (vec_of_bits [B1,B0]  ::  2 Word.word))"
|" encdec_csrop_forwards CSRRC = ( (vec_of_bits [B1,B1]  ::  2 Word.word))"


\<comment> \<open>\<open>val encdec_csrop_backwards : mword ty2 -> M csrop\<close>\<close>

definition encdec_csrop_backwards  :: "(2)Word.word \<Rightarrow>((register_value),(csrop),(exception))monad "  where 
     " encdec_csrop_backwards arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then return CSRRW
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then return CSRRS
   else if (((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then return CSRRC
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: "(2)Word.word "


\<comment> \<open>\<open>val encdec_csrop_forwards_matches : csrop -> bool\<close>\<close>

fun encdec_csrop_forwards_matches  :: " csrop \<Rightarrow> bool "  where 
     " encdec_csrop_forwards_matches CSRRW = ( True )"
|" encdec_csrop_forwards_matches CSRRS = ( True )"
|" encdec_csrop_forwards_matches CSRRC = ( True )"


\<comment> \<open>\<open>val encdec_csrop_backwards_matches : mword ty2 -> bool\<close>\<close>

definition encdec_csrop_backwards_matches  :: "(2)Word.word \<Rightarrow> bool "  where 
     " encdec_csrop_backwards_matches arg1 = (
   (let b__0 = arg1 in
   if (((b__0 = (vec_of_bits [B0,B1]  ::  2 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B0]  ::  2 Word.word)))) then True
   else if (((b__0 = (vec_of_bits [B1,B1]  ::  2 Word.word)))) then True
   else False))" 
  for  arg1  :: "(2)Word.word "


\<comment> \<open>\<open>val readCSR : mword ty12 -> M (mword ty32)\<close>\<close>

definition readCSR  :: "(12)Word.word \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " readCSR csr = (
   (case  (csr, (( 32 :: int)::ii)) of
     (b__0, g__3) =>
      if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
        (read_reg mvendorid_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
        return ((EXTZ (( 32 :: int)::ii) w__0  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
        (read_reg marchid_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
        (read_reg mimpid_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B1,B1,B1,B1,B0,B0,B0,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
        (read_reg mhartid_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        read_reg mstatus_ref \<bind> (\<lambda> (w__4 :: Mstatus) . 
        return ((get_Mstatus_bits w__4  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
        read_reg misa_ref \<bind> (\<lambda> (w__5 :: Misa) .  return ((get_Misa_bits w__5  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        read_reg medeleg_ref \<bind> (\<lambda> (w__6 :: Medeleg) . 
        return ((get_Medeleg_bits w__6  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
        read_reg mideleg_ref \<bind> (\<lambda> (w__7 :: Minterrupts) . 
        return ((get_Minterrupts_bits w__7  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
        read_reg mie_ref \<bind> (\<lambda> (w__8 :: Minterrupts) . 
        return ((get_Minterrupts_bits w__8  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
        (get_mtvec ()   :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
        read_reg mcounteren_ref \<bind> (\<lambda> (w__10 :: Counteren) . 
        return ((EXTZ (( 32 :: int)::ii) ((get_Counteren_bits w__10  ::  32 Word.word))  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (read_reg mscratch_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
        (get_xret_target Machine  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 ::  32 Word.word) . 
        (pc_alignment_mask ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 ::  32 Word.word) . 
        return ((and_vec w__12 w__13  ::  32 Word.word))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        read_reg mcause_ref \<bind> (\<lambda> (w__14 :: Mcause) . 
        return ((get_Mcause_bits w__14  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
        (read_reg mtval_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
        read_reg mip_ref \<bind> (\<lambda> (w__16 :: Minterrupts) . 
        return ((get_Minterrupts_bits w__16  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (pmpReadCfgReg (( 0 :: int)::ii)  :: ( 32 Word.word) M)
      else if ((((((g__3 = (( 32 :: int)::ii)))) \<and> (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B1]  ::  12 Word.word)))))))
      then
        (pmpReadCfgReg (( 1 :: int)::ii)  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        (pmpReadCfgReg (( 2 :: int)::ii)  :: ( 32 Word.word) M)
      else if ((((((g__3 = (( 32 :: int)::ii)))) \<and> (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B1]  ::  12 Word.word)))))))
      then
        (pmpReadCfgReg (( 3 :: int)::ii)  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (read_reg pmpaddr0_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
        (read_reg pmpaddr1_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
        (read_reg pmpaddr2_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
        (read_reg pmpaddr3_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
        (read_reg pmpaddr4_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B1]  ::  12 Word.word)))) then
        (read_reg pmpaddr5_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B0]  ::  12 Word.word)))) then
        (read_reg pmpaddr6_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B1]  ::  12 Word.word)))) then
        (read_reg pmpaddr7_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B0]  ::  12 Word.word)))) then
        (read_reg pmpaddr8_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B1]  ::  12 Word.word)))) then
        (read_reg pmpaddr9_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B0]  ::  12 Word.word)))) then
        (read_reg pmpaddr10_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B1]  ::  12 Word.word)))) then
        (read_reg pmpaddr11_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B0]  ::  12 Word.word)))) then
        (read_reg pmpaddr12_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B1]  ::  12 Word.word)))) then
        (read_reg pmpaddr13_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B0]  ::  12 Word.word)))) then
        (read_reg pmpaddr14_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B1]  ::  12 Word.word)))) then
        (read_reg pmpaddr15_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__37 ::  64 Word.word) . 
        return ((subrange_vec_dec w__37 (((( 32 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        (read_reg minstret_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__38 ::  64 Word.word) . 
        return ((subrange_vec_dec w__38 (((( 32 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  32 Word.word)))
      else if ((((((g__3 = (( 32 :: int)::ii)))) \<and> (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))))))
      then
        (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__39 ::  64 Word.word) . 
        return ((subrange_vec_dec w__39 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)))
      else if ((((((g__3 = (( 32 :: int)::ii)))) \<and> (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))))))
      then
        (read_reg minstret_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__40 ::  64 Word.word) . 
        return ((subrange_vec_dec w__40 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (read_reg tselect_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__41 ::  32 Word.word) . 
        return ((not_vec w__41  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        read_reg mstatus_ref \<bind> (\<lambda> (w__42 :: Mstatus) . 
        return ((get_Sstatus_bits ((lower_mstatus w__42))  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        read_reg sedeleg_ref \<bind> (\<lambda> (w__43 :: Sedeleg) . 
        return ((get_Sedeleg_bits w__43  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
        read_reg sideleg_ref \<bind> (\<lambda> (w__44 :: Sinterrupts) . 
        return ((get_Sinterrupts_bits w__44  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
        read_reg mie_ref \<bind> (\<lambda> (w__45 :: Minterrupts) . 
        read_reg mideleg_ref \<bind> (\<lambda> (w__46 :: Minterrupts) . 
        return ((get_Sinterrupts_bits ((lower_mie w__45 w__46))  ::  32 Word.word))))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
        (get_stvec ()   :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
        read_reg scounteren_ref \<bind> (\<lambda> (w__48 :: Counteren) . 
        return ((EXTZ (( 32 :: int)::ii) ((get_Counteren_bits w__48  ::  32 Word.word))  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (read_reg sscratch_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
        (get_xret_target Supervisor  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__50 ::  32 Word.word) . 
        (pc_alignment_mask ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__51 ::  32 Word.word) . 
        return ((and_vec w__50 w__51  ::  32 Word.word))))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        read_reg scause_ref \<bind> (\<lambda> (w__52 :: Mcause) . 
        return ((get_Mcause_bits w__52  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
        (read_reg stval_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
        read_reg mip_ref \<bind> (\<lambda> (w__54 :: Minterrupts) . 
        read_reg mideleg_ref \<bind> (\<lambda> (w__55 :: Minterrupts) . 
        return ((get_Sinterrupts_bits ((lower_mip w__54 w__55))  ::  32 Word.word))))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (read_reg satp_ref  :: ( 32 Word.word) M)
      else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__57 ::  64 Word.word) . 
        return ((subrange_vec_dec w__57 (((( 32 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
        (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__58 ::  64 Word.word) . 
        return ((subrange_vec_dec w__58 (((( 32 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  32 Word.word)))
      else if (((b__0 = (vec_of_bits [B1,B1,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        (read_reg minstret_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__59 ::  64 Word.word) . 
        return ((subrange_vec_dec w__59 (((( 32 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  32 Word.word)))
      else if ((((((g__3 = (( 32 :: int)::ii)))) \<and> (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))))))
      then
        (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__60 ::  64 Word.word) . 
        return ((subrange_vec_dec w__60 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)))
      else if ((((((g__3 = (( 32 :: int)::ii)))) \<and> (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))))))
      then
        (read_reg mtime_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__61 ::  64 Word.word) . 
        return ((subrange_vec_dec w__61 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)))
      else if ((((((g__3 = (( 32 :: int)::ii)))) \<and> (((b__0 = (vec_of_bits [B1,B1,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))))))
      then
        (read_reg minstret_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__62 ::  64 Word.word) . 
        return ((subrange_vec_dec w__62 (( 63 :: int)::ii) (( 32 :: int)::ii)  ::  32 Word.word)))
      else
        (ext_read_CSR csr  :: ( ( 32 Word.word)option) M) \<bind> (\<lambda> (w__63 ::  ( 32 Word.word)option) . 
        return ((case  w__63 of
          Some (res) => res
        | None =>
           (let (_ :: unit) = (print_bits0 (''unhandled read to CSR '') csr) in
           (EXTZ (( 32 :: int)::ii) (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)  ::  32 Word.word))
        )))
   ) \<bind> (\<lambda> (res :: xlenbits) . 
   (let (_ :: unit) =
     (if ((get_config_print_reg () )) then
       print_dbg
         (((@) (''CSR '')
             (((@) ((csr_name csr)) (((@) ('' -> '') ((string_of_bits res))))))))
     else () ) in
   return res)))" 
  for  csr  :: "(12)Word.word "


\<comment> \<open>\<open>val writeCSR : mword ty12 -> mword ty32 -> M unit\<close>\<close>

definition writeCSR  :: "(12)Word.word \<Rightarrow>(32)Word.word \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " writeCSR (csr :: csreg) (value1 :: xlenbits) = (
   (case  (csr, (( 32 :: int)::ii)) of
     (b__0, g__2) =>
      if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        read_reg mstatus_ref \<bind> (\<lambda> (w__0 :: Mstatus) . 
        legalize_mstatus w__0 value1 \<bind> (\<lambda> (w__1 :: Mstatus) . 
        (write_reg mstatus_ref w__1 \<then>
        read_reg mstatus_ref) \<bind> (\<lambda> (w__2 :: Mstatus) . 
        return (Some ((get_Mstatus_bits w__2  ::  32 Word.word))))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
        read_reg misa_ref \<bind> (\<lambda> (w__3 :: Misa) . 
        legalize_misa w__3 value1 \<bind> (\<lambda> (w__4 :: Misa) . 
        (write_reg misa_ref w__4 \<then>
        read_reg misa_ref) \<bind> (\<lambda> (w__5 :: Misa) . 
        return (Some ((get_Misa_bits w__5  ::  32 Word.word))))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        read_reg medeleg_ref \<bind> (\<lambda> (w__6 :: Medeleg) . 
        (write_reg medeleg_ref ((legalize_medeleg w__6 value1)) \<then>
        read_reg medeleg_ref) \<bind> (\<lambda> (w__7 :: Medeleg) . 
        return (Some ((get_Medeleg_bits w__7  ::  32 Word.word)))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
        read_reg mideleg_ref \<bind> (\<lambda> (w__8 :: Minterrupts) . 
        (write_reg mideleg_ref ((legalize_mideleg w__8 value1)) \<then>
        read_reg mideleg_ref) \<bind> (\<lambda> (w__9 :: Minterrupts) . 
        return (Some ((get_Minterrupts_bits w__9  ::  32 Word.word)))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
        read_reg mie_ref \<bind> (\<lambda> (w__10 :: Minterrupts) . 
        legalize_mie w__10 value1 \<bind> (\<lambda> (w__11 :: Minterrupts) . 
        (write_reg mie_ref w__11 \<then>
        read_reg mie_ref) \<bind> (\<lambda> (w__12 :: Minterrupts) . 
        return (Some ((get_Minterrupts_bits w__12  ::  32 Word.word))))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
        (set_mtvec value1  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__13 ::  32 Word.word) .  return (Some w__13))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
        read_reg mcounteren_ref \<bind> (\<lambda> (w__14 :: Counteren) . 
        (write_reg mcounteren_ref ((legalize_mcounteren w__14 value1)) \<then>
        read_reg mcounteren_ref) \<bind> (\<lambda> (w__15 :: Counteren) . 
        return (Some ((EXTZ (( 32 :: int)::ii) ((get_Counteren_bits w__15  ::  32 Word.word))  ::  32 Word.word)))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (write_reg mscratch_ref value1 \<then>
        (read_reg mscratch_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__16 ::  32 Word.word) . 
        return (Some w__16))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
        (set_xret_target Machine value1  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__17 ::  32 Word.word) . 
        return (Some w__17))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        (set_Mcause_bits mcause_ref value1 \<then>
        read_reg mcause_ref) \<bind> (\<lambda> (w__18 :: Mcause) . 
        return (Some ((get_Mcause_bits w__18  ::  32 Word.word))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
        (write_reg mtval_ref value1 \<then>
        (read_reg mtval_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__19 ::  32 Word.word) .  return (Some w__19))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
        read_reg mip_ref \<bind> (\<lambda> (w__20 :: Minterrupts) . 
        legalize_mip w__20 value1 \<bind> (\<lambda> (w__21 :: Minterrupts) . 
        (write_reg mip_ref w__21 \<then>
        read_reg mip_ref) \<bind> (\<lambda> (w__22 :: Minterrupts) . 
        return (Some ((get_Minterrupts_bits w__22  ::  32 Word.word))))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        pmpWriteCfgReg (( 0 :: int)::ii) value1 \<then> return (Some value1)
      else if ((((((g__2 = (( 32 :: int)::ii)))) \<and> (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B0,B1]  ::  12 Word.word)))))))
      then
        pmpWriteCfgReg (( 1 :: int)::ii) value1 \<then> return (Some value1)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        pmpWriteCfgReg (( 2 :: int)::ii) value1 \<then> return (Some value1)
      else if ((((((g__2 = (( 32 :: int)::ii)))) \<and> (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B0,B0,B0,B1,B1]  ::  12 Word.word)))))))
      then
        pmpWriteCfgReg (( 3 :: int)::ii) value1 \<then> return (Some value1)
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B0]  ::  12 Word.word)))) then
        read_reg pmp0cfg_ref \<bind> (\<lambda> (w__23 :: Pmpcfg_ent) . 
        (read_reg pmpaddr0_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__24 ::  32 Word.word) . 
        (write_reg pmpaddr0_ref ((pmpWriteAddr w__23 w__24 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr0_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__25 ::  32 Word.word) . 
        return (Some w__25))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B0,B1]  ::  12 Word.word)))) then
        read_reg pmp1cfg_ref \<bind> (\<lambda> (w__26 :: Pmpcfg_ent) . 
        (read_reg pmpaddr1_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__27 ::  32 Word.word) . 
        (write_reg pmpaddr1_ref ((pmpWriteAddr w__26 w__27 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr1_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__28 ::  32 Word.word) . 
        return (Some w__28))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B0]  ::  12 Word.word)))) then
        read_reg pmp2cfg_ref \<bind> (\<lambda> (w__29 :: Pmpcfg_ent) . 
        (read_reg pmpaddr2_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__30 ::  32 Word.word) . 
        (write_reg pmpaddr2_ref ((pmpWriteAddr w__29 w__30 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr2_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__31 ::  32 Word.word) . 
        return (Some w__31))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B0,B1,B1]  ::  12 Word.word)))) then
        read_reg pmp3cfg_ref \<bind> (\<lambda> (w__32 :: Pmpcfg_ent) . 
        (read_reg pmpaddr3_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__33 ::  32 Word.word) . 
        (write_reg pmpaddr3_ref ((pmpWriteAddr w__32 w__33 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr3_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__34 ::  32 Word.word) . 
        return (Some w__34))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B0]  ::  12 Word.word)))) then
        read_reg pmp4cfg_ref \<bind> (\<lambda> (w__35 :: Pmpcfg_ent) . 
        (read_reg pmpaddr4_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__36 ::  32 Word.word) . 
        (write_reg pmpaddr4_ref ((pmpWriteAddr w__35 w__36 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr4_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__37 ::  32 Word.word) . 
        return (Some w__37))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B0,B1]  ::  12 Word.word)))) then
        read_reg pmp5cfg_ref \<bind> (\<lambda> (w__38 :: Pmpcfg_ent) . 
        (read_reg pmpaddr5_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__39 ::  32 Word.word) . 
        (write_reg pmpaddr5_ref ((pmpWriteAddr w__38 w__39 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr5_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__40 ::  32 Word.word) . 
        return (Some w__40))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B0]  ::  12 Word.word)))) then
        read_reg pmp6cfg_ref \<bind> (\<lambda> (w__41 :: Pmpcfg_ent) . 
        (read_reg pmpaddr6_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__42 ::  32 Word.word) . 
        (write_reg pmpaddr6_ref ((pmpWriteAddr w__41 w__42 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr6_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__43 ::  32 Word.word) . 
        return (Some w__43))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B0,B1,B1,B1]  ::  12 Word.word)))) then
        read_reg pmp7cfg_ref \<bind> (\<lambda> (w__44 :: Pmpcfg_ent) . 
        (read_reg pmpaddr7_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__45 ::  32 Word.word) . 
        (write_reg pmpaddr7_ref ((pmpWriteAddr w__44 w__45 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr7_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__46 ::  32 Word.word) . 
        return (Some w__46))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B0]  ::  12 Word.word)))) then
        read_reg pmp8cfg_ref \<bind> (\<lambda> (w__47 :: Pmpcfg_ent) . 
        (read_reg pmpaddr8_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__48 ::  32 Word.word) . 
        (write_reg pmpaddr8_ref ((pmpWriteAddr w__47 w__48 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr8_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__49 ::  32 Word.word) . 
        return (Some w__49))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B0,B1]  ::  12 Word.word)))) then
        read_reg pmp9cfg_ref \<bind> (\<lambda> (w__50 :: Pmpcfg_ent) . 
        (read_reg pmpaddr9_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__51 ::  32 Word.word) . 
        (write_reg pmpaddr9_ref ((pmpWriteAddr w__50 w__51 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr9_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__52 ::  32 Word.word) . 
        return (Some w__52))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B0]  ::  12 Word.word)))) then
        read_reg pmp10cfg_ref \<bind> (\<lambda> (w__53 :: Pmpcfg_ent) . 
        (read_reg pmpaddr10_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__54 ::  32 Word.word) . 
        (write_reg pmpaddr10_ref ((pmpWriteAddr w__53 w__54 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr10_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__55 ::  32 Word.word) . 
        return (Some w__55))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B0,B1,B1]  ::  12 Word.word)))) then
        read_reg pmp11cfg_ref \<bind> (\<lambda> (w__56 :: Pmpcfg_ent) . 
        (read_reg pmpaddr11_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__57 ::  32 Word.word) . 
        (write_reg pmpaddr11_ref ((pmpWriteAddr w__56 w__57 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr11_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__58 ::  32 Word.word) . 
        return (Some w__58))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B0]  ::  12 Word.word)))) then
        read_reg pmp12cfg_ref \<bind> (\<lambda> (w__59 :: Pmpcfg_ent) . 
        (read_reg pmpaddr12_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__60 ::  32 Word.word) . 
        (write_reg pmpaddr12_ref ((pmpWriteAddr w__59 w__60 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr12_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__61 ::  32 Word.word) . 
        return (Some w__61))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B0,B1]  ::  12 Word.word)))) then
        read_reg pmp13cfg_ref \<bind> (\<lambda> (w__62 :: Pmpcfg_ent) . 
        (read_reg pmpaddr13_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__63 ::  32 Word.word) . 
        (write_reg pmpaddr13_ref ((pmpWriteAddr w__62 w__63 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr13_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__64 ::  32 Word.word) . 
        return (Some w__64))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B0]  ::  12 Word.word)))) then
        read_reg pmp14cfg_ref \<bind> (\<lambda> (w__65 :: Pmpcfg_ent) . 
        (read_reg pmpaddr14_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__66 ::  32 Word.word) . 
        (write_reg pmpaddr14_ref ((pmpWriteAddr w__65 w__66 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr14_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__67 ::  32 Word.word) . 
        return (Some w__67))))
      else if (((b__0 = (vec_of_bits [B0,B0,B1,B1,B1,B0,B1,B1,B1,B1,B1,B1]  ::  12 Word.word)))) then
        read_reg pmp15cfg_ref \<bind> (\<lambda> (w__68 :: Pmpcfg_ent) . 
        (read_reg pmpaddr15_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__69 ::  32 Word.word) . 
        (write_reg pmpaddr15_ref ((pmpWriteAddr w__68 w__69 value1  ::  32 Word.word)) \<then>
        (read_reg pmpaddr15_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__70 ::  32 Word.word) . 
        return (Some w__70))))
      else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__71 ::  64 Word.word) . 
        write_reg
          mcycle_ref
          ((update_subrange_vec_dec w__71 (((( 32 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii) value1  ::  64 Word.word)) \<then>
        return (Some value1))
      else if (((b__0 = (vec_of_bits [B1,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        (read_reg minstret_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__72 ::  64 Word.word) . 
        (write_reg
          minstret_ref
          ((update_subrange_vec_dec w__72 (((( 32 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii) value1  ::  64 Word.word)) \<then>
        write_reg minstret_written_ref True) \<then> return (Some value1))
      else if ((((((g__2 = (( 32 :: int)::ii)))) \<and> (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))))))
      then
        (read_reg mcycle_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__73 ::  64 Word.word) . 
        write_reg mcycle_ref ((update_subrange_vec_dec w__73 (( 63 :: int)::ii) (( 32 :: int)::ii) value1  ::  64 Word.word)) \<then>
        return (Some value1))
      else if ((((((g__2 = (( 32 :: int)::ii)))) \<and> (((b__0 = (vec_of_bits [B1,B0,B1,B1,B1,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))))))
      then
        (read_reg minstret_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__74 ::  64 Word.word) . 
        (write_reg minstret_ref ((update_subrange_vec_dec w__74 (( 63 :: int)::ii) (( 32 :: int)::ii) value1  ::  64 Word.word)) \<then>
        write_reg minstret_written_ref True) \<then> return (Some value1))
      else if (((b__0 = (vec_of_bits [B0,B1,B1,B1,B1,B0,B1,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (write_reg tselect_ref value1 \<then>
        (read_reg tselect_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__75 ::  32 Word.word) .  return (Some w__75))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        read_reg mstatus_ref \<bind> (\<lambda> (w__76 :: Mstatus) . 
        legalize_sstatus w__76 value1 \<bind> (\<lambda> (w__77 :: Mstatus) . 
        (write_reg mstatus_ref w__77 \<then>
        read_reg mstatus_ref) \<bind> (\<lambda> (w__78 :: Mstatus) . 
        return (Some ((get_Mstatus_bits w__78  ::  32 Word.word))))))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        read_reg sedeleg_ref \<bind> (\<lambda> (w__79 :: Sedeleg) . 
        (write_reg sedeleg_ref ((legalize_sedeleg w__79 value1)) \<then>
        read_reg sedeleg_ref) \<bind> (\<lambda> (w__80 :: Sedeleg) . 
        return (Some ((get_Sedeleg_bits w__80  ::  32 Word.word)))))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
        (set_Sinterrupts_bits sideleg_ref value1 \<then>
        read_reg sideleg_ref) \<bind> (\<lambda> (w__81 :: Sinterrupts) . 
        return (Some ((get_Sinterrupts_bits w__81  ::  32 Word.word))))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
        read_reg mie_ref \<bind> (\<lambda> (w__82 :: Minterrupts) . 
        read_reg mideleg_ref \<bind> (\<lambda> (w__83 :: Minterrupts) . 
        legalize_sie w__82 w__83 value1 \<bind> (\<lambda> (w__84 :: Minterrupts) . 
        (write_reg mie_ref w__84 \<then>
        read_reg mie_ref) \<bind> (\<lambda> (w__85 :: Minterrupts) . 
        return (Some ((get_Minterrupts_bits w__85  ::  32 Word.word)))))))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)))) then
        (set_stvec value1  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__86 ::  32 Word.word) .  return (Some w__86))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B1,B0]  ::  12 Word.word)))) then
        read_reg scounteren_ref \<bind> (\<lambda> (w__87 :: Counteren) . 
        (write_reg scounteren_ref ((legalize_scounteren w__87 value1)) \<then>
        read_reg scounteren_ref) \<bind> (\<lambda> (w__88 :: Counteren) . 
        return (Some ((EXTZ (( 32 :: int)::ii) ((get_Counteren_bits w__88  ::  32 Word.word))  ::  32 Word.word)))))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        (write_reg sscratch_ref value1 \<then>
        (read_reg sscratch_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__89 ::  32 Word.word) . 
        return (Some w__89))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)))) then
        (set_xret_target Supervisor value1  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__90 ::  32 Word.word) . 
        return (Some w__90))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B0]  ::  12 Word.word)))) then
        (set_Mcause_bits scause_ref value1 \<then>
        read_reg scause_ref) \<bind> (\<lambda> (w__91 :: Mcause) . 
        return (Some ((get_Mcause_bits w__91  ::  32 Word.word))))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B1,B1]  ::  12 Word.word)))) then
        (write_reg stval_ref value1 \<then>
        (read_reg stval_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__92 ::  32 Word.word) .  return (Some w__92))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B0,B1,B0,B0,B0,B1,B0,B0]  ::  12 Word.word)))) then
        read_reg mip_ref \<bind> (\<lambda> (w__93 :: Minterrupts) . 
        read_reg mideleg_ref \<bind> (\<lambda> (w__94 :: Minterrupts) . 
        legalize_sip w__93 w__94 value1 \<bind> (\<lambda> (w__95 :: Minterrupts) . 
        (write_reg mip_ref w__95 \<then>
        read_reg mip_ref) \<bind> (\<lambda> (w__96 :: Minterrupts) . 
        return (Some ((get_Minterrupts_bits w__96  ::  32 Word.word)))))))
      else if (((b__0 = (vec_of_bits [B0,B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)))) then
        cur_Architecture ()  \<bind> (\<lambda> (w__97 :: Architecture) . 
        (read_reg satp_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__98 ::  32 Word.word) . 
        (write_reg satp_ref ((legalize_satp w__97 w__98 value1  ::  32 Word.word)) \<then>
        (read_reg satp_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__99 ::  32 Word.word) .  return (Some w__99))))
      else return None
   ) \<bind> (\<lambda> (res ::  xlenbits option) . 
   (case  res of
     Some (v) =>
      return (if ((get_config_print_reg () )) then
                print_dbg
                  (((@) (''CSR '')
                      (((@) ((csr_name csr))
                          (((@) ('' <- '')
                              (((@) ((string_of_bits v))
                                  (((@) ('' (input: '')
                                      (((@) ((string_of_bits value1)) ('')'')))))))))))))
              else () )
   | None =>
      ext_write_CSR csr value1 \<bind> (\<lambda> (w__149 :: bool) . 
      return (if w__149 then () 
              else print_bits0 (''unhandled write to CSR '') csr))
   )))" 
  for  csr  :: "(12)Word.word " 
  and  value1  :: "(32)Word.word "


\<comment> \<open>\<open>val maybe_i_forwards : bool -> string\<close>\<close>

fun maybe_i_forwards  :: " bool \<Rightarrow> string "  where 
     " maybe_i_forwards True = ( (''i''))"
|" maybe_i_forwards False = ( (''''))"


\<comment> \<open>\<open>val maybe_i_backwards : string -> M bool\<close>\<close>

definition maybe_i_backwards  :: " string \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " maybe_i_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''i'')))) then return True
   else if (((p00 = ('''')))) then return False
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_i_forwards_matches : bool -> bool\<close>\<close>

fun maybe_i_forwards_matches  :: " bool \<Rightarrow> bool "  where 
     " maybe_i_forwards_matches True = ( True )"
|" maybe_i_forwards_matches False = ( True )"


\<comment> \<open>\<open>val maybe_i_backwards_matches : string -> bool\<close>\<close>

definition maybe_i_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " maybe_i_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''i'')))) then True
   else if (((p00 = ('''')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val maybe_i_matches_prefix : string -> maybe ((bool * ii))\<close>\<close>

\<comment> \<open>\<open>val _s797_ : string -> maybe string\<close>\<close>

definition s797  :: " string \<Rightarrow>(string)option "  where 
     " s797 s7980 = (
   (let s7990 = s7980 in
   if ((string_startswith s7990 (''''))) then  
  (case  ((string_drop s7990 ((string_length (''''))))) of   s1 => Some s1 )
   else None))" 
  for  s7980  :: " string "


\<comment> \<open>\<open>val _s793_ : string -> maybe string\<close>\<close>

definition s793  :: " string \<Rightarrow>(string)option "  where 
     " s793 s7940 = (
   (let s7950 = s7940 in
   if ((string_startswith s7950 (''i''))) then  
  (case  ((string_drop s7950 ((string_length (''i''))))) of   s1 => Some s1 )
   else None))" 
  for  s7940  :: " string "


definition maybe_i_matches_prefix  :: " string \<Rightarrow>(bool*int)option "  where 
     " maybe_i_matches_prefix arg1 = (
   (let s7960 = arg1 in
   if ((case  ((s793 s7960)) of   Some (s1) => True | _ => False )) then  
  (case  s793 s7960 of
      (Some (s1)) =>
  Some (True, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s797 s7960)) of   Some (s1) => True | _ => False )) then  
  (case  s797 s7960 of
      (Some (s1)) =>
  Some (False, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val csr_mnemonic_forwards : csrop -> string\<close>\<close>

fun csr_mnemonic_forwards  :: " csrop \<Rightarrow> string "  where 
     " csr_mnemonic_forwards CSRRW = ( (''csrrw''))"
|" csr_mnemonic_forwards CSRRS = ( (''csrrs''))"
|" csr_mnemonic_forwards CSRRC = ( (''csrrc''))"


\<comment> \<open>\<open>val csr_mnemonic_backwards : string -> M csrop\<close>\<close>

definition csr_mnemonic_backwards  :: " string \<Rightarrow>((register_value),(csrop),(exception))monad "  where 
     " csr_mnemonic_backwards arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''csrrw'')))) then return CSRRW
   else if (((p00 = (''csrrs'')))) then return CSRRS
   else if (((p00 = (''csrrc'')))) then return CSRRC
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val csr_mnemonic_forwards_matches : csrop -> bool\<close>\<close>

fun csr_mnemonic_forwards_matches  :: " csrop \<Rightarrow> bool "  where 
     " csr_mnemonic_forwards_matches CSRRW = ( True )"
|" csr_mnemonic_forwards_matches CSRRS = ( True )"
|" csr_mnemonic_forwards_matches CSRRC = ( True )"


\<comment> \<open>\<open>val csr_mnemonic_backwards_matches : string -> bool\<close>\<close>

definition csr_mnemonic_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " csr_mnemonic_backwards_matches arg1 = (
   (let p00 = arg1 in
   if (((p00 = (''csrrw'')))) then True
   else if (((p00 = (''csrrs'')))) then True
   else if (((p00 = (''csrrc'')))) then True
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val csr_mnemonic_matches_prefix : string -> maybe ((csrop * ii))\<close>\<close>

\<comment> \<open>\<open>val _s809_ : string -> maybe string\<close>\<close>

definition s809  :: " string \<Rightarrow>(string)option "  where 
     " s809 s8100 = (
   (let s8110 = s8100 in
   if ((string_startswith s8110 (''csrrc''))) then  
  (case  ((string_drop s8110 ((string_length (''csrrc''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s8100  :: " string "


\<comment> \<open>\<open>val _s805_ : string -> maybe string\<close>\<close>

definition s805  :: " string \<Rightarrow>(string)option "  where 
     " s805 s8060 = (
   (let s8070 = s8060 in
   if ((string_startswith s8070 (''csrrs''))) then  
  (case  ((string_drop s8070 ((string_length (''csrrs''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s8060  :: " string "


\<comment> \<open>\<open>val _s801_ : string -> maybe string\<close>\<close>

definition s801  :: " string \<Rightarrow>(string)option "  where 
     " s801 s8020 = (
   (let s8030 = s8020 in
   if ((string_startswith s8030 (''csrrw''))) then  
  (case  ((string_drop s8030 ((string_length (''csrrw''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s8020  :: " string "


definition csr_mnemonic_matches_prefix  :: " string \<Rightarrow>(csrop*int)option "  where 
     " csr_mnemonic_matches_prefix arg1 = (
   (let s8040 = arg1 in
   if ((case  ((s801 s8040)) of   Some (s1) => True | _ => False )) then  
  (case  s801 s8040 of
      (Some (s1)) =>
  Some (CSRRW, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s805 s8040)) of   Some (s1) => True | _ => False )) then  
  (case  s805 s8040 of
      (Some (s1)) =>
  Some (CSRRS, ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s809 s8040)) of   Some (s1) => True | _ => False )) then  
  (case  s809 s8040 of
      (Some (s1)) =>
  Some (CSRRC, ((string_length arg1)) - ((string_length s1)))
  )
   else None))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val encdec_forwards : ast -> M (mword ty32)\<close>\<close>

fun encdec_forwards  :: " ast \<Rightarrow>((register_value),((32)Word.word),(exception))monad "  where 
     " encdec_forwards (UTYPE ((imm, rd, op1))) = (
      return ((concat_vec imm
                 ((concat_vec rd ((encdec_uop_forwards op1  ::  7 Word.word))  ::  12 Word.word))
                ::  32 Word.word)))" 
  for  op1  :: " uop " 
  and  imm  :: "(20)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RISCV_JAL ((v__2, rd))) = (
      if (((((subrange_vec_dec v__2 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        (let (imm_19 :: 1 bits) = ((subrange_vec_dec v__2 (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word)) in
        (let (imm_8 :: 1 bits) = ((subrange_vec_dec v__2 (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word)) in
        (let (imm_7_0 :: 8 bits) = ((subrange_vec_dec v__2 (( 19 :: int)::ii) (( 12 :: int)::ii)  ::  8 Word.word)) in
        (let (imm_19 :: 1 bits) = ((subrange_vec_dec v__2 (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word)) in
        (let (imm_18_13 :: 6 bits) = ((subrange_vec_dec v__2 (( 10 :: int)::ii) (( 5 :: int)::ii)  ::  6 Word.word)) in
        (let (imm_12_9 :: 4 bits) = ((subrange_vec_dec v__2 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) in
        return ((concat_vec imm_19
                   ((concat_vec imm_18_13
                       ((concat_vec imm_12_9
                           ((concat_vec imm_8
                               ((concat_vec imm_7_0
                                   ((concat_vec rd (vec_of_bits [B1,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)
                                      ::  12 Word.word))
                                  ::  20 Word.word))
                              ::  21 Word.word))
                          ::  25 Word.word))
                      ::  31 Word.word))
                  ::  32 Word.word))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__2  :: "(21)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RISCV_JALR ((imm, rs1, rd))) = (
      return ((concat_vec imm
                 ((concat_vec rs1
                     ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                         ((concat_vec rd (vec_of_bits [B1,B1,B0,B0,B1,B1,B1]  ::  7 Word.word)
                            ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word)))" 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (BTYPE ((v__4, rs2, rs1, op1))) = (
      if (((((subrange_vec_dec v__4 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        (let (imm7_6 :: 1 bits) = ((subrange_vec_dec v__4 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
        (let (imm7_6 :: 1 bits) = ((subrange_vec_dec v__4 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
        (let (imm7_5_0 :: 6 bits) = ((subrange_vec_dec v__4 (( 10 :: int)::ii) (( 5 :: int)::ii)  ::  6 Word.word)) in
        (let (imm5_4_1 :: 4 bits) = ((subrange_vec_dec v__4 (( 4 :: int)::ii) (( 1 :: int)::ii)  ::  4 Word.word)) in
        (let (imm5_0 :: 1 bits) = ((subrange_vec_dec v__4 (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word)) in
        return ((concat_vec imm7_6
                   ((concat_vec imm7_5_0
                       ((concat_vec rs2
                           ((concat_vec rs1
                               ((concat_vec ((encdec_bop_forwards op1  ::  3 Word.word))
                                   ((concat_vec imm5_4_1
                                       ((concat_vec imm5_0
                                           (vec_of_bits [B1,B1,B0,B0,B0,B1,B1]  ::  7 Word.word)
                                          ::  8 Word.word))
                                      ::  12 Word.word))
                                  ::  15 Word.word))
                              ::  20 Word.word))
                          ::  25 Word.word))
                      ::  31 Word.word))
                  ::  32 Word.word)))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  op1  :: " bop " 
  and  rs2  :: "(5)Word.word " 
  and  v__4  :: "(13)Word.word " 
  and  rs1  :: "(5)Word.word "
|" encdec_forwards (ITYPE ((imm, rs1, rd, op1))) = (
      return ((concat_vec imm
                 ((concat_vec rs1
                     ((concat_vec ((encdec_iop_forwards op1  ::  3 Word.word))
                         ((concat_vec rd (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word)
                            ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word)))" 
  for  op1  :: " iop " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (SHIFTIOP ((shamt, rs1, rd, RISCV_SLLI))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)
                 ((concat_vec shamt
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B0,B0,B1]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  26 Word.word))
                ::  32 Word.word)))" 
  for  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (SHIFTIOP ((shamt, rs1, rd, RISCV_SRLI))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)
                 ((concat_vec shamt
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  26 Word.word))
                ::  32 Word.word)))" 
  for  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (SHIFTIOP ((shamt, rs1, rd, RISCV_SRAI))) = (
      return ((concat_vec (vec_of_bits [B0,B1,B0,B0,B0,B0]  ::  6 Word.word)
                 ((concat_vec shamt
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  26 Word.word))
                ::  32 Word.word)))" 
  for  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPE ((rs2, rs1, rd, RISCV_ADD))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPE ((rs2, rs1, rd, RISCV_SLT))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B0,B1,B0]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPE ((rs2, rs1, rd, RISCV_SLTU))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B0,B1,B1]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPE ((rs2, rs1, rd, RISCV_AND))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B1,B1,B1]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPE ((rs2, rs1, rd, RISCV_OR))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B1,B1,B0]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPE ((rs2, rs1, rd, RISCV_XOR))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPE ((rs2, rs1, rd, RISCV_SLL))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B0,B0,B1]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPE ((rs2, rs1, rd, RISCV_SRL))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPE ((rs2, rs1, rd, RISCV_SUB))) = (
      return ((concat_vec (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPE ((rs2, rs1, rd, RISCV_SRA))) = (
      return ((concat_vec (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
                             ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (LOAD ((imm, rs1, rd, is_unsigned, size1, False, False))) = (
      if (((((((word_width_bytes size1)) < (( 4 :: int)::ii))) \<or> (((((\<not> is_unsigned)) \<and> ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))))))) then
        return ((concat_vec imm
                   ((concat_vec rs1
                       ((concat_vec ((bool_bits_forwards is_unsigned  ::  1 Word.word))
                           ((concat_vec ((size_bits_forwards size1  ::  2 Word.word))
                               ((concat_vec rd (vec_of_bits [B0,B0,B0,B0,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  14 Word.word))
                          ::  15 Word.word))
                      ::  20 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  size1  :: " word_width " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  is_unsigned  :: " bool "
|" encdec_forwards (STORE ((v__6, rs2, rs1, size1, False, False))) = (
      if ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))) then
        (let (imm7 :: 7 bits) = ((subrange_vec_dec v__6 (( 11 :: int)::ii) (( 5 :: int)::ii)  ::  7 Word.word)) in
        (let (imm7 :: 7 bits) = ((subrange_vec_dec v__6 (( 11 :: int)::ii) (( 5 :: int)::ii)  ::  7 Word.word)) in
        (let (imm5 :: 5 bits) = ((subrange_vec_dec v__6 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec imm7
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                               ((concat_vec ((size_bits_forwards size1  ::  2 Word.word))
                                   ((concat_vec imm5
                                       (vec_of_bits [B0,B1,B0,B0,B0,B1,B1]  ::  7 Word.word)
                                      ::  12 Word.word))
                                  ::  14 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  size1  :: " word_width " 
  and  v__6  :: "(12)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word "
|" encdec_forwards (ADDIW ((imm, rs1, rd))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec imm
                   ((concat_vec rs1
                       ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                           ((concat_vec rd (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)
                              ::  12 Word.word))
                          ::  15 Word.word))
                      ::  20 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (SHIFTW ((shamt, rs1, rd, RISCV_SLLI))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B0,B0,B1]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (SHIFTW ((shamt, rs1, rd, RISCV_SRLI))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (SHIFTW ((shamt, rs1, rd, RISCV_SRAI))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPEW ((rs2, rs1, rd, RISCV_ADDW))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPEW ((rs2, rs1, rd, RISCV_SUBW))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPEW ((rs2, rs1, rd, RISCV_SLLW))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B0,B0,B1]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPEW ((rs2, rs1, rd, RISCV_SRLW))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (RTYPEW ((rs2, rs1, rd, RISCV_SRAW))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (SHIFTIWOP ((shamt, rs1, rd, RISCV_SLLIW))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B0,B0,B1]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (SHIFTIWOP ((shamt, rs1, rd, RISCV_SRLIW))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (SHIFTIWOP ((shamt, rs1, rd, RISCV_SRAIW))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)
                   ((concat_vec shamt
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (FENCE ((pred, succ))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)
                 ((concat_vec pred
                     ((concat_vec succ
                         ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                             ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                                 ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                                     (vec_of_bits [B0,B0,B0,B1,B1,B1,B1]  ::  7 Word.word)
                                    ::  12 Word.word))
                                ::  15 Word.word))
                            ::  20 Word.word))
                        ::  24 Word.word))
                    ::  28 Word.word))
                ::  32 Word.word)))" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|" encdec_forwards (FENCE_TSO ((pred, succ))) = (
      return ((concat_vec (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)
                 ((concat_vec pred
                     ((concat_vec succ
                         ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                             ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                                 ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                                     (vec_of_bits [B0,B0,B0,B1,B1,B1,B1]  ::  7 Word.word)
                                    ::  12 Word.word))
                                ::  15 Word.word))
                            ::  20 Word.word))
                        ::  24 Word.word))
                    ::  28 Word.word))
                ::  32 Word.word)))" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|" encdec_forwards (FENCEI (_)) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
                 ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                     ((concat_vec (vec_of_bits [B0,B0,B1]  ::  3 Word.word)
                         ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                             (vec_of_bits [B0,B0,B0,B1,B1,B1,B1]  ::  7 Word.word)
                            ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word)))"
|" encdec_forwards (ECALL (_)) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
                 ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                     ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                         ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                             (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                            ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word)))"
|" encdec_forwards (MRET (_)) = (
      return ((concat_vec (vec_of_bits [B0,B0,B1,B1,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)
                     ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                         ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                             ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                                 (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))"
|" encdec_forwards (SRET (_)) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B1,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)
                     ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                         ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                             ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                                 (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))"
|" encdec_forwards (EBREAK (_)) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  12 Word.word)
                 ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                     ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                         ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                             (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                            ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word)))"
|" encdec_forwards (WFI (_)) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1]  ::  12 Word.word)
                 ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                     ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                         ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                             (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                            ::  12 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word)))"
|" encdec_forwards (SFENCE_VMA ((rs1, rs2))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B1,B0,B0,B1]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                             ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                                 (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word "
|" encdec_forwards (LOADRES ((aq, rl, rs1, size1, rd))) = (
      if ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)
                   ((concat_vec ((bool_bits_forwards aq  ::  1 Word.word))
                       ((concat_vec ((bool_bits_forwards rl  ::  1 Word.word))
                           ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                               ((concat_vec rs1
                                   ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                                       ((concat_vec ((size_bits_forwards size1  ::  2 Word.word))
                                           ((concat_vec rd
                                               (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)
                                              ::  12 Word.word))
                                          ::  14 Word.word))
                                      ::  15 Word.word))
                                  ::  20 Word.word))
                              ::  25 Word.word))
                          ::  26 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  size1  :: " word_width " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" encdec_forwards (STORECON ((aq, rl, rs2, rs1, size1, rd))) = (
      if ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)
                   ((concat_vec ((bool_bits_forwards aq  ::  1 Word.word))
                       ((concat_vec ((bool_bits_forwards rl  ::  1 Word.word))
                           ((concat_vec rs2
                               ((concat_vec rs1
                                   ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                                       ((concat_vec ((size_bits_forwards size1  ::  2 Word.word))
                                           ((concat_vec rd
                                               (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)
                                              ::  12 Word.word))
                                          ::  14 Word.word))
                                      ::  15 Word.word))
                                  ::  20 Word.word))
                              ::  25 Word.word))
                          ::  26 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  size1  :: " word_width " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" encdec_forwards (AMO ((op1, aq, rl, rs2, rs1, size1, rd))) = (
      if ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))) then
        return ((concat_vec ((encdec_amoop_forwards op1  ::  5 Word.word))
                   ((concat_vec ((bool_bits_forwards aq  ::  1 Word.word))
                       ((concat_vec ((bool_bits_forwards rl  ::  1 Word.word))
                           ((concat_vec rs2
                               ((concat_vec rs1
                                   ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                                       ((concat_vec ((size_bits_forwards size1  ::  2 Word.word))
                                           ((concat_vec rd
                                               (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)
                                              ::  12 Word.word))
                                          ::  14 Word.word))
                                      ::  15 Word.word))
                                  ::  20 Word.word))
                              ::  25 Word.word))
                          ::  26 Word.word))
                      ::  27 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  size1  :: " word_width " 
  and  op1  :: " amoop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" encdec_forwards (MUL ((rs2, rs1, rd, high, signed1, signed2))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec
                             ((encdec_mul_op_forwards (high, signed1, signed2)  ::  3 Word.word))
                             ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  signed2  :: " bool " 
  and  signed1  :: " bool " 
  and  high  :: " bool " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (DIV ((rs2, rs1, rd, s))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B1,B0]  ::  2 Word.word)
                             ((concat_vec ((bool_not_bits_forwards s  ::  1 Word.word))
                                 ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                    ::  12 Word.word))
                                ::  13 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" encdec_forwards (REM ((rs2, rs1, rd, s))) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)
                 ((concat_vec rs2
                     ((concat_vec rs1
                         ((concat_vec (vec_of_bits [B1,B1]  ::  2 Word.word)
                             ((concat_vec ((bool_not_bits_forwards s  ::  1 Word.word))
                                 ((concat_vec rd (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                    ::  12 Word.word))
                                ::  13 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" encdec_forwards (MULW ((rs2, rs1, rd))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                               ((concat_vec rd (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                  ::  12 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards (DIVW ((rs2, rs1, rd, s))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B1,B0]  ::  2 Word.word)
                               ((concat_vec ((bool_not_bits_forwards s  ::  1 Word.word))
                                   ((concat_vec rd (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                      ::  12 Word.word))
                                  ::  13 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" encdec_forwards (REMW ((rs2, rs1, rd, s))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)
                   ((concat_vec rs2
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B1,B1]  ::  2 Word.word)
                               ((concat_vec ((bool_not_bits_forwards s  ::  1 Word.word))
                                   ((concat_vec rd (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)
                                      ::  12 Word.word))
                                  ::  13 Word.word))
                              ::  15 Word.word))
                          ::  20 Word.word))
                      ::  25 Word.word))
                  ::  32 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" encdec_forwards (CSR ((csr, rs1, rd, is_imm, op1))) = (
      return ((concat_vec csr
                 ((concat_vec rs1
                     ((concat_vec ((bool_bits_forwards is_imm  ::  1 Word.word))
                         ((concat_vec ((encdec_csrop_forwards op1  ::  2 Word.word))
                             ((concat_vec rd (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  14 Word.word))
                        ::  15 Word.word))
                    ::  20 Word.word))
                ::  32 Word.word)))" 
  for  op1  :: " csrop " 
  and  is_imm  :: " bool " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  csr  :: "(12)Word.word "
|" encdec_forwards (URET (_)) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)
                 ((concat_vec (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)
                     ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                         ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                             ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                                 (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)
                                ::  12 Word.word))
                            ::  15 Word.word))
                        ::  20 Word.word))
                    ::  25 Word.word))
                ::  32 Word.word)))"
|" encdec_forwards (ILLEGAL (s)) = ( return s )" 
  for  s  :: "(32)Word.word "
|" encdec_forwards _ = ( assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )"


\<comment> \<open>\<open>val encdec_backwards : mword ty32 -> M ast\<close>\<close>

definition encdec_backwards  :: "(32)Word.word \<Rightarrow>((register_value),(ast),(exception))monad "  where 
     " encdec_backwards arg1 = (
   (let v__7 = arg1 in
   (let (mappingpatterns_230 ::  7 Word.word) = ((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) in
   and_boolM (return ((encdec_uop_backwards_matches mappingpatterns_230)))
     (if ((encdec_uop_backwards_matches mappingpatterns_230)) then
        encdec_uop_backwards mappingpatterns_230 \<bind> (\<lambda> op1 .  return True)
      else return False) \<bind> (\<lambda> (w__1 :: bool) . 
   if w__1 then
     (let (imm ::  20 Word.word) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm ::  20 Word.word) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 12 :: int)::ii)  ::  20 Word.word)) in
     (let (mappingpatterns_230 ::  7 Word.word) = ((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) in
     encdec_uop_backwards mappingpatterns_230 \<bind> (\<lambda> op1 .  return (UTYPE (imm, rd, op1)))))))
   else if (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))) then
     (let (imm_19 :: 1 bits) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm_8 :: 1 bits) = ((subrange_vec_dec v__7 (( 20 :: int)::ii) (( 20 :: int)::ii)  ::  1 Word.word)) in
     (let (imm_7_0 :: 8 bits) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 12 :: int)::ii)  ::  8 Word.word)) in
     (let (imm_19 :: 1 bits) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) in
     (let (imm_18_13 :: 6 bits) = ((subrange_vec_dec v__7 (( 30 :: int)::ii) (( 25 :: int)::ii)  ::  6 Word.word)) in
     (let (imm_12_9 :: 4 bits) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 21 :: int)::ii)  ::  4 Word.word)) in
     return (RISCV_JAL ((concat_vec imm_19
                           ((concat_vec imm_7_0
                               ((concat_vec imm_8
                                   ((concat_vec imm_18_13
                                       ((concat_vec imm_12_9 (vec_of_bits [B0]  ::  1 Word.word)
                                          ::  5 Word.word))
                                      ::  11 Word.word))
                                  ::  12 Word.word))
                              ::  20 Word.word))
                          ::  21 Word.word),
                        rd)))))))))
   else if ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B1,B1]  ::  7 Word.word))))))) then
     (let (imm ::  12 Word.word) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm ::  12 Word.word) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
     return (RISCV_JALR (imm, rs1, rd))))))
   else
     and_boolM
       ((let (mappingpatterns_240 ::  3 Word.word) =
         ((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
       and_boolM (return ((encdec_bop_backwards_matches mappingpatterns_240)))
         (if ((encdec_bop_backwards_matches mappingpatterns_240)) then
            encdec_bop_backwards mappingpatterns_240 \<bind> (\<lambda> op1 .  return True)
          else return False)))
       (return (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))) \<bind> (\<lambda> (w__4 :: bool) . 
     if w__4 then
       (let (imm7_6 :: 1 bits) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) in
       (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
       (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
       (let (imm7_6 :: 1 bits) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 31 :: int)::ii)  ::  1 Word.word)) in
       (let (imm7_5_0 :: 6 bits) = ((subrange_vec_dec v__7 (( 30 :: int)::ii) (( 25 :: int)::ii)  ::  6 Word.word)) in
       (let (imm5_4_1 :: 4 bits) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 8 :: int)::ii)  ::  4 Word.word)) in
       (let (imm5_0 :: 1 bits) = ((subrange_vec_dec v__7 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
       (let (mappingpatterns_240 ::  3 Word.word) = ((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
       encdec_bop_backwards mappingpatterns_240 \<bind> (\<lambda> op1 . 
       return (BTYPE ((concat_vec imm7_6
                         ((concat_vec imm5_0
                             ((concat_vec imm7_5_0
                                 ((concat_vec imm5_4_1 (vec_of_bits [B0]  ::  1 Word.word)  ::  5 Word.word))
                                ::  11 Word.word))
                            ::  12 Word.word))
                        ::  13 Word.word),
                      rs2,
                      rs1,
                      op1)))))))))))
     else
       and_boolM
         ((let (mappingpatterns_250 ::  3 Word.word) =
           ((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
         and_boolM (return ((encdec_iop_backwards_matches mappingpatterns_250)))
           (if ((encdec_iop_backwards_matches mappingpatterns_250)) then
              encdec_iop_backwards mappingpatterns_250 \<bind> (\<lambda> op1 .  return True)
            else return False)))
         (return (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))) \<bind> (\<lambda> (w__7 :: bool) . 
       if w__7 then
         (let (imm ::  12 Word.word) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         (let (imm ::  12 Word.word) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
         (let (mappingpatterns_250 ::  3 Word.word) =
           ((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
         encdec_iop_backwards mappingpatterns_250 \<bind> (\<lambda> op1 .  return (ITYPE (imm, rs1, rd, op1))))))))
       else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
                   (((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((bit_to_bool ((access_vec_dec shamt (( 5 :: int)::ii))))) = False)))))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))))))))) then
         (let (shamt ::  6 Word.word) = ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (SHIFTIOP (shamt, rs1, rd, RISCV_SLLI)))))
       else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
                   (((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((bit_to_bool ((access_vec_dec shamt (( 5 :: int)::ii))))) = False)))))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))))))))) then
         (let (shamt ::  6 Word.word) = ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (SHIFTIOP (shamt, rs1, rd, RISCV_SRLI)))))
       else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
                   (((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((bit_to_bool ((access_vec_dec shamt (( 5 :: int)::ii))))) = False)))))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))))))))) then
         (let (shamt ::  6 Word.word) = ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (SHIFTIOP (shamt, rs1, rd, RISCV_SRAI)))))
       else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPE (rs2, rs1, rd, RISCV_ADD)))))
       else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPE (rs2, rs1, rd, RISCV_SLT)))))
       else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPE (rs2, rs1, rd, RISCV_SLTU)))))
       else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPE (rs2, rs1, rd, RISCV_AND)))))
       else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPE (rs2, rs1, rd, RISCV_OR)))))
       else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPE (rs2, rs1, rd, RISCV_XOR)))))
       else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPE (rs2, rs1, rd, RISCV_SLL)))))
       else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPE (rs2, rs1, rd, RISCV_SRL)))))
       else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPE (rs2, rs1, rd, RISCV_SUB)))))
       else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
         (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
         return (RTYPE (rs2, rs1, rd, RISCV_SRA)))))
       else
         and_boolM
           ((let (mappingpatterns_270 ::  2 Word.word) =
             ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
           (let (mappingpatterns_260 ::  1 Word.word) =
             ((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
           and_boolM (return ((size_bits_backwards_matches mappingpatterns_270)))
             (if ((size_bits_backwards_matches mappingpatterns_270)) then
                size_bits_backwards mappingpatterns_270 \<bind> (\<lambda> size1 . 
                and_boolM (return ((bool_bits_backwards_matches mappingpatterns_260)))
                  (if ((bool_bits_backwards_matches mappingpatterns_260)) then
                     bool_bits_backwards mappingpatterns_260 \<bind> (\<lambda> is_unsigned . 
                     return (((((((word_width_bytes size1)) < (( 4 :: int)::ii))) \<or> (((((\<not> is_unsigned)) \<and> ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))))))))
                   else return False) \<bind> (\<lambda> (w__9 :: bool) . 
                return w__9))
              else return False))))
           (return (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1]  ::  7 Word.word))))) \<bind> (\<lambda> (w__12 :: bool) . 
         if w__12 then
           (let (imm ::  12 Word.word) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
           (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
           (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
           (let (imm ::  12 Word.word) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
           (let (mappingpatterns_270 ::  2 Word.word) =
             ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
           (let (mappingpatterns_260 ::  1 Word.word) =
             ((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
           size_bits_backwards mappingpatterns_270 \<bind> (\<lambda> size1 . 
           bool_bits_backwards mappingpatterns_260 \<bind> (\<lambda> is_unsigned . 
           return (LOAD (imm, rs1, rd, is_unsigned, size1, False, False))))))))))
         else
           and_boolM
             ((let (mappingpatterns_280 ::  2 Word.word) =
               ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
             and_boolM (return ((size_bits_backwards_matches mappingpatterns_280)))
               (if ((size_bits_backwards_matches mappingpatterns_280)) then
                  size_bits_backwards mappingpatterns_280 \<bind> (\<lambda> size1 . 
                  return ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))
                else return False)))
             (return ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B1,B1]  ::  7 Word.word)))))))) \<bind> (\<lambda> (w__15 ::
             bool) . 
           if w__15 then
             (let (imm7 :: 7 bits) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
             (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (imm7 :: 7 bits) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) in
             (let (imm5 :: 5 bits) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             (let (mappingpatterns_280 ::  2 Word.word) =
               ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
             size_bits_backwards mappingpatterns_280 \<bind> (\<lambda> size1 . 
             return (STORE ((concat_vec imm7 imm5  ::  12 Word.word), rs2, rs1, size1, False, False)))))))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
             (let (imm ::  12 Word.word) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             (let (imm ::  12 Word.word) = ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
             return (ADDIW (imm, rs1, rd))))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             return (SHIFTW (shamt, rs1, rd, RISCV_SLLI)))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             return (SHIFTW (shamt, rs1, rd, RISCV_SRLI)))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             return (SHIFTW (shamt, rs1, rd, RISCV_SRAI)))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             return (RTYPEW (rs2, rs1, rd, RISCV_ADDW)))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             return (RTYPEW (rs2, rs1, rd, RISCV_SUBW)))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             return (RTYPEW (rs2, rs1, rd, RISCV_SLLW)))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             return (RTYPEW (rs2, rs1, rd, RISCV_SRLW)))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             return (RTYPEW (rs2, rs1, rd, RISCV_SRAW)))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             return (SHIFTIWOP (shamt, rs1, rd, RISCV_SLLIW)))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             return (SHIFTIWOP (shamt, rs1, rd, RISCV_SRLIW)))))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             (let (shamt ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
             return (SHIFTIWOP (shamt, rs1, rd, RISCV_SRAIW)))))
           else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 0 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1]
                             ::  20 Word.word))))))) then
             (let (succ ::  4 Word.word) = ((subrange_vec_dec v__7 (( 23 :: int)::ii) (( 20 :: int)::ii)  ::  4 Word.word)) in
             (let (pred ::  4 Word.word) = ((subrange_vec_dec v__7 (( 27 :: int)::ii) (( 24 :: int)::ii)  ::  4 Word.word)) in
             return (FENCE (pred, succ))))
           else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 0 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1]
                             ::  20 Word.word))))))) then
             (let (succ ::  4 Word.word) = ((subrange_vec_dec v__7 (( 23 :: int)::ii) (( 20 :: int)::ii)  ::  4 Word.word)) in
             (let (pred ::  4 Word.word) = ((subrange_vec_dec v__7 (( 27 :: int)::ii) (( 24 :: int)::ii)  ::  4 Word.word)) in
             return (FENCE_TSO (pred, succ))))
           else if (((v__7 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,
                                     B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1]
                         ::  32 Word.word)))) then
             return (FENCEI () )
           else if (((v__7 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]
                         ::  32 Word.word)))) then
             return (ECALL () )
           else if (((v__7 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]
                         ::  32 Word.word)))) then
             return (MRET () )
           else if (((v__7 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]
                         ::  32 Word.word)))) then
             return (SRET () )
           else if (((v__7 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]
                         ::  32 Word.word)))) then
             return (EBREAK () )
           else if (((v__7 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]
                         ::  32 Word.word)))) then
             return (WFI () )
           else if ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0,B0,B1]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 0 :: int)::ii)  ::  15 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]  ::  15 Word.word)))))))
           then
             (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
             (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
             return (SFENCE_VMA (rs1, rs2))))
           else
             and_boolM
               ((let (mappingpatterns_310 ::  2 Word.word) =
                 ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
               (let (mappingpatterns_300 ::  1 Word.word) =
                 ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_290 ::  1 Word.word) =
                 ((subrange_vec_dec v__7 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
               and_boolM (return ((size_bits_backwards_matches mappingpatterns_310)))
                 (if ((size_bits_backwards_matches mappingpatterns_310)) then
                    size_bits_backwards mappingpatterns_310 \<bind> (\<lambda> size1 . 
                    and_boolM (return ((bool_bits_backwards_matches mappingpatterns_300)))
                      (if ((bool_bits_backwards_matches mappingpatterns_300)) then
                         bool_bits_backwards mappingpatterns_300 \<bind> (\<lambda> rl . 
                         and_boolM (return ((bool_bits_backwards_matches mappingpatterns_290)))
                           (if ((bool_bits_backwards_matches mappingpatterns_290)) then
                              bool_bits_backwards mappingpatterns_290 \<bind> (\<lambda> aq . 
                              return ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))
                            else return False) \<bind> (\<lambda> (w__17 :: bool) . 
                         return w__17))
                       else return False) \<bind> (\<lambda> (w__19 :: bool) . 
                    return w__19))
                  else return False)))))
               (return ((((((((regidx_to_regno
                                   ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))) \<and> ((((((((regidx_to_regno
                                       ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)))) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))))))) \<bind> (\<lambda> (w__22 ::
               bool) . 
             if w__22 then
               (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
               (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (mappingpatterns_310 ::  2 Word.word) =
                 ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
               (let (mappingpatterns_300 ::  1 Word.word) =
                 ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_290 ::  1 Word.word) =
                 ((subrange_vec_dec v__7 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
               size_bits_backwards mappingpatterns_310 \<bind> (\<lambda> size1 . 
               bool_bits_backwards mappingpatterns_300 \<bind> (\<lambda> rl . 
               bool_bits_backwards mappingpatterns_290 \<bind> (\<lambda> aq . 
               return (LOADRES (aq, rl, rs1, size1, rd))))))))))
             else
               and_boolM
                 ((let (mappingpatterns_340 ::  2 Word.word) =
                   ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                 (let (mappingpatterns_330 ::  1 Word.word) =
                   ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
                 (let (mappingpatterns_320 ::  1 Word.word) =
                   ((subrange_vec_dec v__7 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
                 and_boolM (return ((size_bits_backwards_matches mappingpatterns_340)))
                   (if ((size_bits_backwards_matches mappingpatterns_340)) then
                      size_bits_backwards mappingpatterns_340 \<bind> (\<lambda> size1 . 
                      and_boolM (return ((bool_bits_backwards_matches mappingpatterns_330)))
                        (if ((bool_bits_backwards_matches mappingpatterns_330)) then
                           bool_bits_backwards mappingpatterns_330 \<bind> (\<lambda> rl . 
                           and_boolM (return ((bool_bits_backwards_matches mappingpatterns_320)))
                             (if ((bool_bits_backwards_matches mappingpatterns_320)) then
                                bool_bits_backwards mappingpatterns_320 \<bind> (\<lambda> aq . 
                                return ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))
                              else return False) \<bind> (\<lambda> (w__24 :: bool) . 
                           return w__24))
                         else return False) \<bind> (\<lambda> (w__26 :: bool) . 
                      return w__26))
                    else return False)))))
                 (return ((((((((regidx_to_regno
                                     ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word))))))))))) \<bind> (\<lambda> (w__29 ::
                 bool) . 
               if w__29 then
                 (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                 (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                 (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                 (let (mappingpatterns_340 ::  2 Word.word) =
                   ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                 (let (mappingpatterns_330 ::  1 Word.word) =
                   ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
                 (let (mappingpatterns_320 ::  1 Word.word) =
                   ((subrange_vec_dec v__7 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
                 size_bits_backwards mappingpatterns_340 \<bind> (\<lambda> size1 . 
                 bool_bits_backwards mappingpatterns_330 \<bind> (\<lambda> rl . 
                 bool_bits_backwards mappingpatterns_320 \<bind> (\<lambda> aq . 
                 return (STORECON (aq, rl, rs2, rs1, size1, rd)))))))))))
               else
                 and_boolM
                   ((let (mappingpatterns_350 ::  5 Word.word) =
                     ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                   (let (mappingpatterns_380 ::  2 Word.word) =
                     ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                   (let (mappingpatterns_370 ::  1 Word.word) =
                     ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
                   (let (mappingpatterns_360 ::  1 Word.word) =
                     ((subrange_vec_dec v__7 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
                   (let (mappingpatterns_350 ::  5 Word.word) =
                     ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                   and_boolM (return ((size_bits_backwards_matches mappingpatterns_380)))
                     (if ((size_bits_backwards_matches mappingpatterns_380)) then
                        size_bits_backwards mappingpatterns_380 \<bind> (\<lambda> size1 . 
                        and_boolM (return ((bool_bits_backwards_matches mappingpatterns_370)))
                          (if ((bool_bits_backwards_matches mappingpatterns_370)) then
                             bool_bits_backwards mappingpatterns_370 \<bind> (\<lambda> rl . 
                             and_boolM (return ((bool_bits_backwards_matches mappingpatterns_360)))
                               (if ((bool_bits_backwards_matches mappingpatterns_360)) then
                                  bool_bits_backwards mappingpatterns_360 \<bind> (\<lambda> aq . 
                                  and_boolM
                                    (return ((encdec_amoop_backwards_matches mappingpatterns_350)))
                                    (if ((encdec_amoop_backwards_matches mappingpatterns_350)) then
                                       encdec_amoop_backwards mappingpatterns_350 \<bind> (\<lambda> op1 . 
                                       return ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))
                                     else return False) \<bind> (\<lambda> (w__31 :: bool) . 
                                  return w__31))
                                else return False) \<bind> (\<lambda> (w__33 :: bool) . 
                             return w__33))
                           else return False) \<bind> (\<lambda> (w__35 :: bool) . 
                        return w__35))
                      else return False)))))))
                   (return ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))) \<bind> (\<lambda> (w__38 ::
                   bool) . 
                 if w__38 then
                   (let (mappingpatterns_350 ::  5 Word.word) =
                     ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                   (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                   (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                   (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                   (let (mappingpatterns_380 ::  2 Word.word) =
                     ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                   (let (mappingpatterns_370 ::  1 Word.word) =
                     ((subrange_vec_dec v__7 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
                   (let (mappingpatterns_360 ::  1 Word.word) =
                     ((subrange_vec_dec v__7 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
                   (let (mappingpatterns_350 ::  5 Word.word) =
                     ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                   size_bits_backwards mappingpatterns_380 \<bind> (\<lambda> size1 . 
                   bool_bits_backwards mappingpatterns_370 \<bind> (\<lambda> rl . 
                   bool_bits_backwards mappingpatterns_360 \<bind> (\<lambda> aq . 
                   encdec_amoop_backwards mappingpatterns_350 \<bind> (\<lambda> op1 . 
                   return (AMO (op1, aq, rl, rs2, rs1, size1, rd))))))))))))))
                 else
                   and_boolM
                     ((let (mappingpatterns_390 ::  3 Word.word) =
                       ((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                     and_boolM (return ((encdec_mul_op_backwards_matches mappingpatterns_390)))
                       (if ((encdec_mul_op_backwards_matches mappingpatterns_390)) then
                          encdec_mul_op_backwards mappingpatterns_390 \<bind> (\<lambda> varstup .  (let (high, signed1, signed2) = varstup in
                          return True))
                        else return False)))
                     (return ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))) \<bind> (\<lambda> (w__41 ::
                     bool) . 
                   if w__41 then
                     (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                     (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                     (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                     (let (mappingpatterns_390 ::  3 Word.word) =
                       ((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                     encdec_mul_op_backwards mappingpatterns_390 \<bind> (\<lambda> varstup .  (let (high, signed1, signed2) = varstup in
                     return (MUL (rs2, rs1, rd, high, signed1, signed2))))))))
                   else
                     and_boolM
                       ((let (mappingpatterns_400 ::  1 Word.word) =
                         ((subrange_vec_dec v__7 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                       and_boolM (return ((bool_not_bits_backwards_matches mappingpatterns_400)))
                         (if ((bool_not_bits_backwards_matches mappingpatterns_400)) then
                            bool_not_bits_backwards mappingpatterns_400 \<bind> (\<lambda> s .  return True)
                          else return False)))
                       (return ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))))))))) \<bind> (\<lambda> (w__44 ::
                       bool) . 
                     if w__44 then
                       (let (rs2 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                       (let (rs1 ::  5 Word.word) = ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                       (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                       (let (mappingpatterns_400 ::  1 Word.word) =
                         ((subrange_vec_dec v__7 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                       bool_not_bits_backwards mappingpatterns_400 \<bind> (\<lambda> s . 
                       return (DIV (rs2, rs1, rd, s)))))))
                     else
                       and_boolM
                         ((let (mappingpatterns_410 ::  1 Word.word) =
                           ((subrange_vec_dec v__7 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                         and_boolM (return ((bool_not_bits_backwards_matches mappingpatterns_410)))
                           (if ((bool_not_bits_backwards_matches mappingpatterns_410)) then
                              bool_not_bits_backwards mappingpatterns_410 \<bind> (\<lambda> s .  return True)
                            else return False)))
                         (return ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))))))))) \<bind> (\<lambda> (w__47 ::
                         bool) . 
                       if w__47 then
                         (let (rs2 ::  5 Word.word) =
                           ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                         (let (rs1 ::  5 Word.word) =
                           ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                         (let (mappingpatterns_410 ::  1 Word.word) =
                           ((subrange_vec_dec v__7 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                         bool_not_bits_backwards mappingpatterns_410 \<bind> (\<lambda> s . 
                         return (REM (rs2, rs1, rd, s)))))))
                       else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))))))
                       then
                         (let (rs2 ::  5 Word.word) =
                           ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                         (let (rs1 ::  5 Word.word) =
                           ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                         (let (rd ::  5 Word.word) = ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                         return (MULW (rs2, rs1, rd)))))
                       else
                         and_boolM
                           ((let (mappingpatterns_420 ::  1 Word.word) =
                             ((subrange_vec_dec v__7 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                           and_boolM
                             (return ((bool_not_bits_backwards_matches mappingpatterns_420)))
                             (if ((bool_not_bits_backwards_matches mappingpatterns_420)) then
                                bool_not_bits_backwards mappingpatterns_420 \<bind> (\<lambda> s . 
                                return ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))
                              else return False)))
                           (return ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))) \<bind> (\<lambda> (w__50 ::
                           bool) . 
                         if w__50 then
                           (let (rs2 ::  5 Word.word) =
                             ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                           (let (rs1 ::  5 Word.word) =
                             ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                           (let (rd ::  5 Word.word) =
                             ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                           (let (mappingpatterns_420 ::  1 Word.word) =
                             ((subrange_vec_dec v__7 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                           bool_not_bits_backwards mappingpatterns_420 \<bind> (\<lambda> s . 
                           return (DIVW (rs2, rs1, rd, s)))))))
                         else
                           and_boolM
                             ((let (mappingpatterns_430 ::  1 Word.word) =
                               ((subrange_vec_dec v__7 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                             and_boolM
                               (return ((bool_not_bits_backwards_matches mappingpatterns_430)))
                               (if ((bool_not_bits_backwards_matches mappingpatterns_430)) then
                                  bool_not_bits_backwards mappingpatterns_430 \<bind> (\<lambda> s . 
                                  return ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))
                                else return False)))
                             (return ((((((((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 13 :: int)::ii)
                                                    ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))) \<bind> (\<lambda> (w__53 ::
                             bool) . 
                           if w__53 then
                             (let (rs2 ::  5 Word.word) =
                               ((subrange_vec_dec v__7 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)) in
                             (let (rs1 ::  5 Word.word) =
                               ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                             (let (rd ::  5 Word.word) =
                               ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                             (let (mappingpatterns_430 ::  1 Word.word) =
                               ((subrange_vec_dec v__7 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                             bool_not_bits_backwards mappingpatterns_430 \<bind> (\<lambda> s . 
                             return (REMW (rs2, rs1, rd, s)))))))
                           else
                             and_boolM
                               ((let (mappingpatterns_450 ::  2 Word.word) =
                                 ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                               (let (mappingpatterns_440 ::  1 Word.word) =
                                 ((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
                               and_boolM
                                 (return ((encdec_csrop_backwards_matches mappingpatterns_450)))
                                 (if ((encdec_csrop_backwards_matches mappingpatterns_450)) then
                                    encdec_csrop_backwards mappingpatterns_450 \<bind> (\<lambda> op1 . 
                                    and_boolM
                                      (return ((bool_bits_backwards_matches mappingpatterns_440)))
                                      (if ((bool_bits_backwards_matches mappingpatterns_440)) then
                                         bool_bits_backwards mappingpatterns_440 \<bind> (\<lambda> is_imm . 
                                         return True)
                                       else return False) \<bind> (\<lambda> (w__55 :: bool) . 
                                    return w__55))
                                  else return False))))
                               (return (((((subrange_vec_dec v__7 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))) \<bind> (\<lambda> (w__58 ::
                               bool) . 
                             if w__58 then
                               (let (csr ::  12 Word.word) =
                                 ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                               (let (rs1 ::  5 Word.word) =
                                 ((subrange_vec_dec v__7 (( 19 :: int)::ii) (( 15 :: int)::ii)  ::  5 Word.word)) in
                               (let (rd ::  5 Word.word) =
                                 ((subrange_vec_dec v__7 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
                               (let (csr ::  12 Word.word) =
                                 ((subrange_vec_dec v__7 (( 31 :: int)::ii) (( 20 :: int)::ii)  ::  12 Word.word)) in
                               (let (mappingpatterns_450 ::  2 Word.word) =
                                 ((subrange_vec_dec v__7 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                               (let (mappingpatterns_440 ::  1 Word.word) =
                                 ((subrange_vec_dec v__7 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
                               encdec_csrop_backwards mappingpatterns_450 \<bind> (\<lambda> op1 . 
                               bool_bits_backwards mappingpatterns_440 \<bind> (\<lambda> is_imm . 
                               return (CSR (csr, rs1, rd, is_imm, op1))))))))))
                             else
                               return (if (((v__7 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0,
                                                            B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,
                                                            B1,B1,B0,B0,B1,B1]
                                                ::  32 Word.word)))) then
                                         URET () 
                                       else ILLEGAL v__7))))))))))))))))))" 
  for  arg1  :: "(32)Word.word "


\<comment> \<open>\<open>val encdec_forwards_matches : ast -> bool\<close>\<close>

fun encdec_forwards_matches  :: " ast \<Rightarrow> bool "  where 
     " encdec_forwards_matches (UTYPE ((imm, rd, op1))) = ( True )" 
  for  op1  :: " uop " 
  and  imm  :: "(20)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RISCV_JAL ((v__220, rd))) = (
      if (((((subrange_vec_dec v__220 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        True
      else False )" 
  for  v__220  :: "(21)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RISCV_JALR ((imm, rs1, rd))) = ( True )" 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (BTYPE ((v__222, rs2, rs1, op1))) = (
      if (((((subrange_vec_dec v__222 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) then
        True
      else False )" 
  for  op1  :: " bop " 
  and  v__222  :: "(13)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word "
|" encdec_forwards_matches (ITYPE ((imm, rs1, rd, op1))) = ( True )" 
  for  op1  :: " iop " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (SHIFTIOP ((shamt, rs1, rd, RISCV_SLLI))) = ( True )" 
  for  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (SHIFTIOP ((shamt, rs1, rd, RISCV_SRLI))) = ( True )" 
  for  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (SHIFTIOP ((shamt, rs1, rd, RISCV_SRAI))) = ( True )" 
  for  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPE ((rs2, rs1, rd, RISCV_ADD))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPE ((rs2, rs1, rd, RISCV_SLT))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPE ((rs2, rs1, rd, RISCV_SLTU))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPE ((rs2, rs1, rd, RISCV_AND))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPE ((rs2, rs1, rd, RISCV_OR))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPE ((rs2, rs1, rd, RISCV_XOR))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPE ((rs2, rs1, rd, RISCV_SLL))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPE ((rs2, rs1, rd, RISCV_SRL))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPE ((rs2, rs1, rd, RISCV_SUB))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPE ((rs2, rs1, rd, RISCV_SRA))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (LOAD ((imm, rs1, rd, is_unsigned, size1, False, False))) = (
      if (((((((word_width_bytes size1)) < (( 4 :: int)::ii))) \<or> (((((\<not> is_unsigned)) \<and> ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))))))) then
        True
      else False )" 
  for  size1  :: " word_width " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  is_unsigned  :: " bool "
|" encdec_forwards_matches (STORE ((v__224, rs2, rs1, size1, False, False))) = (
      if ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))) then True else False )" 
  for  size1  :: " word_width " 
  and  v__224  :: "(12)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word "
|" encdec_forwards_matches (ADDIW ((imm, rs1, rd))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (SHIFTW ((shamt, rs1, rd, RISCV_SLLI))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (SHIFTW ((shamt, rs1, rd, RISCV_SRLI))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (SHIFTW ((shamt, rs1, rd, RISCV_SRAI))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPEW ((rs2, rs1, rd, RISCV_ADDW))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPEW ((rs2, rs1, rd, RISCV_SUBW))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPEW ((rs2, rs1, rd, RISCV_SLLW))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPEW ((rs2, rs1, rd, RISCV_SRLW))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (RTYPEW ((rs2, rs1, rd, RISCV_SRAW))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (SHIFTIWOP ((shamt, rs1, rd, RISCV_SLLIW))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (SHIFTIWOP ((shamt, rs1, rd, RISCV_SRLIW))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (SHIFTIWOP ((shamt, rs1, rd, RISCV_SRAIW))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (FENCE ((pred, succ))) = ( True )" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|" encdec_forwards_matches (FENCE_TSO ((pred, succ))) = ( True )" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|" encdec_forwards_matches (FENCEI (_)) = ( True )"
|" encdec_forwards_matches (ECALL (_)) = ( True )"
|" encdec_forwards_matches (MRET (_)) = ( True )"
|" encdec_forwards_matches (SRET (_)) = ( True )"
|" encdec_forwards_matches (EBREAK (_)) = ( True )"
|" encdec_forwards_matches (WFI (_)) = ( True )"
|" encdec_forwards_matches (SFENCE_VMA ((rs1, rs2))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word "
|" encdec_forwards_matches (LOADRES ((aq, rl, rs1, size1, rd))) = (
      if ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))) then True else False )" 
  for  size1  :: " word_width " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" encdec_forwards_matches (STORECON ((aq, rl, rs2, rs1, size1, rd))) = (
      if ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))) then True else False )" 
  for  size1  :: " word_width " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" encdec_forwards_matches (AMO ((op1, aq, rl, rs2, rs1, size1, rd))) = (
      if ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))) then True else False )" 
  for  size1  :: " word_width " 
  and  op1  :: " amoop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" encdec_forwards_matches (MUL ((rs2, rs1, rd, high, signed1, signed2))) = ( True )" 
  for  signed2  :: " bool " 
  and  signed1  :: " bool " 
  and  high  :: " bool " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (DIV ((rs2, rs1, rd, s))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" encdec_forwards_matches (REM ((rs2, rs1, rd, s))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" encdec_forwards_matches (MULW ((rs2, rs1, rd))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_forwards_matches (DIVW ((rs2, rs1, rd, s))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" encdec_forwards_matches (REMW ((rs2, rs1, rd, s))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" encdec_forwards_matches (CSR ((csr, rs1, rd, is_imm, op1))) = ( True )" 
  for  op1  :: " csrop " 
  and  is_imm  :: " bool " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  csr  :: "(12)Word.word "
|" encdec_forwards_matches (URET (_)) = ( True )"
|" encdec_forwards_matches (ILLEGAL (s)) = ( True )" 
  for  s  :: "(32)Word.word "
|" encdec_forwards_matches _ = ( False )"


\<comment> \<open>\<open>val encdec_backwards_matches : mword ty32 -> M bool\<close>\<close>

definition encdec_backwards_matches  :: "(32)Word.word \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " encdec_backwards_matches arg1 = (
   (let v__225 = arg1 in
   (let (mappingpatterns_00 ::  7 Word.word) = ((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) in
   and_boolM (return ((encdec_uop_backwards_matches mappingpatterns_00)))
     (if ((encdec_uop_backwards_matches mappingpatterns_00)) then
        encdec_uop_backwards mappingpatterns_00 \<bind> (\<lambda> op1 .  return True)
      else return False) \<bind> (\<lambda> (w__1 :: bool) . 
   if w__1 then
     (let (mappingpatterns_00 ::  7 Word.word) = ((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) in
     encdec_uop_backwards mappingpatterns_00 \<bind> (\<lambda> op1 .  return True))
   else if (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))) then
     return True
   else if ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B1,B1,B1]  ::  7 Word.word))))))) then
     return True
   else
     and_boolM
       ((let (mappingpatterns_10 ::  3 Word.word) =
         ((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
       and_boolM (return ((encdec_bop_backwards_matches mappingpatterns_10)))
         (if ((encdec_bop_backwards_matches mappingpatterns_10)) then
            encdec_bop_backwards mappingpatterns_10 \<bind> (\<lambda> op1 .  return True)
          else return False)))
       (return (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B0,B0,B0,B1,B1]  ::  7 Word.word))))) \<bind> (\<lambda> (w__4 :: bool) . 
     if w__4 then
       (let (mappingpatterns_10 ::  3 Word.word) =
         ((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
       encdec_bop_backwards mappingpatterns_10 \<bind> (\<lambda> op1 .  return True))
     else
       and_boolM
         ((let (mappingpatterns_20 ::  3 Word.word) =
           ((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
         and_boolM (return ((encdec_iop_backwards_matches mappingpatterns_20)))
           (if ((encdec_iop_backwards_matches mappingpatterns_20)) then
              encdec_iop_backwards mappingpatterns_20 \<bind> (\<lambda> op1 .  return True)
            else return False)))
         (return (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))) \<bind> (\<lambda> (w__7 :: bool) . 
       if w__7 then
         (let (mappingpatterns_20 ::  3 Word.word) =
           ((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
         encdec_iop_backwards mappingpatterns_20 \<bind> (\<lambda> op1 .  return True))
       else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__225 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
                   (((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((bit_to_bool ((access_vec_dec shamt (( 5 :: int)::ii))))) = False)))))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))))))))) then
         return True
       else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__225 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
                   (((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((bit_to_bool ((access_vec_dec shamt (( 5 :: int)::ii))))) = False)))))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))))))))) then
         return True
       else if (((((let (shamt ::  6 Word.word) = ((subrange_vec_dec v__225 (( 25 :: int)::ii) (( 20 :: int)::ii)  ::  6 Word.word)) in
                   (((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((((bit_to_bool ((access_vec_dec shamt (( 5 :: int)::ii))))) = False)))))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 26 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B0,B0,B1,B1]  ::  7 Word.word))))))))))))) then
         return True
       else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         return True
       else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         return True
       else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         return True
       else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         return True
       else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         return True
       else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         return True
       else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         return True
       else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         return True
       else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         return True
       else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))))) then
         return True
       else
         and_boolM
           ((let (mappingpatterns_40 ::  2 Word.word) =
             ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
           (let (mappingpatterns_30 ::  1 Word.word) =
             ((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
           and_boolM (return ((size_bits_backwards_matches mappingpatterns_40)))
             (if ((size_bits_backwards_matches mappingpatterns_40)) then
                size_bits_backwards mappingpatterns_40 \<bind> (\<lambda> size1 . 
                and_boolM (return ((bool_bits_backwards_matches mappingpatterns_30)))
                  (if ((bool_bits_backwards_matches mappingpatterns_30)) then
                     bool_bits_backwards mappingpatterns_30 \<bind> (\<lambda> is_unsigned . 
                     return (((((((word_width_bytes size1)) < (( 4 :: int)::ii))) \<or> (((((\<not> is_unsigned)) \<and> ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))))))))
                   else return False) \<bind> (\<lambda> (w__9 :: bool) . 
                return w__9))
              else return False))))
           (return (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B1]  ::  7 Word.word))))) \<bind> (\<lambda> (w__12 :: bool) . 
         if w__12 then
           (let (mappingpatterns_40 ::  2 Word.word) =
             ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
           (let (mappingpatterns_30 ::  1 Word.word) =
             ((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
           size_bits_backwards mappingpatterns_40 \<bind> (\<lambda> size1 . 
           bool_bits_backwards mappingpatterns_30 \<bind> (\<lambda> is_unsigned .  return True))))
         else
           and_boolM
             ((let (mappingpatterns_50 ::  2 Word.word) =
               ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
             and_boolM (return ((size_bits_backwards_matches mappingpatterns_50)))
               (if ((size_bits_backwards_matches mappingpatterns_50)) then
                  size_bits_backwards mappingpatterns_50 \<bind> (\<lambda> size1 . 
                  return ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))
                else return False)))
             (return ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B1,B1]  ::  7 Word.word)))))))) \<bind> (\<lambda> (w__15 ::
             bool) . 
           if w__15 then
             (let (mappingpatterns_50 ::  2 Word.word) =
               ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
             size_bits_backwards mappingpatterns_50 \<bind> (\<lambda> size1 .  return True))
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))) then
             return True
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             return True
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             return True
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             return True
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             return True
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             return True
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             return True
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             return True
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             return True
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             return True
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             return True
           else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B0,B0,B0,B0]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))))) then
             return True
           else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 19 :: int)::ii) (( 0 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1]
                             ::  20 Word.word))))))) then
             return True
           else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 28 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 19 :: int)::ii) (( 0 :: int)::ii)  ::  20 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1]
                             ::  20 Word.word))))))) then
             return True
           else if (((v__225 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,
                                     B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B1]
                         ::  32 Word.word)))) then
             return True
           else if (((v__225 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]
                         ::  32 Word.word)))) then
             return True
           else if (((v__225 = (vec_of_bits [B0,B0,B1,B1,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]
                         ::  32 Word.word)))) then
             return True
           else if (((v__225 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]
                         ::  32 Word.word)))) then
             return True
           else if (((v__225 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]
                         ::  32 Word.word)))) then
             return True
           else if (((v__225 = (vec_of_bits [B0,B0,B0,B1,B0,B0,B0,B0,B0,B1,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,
                                     B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]
                         ::  32 Word.word)))) then
             return True
           else if ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B1,B0,B0,B1]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 0 :: int)::ii)  ::  15 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B1,B1,B1,B0,B0,B1,B1]  ::  15 Word.word)))))))
           then
             return True
           else
             and_boolM
               ((let (mappingpatterns_80 ::  2 Word.word) =
                 ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
               (let (mappingpatterns_70 ::  1 Word.word) =
                 ((subrange_vec_dec v__225 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_60 ::  1 Word.word) =
                 ((subrange_vec_dec v__225 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
               and_boolM (return ((size_bits_backwards_matches mappingpatterns_80)))
                 (if ((size_bits_backwards_matches mappingpatterns_80)) then
                    size_bits_backwards mappingpatterns_80 \<bind> (\<lambda> size1 . 
                    and_boolM (return ((bool_bits_backwards_matches mappingpatterns_70)))
                      (if ((bool_bits_backwards_matches mappingpatterns_70)) then
                         bool_bits_backwards mappingpatterns_70 \<bind> (\<lambda> rl . 
                         and_boolM (return ((bool_bits_backwards_matches mappingpatterns_60)))
                           (if ((bool_bits_backwards_matches mappingpatterns_60)) then
                              bool_bits_backwards mappingpatterns_60 \<bind> (\<lambda> aq . 
                              return ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))
                            else return False) \<bind> (\<lambda> (w__17 :: bool) . 
                         return w__17))
                       else return False) \<bind> (\<lambda> (w__19 :: bool) . 
                    return w__19))
                  else return False)))))
               (return ((((((((regidx_to_regno
                                   ((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))) \<and> ((((((((regidx_to_regno
                                       ((subrange_vec_dec v__225 (( 24 :: int)::ii) (( 20 :: int)::ii)  ::  5 Word.word)))) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))))))))) \<bind> (\<lambda> (w__22 ::
               bool) . 
             if w__22 then
               (let (mappingpatterns_80 ::  2 Word.word) =
                 ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
               (let (mappingpatterns_70 ::  1 Word.word) =
                 ((subrange_vec_dec v__225 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
               (let (mappingpatterns_60 ::  1 Word.word) =
                 ((subrange_vec_dec v__225 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
               size_bits_backwards mappingpatterns_80 \<bind> (\<lambda> size1 . 
               bool_bits_backwards mappingpatterns_70 \<bind> (\<lambda> rl . 
               bool_bits_backwards mappingpatterns_60 \<bind> (\<lambda> aq .  return True))))))
             else
               and_boolM
                 ((let (mappingpatterns_90 ::  1 Word.word) =
                   ((subrange_vec_dec v__225 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
                 (let (mappingpatterns_110 ::  2 Word.word) =
                   ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                 (let (mappingpatterns_100 ::  1 Word.word) =
                   ((subrange_vec_dec v__225 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
                 and_boolM (return ((size_bits_backwards_matches mappingpatterns_110)))
                   (if ((size_bits_backwards_matches mappingpatterns_110)) then
                      size_bits_backwards mappingpatterns_110 \<bind> (\<lambda> size1 . 
                      and_boolM (return ((bool_bits_backwards_matches mappingpatterns_100)))
                        (if ((bool_bits_backwards_matches mappingpatterns_100)) then
                           bool_bits_backwards mappingpatterns_100 \<bind> (\<lambda> rl . 
                           and_boolM (return ((bool_bits_backwards_matches mappingpatterns_90)))
                             (if ((bool_bits_backwards_matches mappingpatterns_90)) then
                                bool_bits_backwards mappingpatterns_90 \<bind> (\<lambda> aq . 
                                return ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))
                              else return False) \<bind> (\<lambda> (w__24 :: bool) . 
                           return w__24))
                         else return False) \<bind> (\<lambda> (w__26 :: bool) . 
                      return w__26))
                    else return False)))))
                 (return ((((((((regidx_to_regno
                                     ((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)))) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B1]  ::  5 Word.word)))))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word))))))))))) \<bind> (\<lambda> (w__29 ::
                 bool) . 
               if w__29 then
                 (let (mappingpatterns_90 ::  1 Word.word) =
                   ((subrange_vec_dec v__225 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
                 (let (mappingpatterns_110 ::  2 Word.word) =
                   ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                 (let (mappingpatterns_100 ::  1 Word.word) =
                   ((subrange_vec_dec v__225 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
                 size_bits_backwards mappingpatterns_110 \<bind> (\<lambda> size1 . 
                 bool_bits_backwards mappingpatterns_100 \<bind> (\<lambda> rl . 
                 bool_bits_backwards mappingpatterns_90 \<bind> (\<lambda> aq .  return True))))))
               else
                 and_boolM
                   ((let (mappingpatterns_120 ::  5 Word.word) =
                     ((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                   (let (mappingpatterns_150 ::  2 Word.word) =
                     ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                   (let (mappingpatterns_140 ::  1 Word.word) =
                     ((subrange_vec_dec v__225 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
                   (let (mappingpatterns_130 ::  1 Word.word) =
                     ((subrange_vec_dec v__225 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
                   (let (mappingpatterns_120 ::  5 Word.word) =
                     ((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                   and_boolM (return ((size_bits_backwards_matches mappingpatterns_150)))
                     (if ((size_bits_backwards_matches mappingpatterns_150)) then
                        size_bits_backwards mappingpatterns_150 \<bind> (\<lambda> size1 . 
                        and_boolM (return ((bool_bits_backwards_matches mappingpatterns_140)))
                          (if ((bool_bits_backwards_matches mappingpatterns_140)) then
                             bool_bits_backwards mappingpatterns_140 \<bind> (\<lambda> rl . 
                             and_boolM (return ((bool_bits_backwards_matches mappingpatterns_130)))
                               (if ((bool_bits_backwards_matches mappingpatterns_130)) then
                                  bool_bits_backwards mappingpatterns_130 \<bind> (\<lambda> aq . 
                                  and_boolM
                                    (return ((encdec_amoop_backwards_matches mappingpatterns_120)))
                                    (if ((encdec_amoop_backwards_matches mappingpatterns_120)) then
                                       encdec_amoop_backwards mappingpatterns_120 \<bind> (\<lambda> op1 . 
                                       return ((((word_width_bytes size1)) \<le> (( 4 :: int)::ii))))
                                     else return False) \<bind> (\<lambda> (w__31 :: bool) . 
                                  return w__31))
                                else return False) \<bind> (\<lambda> (w__33 :: bool) . 
                             return w__33))
                           else return False) \<bind> (\<lambda> (w__35 :: bool) . 
                        return w__35))
                      else return False)))))))
                   (return ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B0,B1,B1,B1,B1]  ::  7 Word.word)))))))) \<bind> (\<lambda> (w__38 ::
                   bool) . 
                 if w__38 then
                   (let (mappingpatterns_120 ::  5 Word.word) =
                     ((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                   (let (mappingpatterns_150 ::  2 Word.word) =
                     ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                   (let (mappingpatterns_140 ::  1 Word.word) =
                     ((subrange_vec_dec v__225 (( 25 :: int)::ii) (( 25 :: int)::ii)  ::  1 Word.word)) in
                   (let (mappingpatterns_130 ::  1 Word.word) =
                     ((subrange_vec_dec v__225 (( 26 :: int)::ii) (( 26 :: int)::ii)  ::  1 Word.word)) in
                   (let (mappingpatterns_120 ::  5 Word.word) =
                     ((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 27 :: int)::ii)  ::  5 Word.word)) in
                   size_bits_backwards mappingpatterns_150 \<bind> (\<lambda> size1 . 
                   bool_bits_backwards mappingpatterns_140 \<bind> (\<lambda> rl . 
                   bool_bits_backwards mappingpatterns_130 \<bind> (\<lambda> aq . 
                   encdec_amoop_backwards mappingpatterns_120 \<bind> (\<lambda> op1 .  return True)))))))))
                 else
                   and_boolM
                     ((let (mappingpatterns_160 ::  3 Word.word) =
                       ((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                     and_boolM (return ((encdec_mul_op_backwards_matches mappingpatterns_160)))
                       (if ((encdec_mul_op_backwards_matches mappingpatterns_160)) then
                          encdec_mul_op_backwards mappingpatterns_160 \<bind> (\<lambda> varstup .  (let (high, signed1, signed2) = varstup in
                          return True))
                        else return False)))
                     (return ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word)))))))) \<bind> (\<lambda> (w__41 ::
                     bool) . 
                   if w__41 then
                     (let (mappingpatterns_160 ::  3 Word.word) =
                       ((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)  ::  3 Word.word)) in
                     encdec_mul_op_backwards mappingpatterns_160 \<bind> (\<lambda> varstup .  (let (high, signed1, signed2) = varstup in
                     return True)))
                   else
                     and_boolM
                       ((let (mappingpatterns_170 ::  1 Word.word) =
                         ((subrange_vec_dec v__225 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                       and_boolM (return ((bool_not_bits_backwards_matches mappingpatterns_170)))
                         (if ((bool_not_bits_backwards_matches mappingpatterns_170)) then
                            bool_not_bits_backwards mappingpatterns_170 \<bind> (\<lambda> s .  return True)
                          else return False)))
                       (return ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))))))))) \<bind> (\<lambda> (w__44 ::
                       bool) . 
                     if w__44 then
                       (let (mappingpatterns_170 ::  1 Word.word) =
                         ((subrange_vec_dec v__225 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                       bool_not_bits_backwards mappingpatterns_170 \<bind> (\<lambda> s .  return True))
                     else
                       and_boolM
                         ((let (mappingpatterns_180 ::  1 Word.word) =
                           ((subrange_vec_dec v__225 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                         and_boolM (return ((bool_not_bits_backwards_matches mappingpatterns_180)))
                           (if ((bool_not_bits_backwards_matches mappingpatterns_180)) then
                              bool_not_bits_backwards mappingpatterns_180 \<bind> (\<lambda> s .  return True)
                            else return False)))
                         (return ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 13 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))))))))) \<bind> (\<lambda> (w__47 ::
                         bool) . 
                       if w__47 then
                         (let (mappingpatterns_180 ::  1 Word.word) =
                           ((subrange_vec_dec v__225 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                         bool_not_bits_backwards mappingpatterns_180 \<bind> (\<lambda> s .  return True))
                       else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 12 :: int)::ii)
                                                  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word)))))))))))))
                       then
                         return True
                       else
                         and_boolM
                           ((let (mappingpatterns_190 ::  1 Word.word) =
                             ((subrange_vec_dec v__225 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                           and_boolM
                             (return ((bool_not_bits_backwards_matches mappingpatterns_190)))
                             (if ((bool_not_bits_backwards_matches mappingpatterns_190)) then
                                bool_not_bits_backwards mappingpatterns_190 \<bind> (\<lambda> s . 
                                return ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))
                              else return False)))
                           (return ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 13 :: int)::ii)
                                                  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))) \<bind> (\<lambda> (w__50 ::
                           bool) . 
                         if w__50 then
                           (let (mappingpatterns_190 ::  1 Word.word) =
                             ((subrange_vec_dec v__225 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                           bool_not_bits_backwards mappingpatterns_190 \<bind> (\<lambda> s .  return True))
                         else
                           and_boolM
                             ((let (mappingpatterns_200 ::  1 Word.word) =
                               ((subrange_vec_dec v__225 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                             and_boolM
                               (return ((bool_not_bits_backwards_matches mappingpatterns_200)))
                               (if ((bool_not_bits_backwards_matches mappingpatterns_200)) then
                                  bool_not_bits_backwards mappingpatterns_200 \<bind> (\<lambda> s . 
                                  return ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))
                                else return False)))
                             (return ((((((((subrange_vec_dec v__225 (( 31 :: int)::ii) (( 25 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B0,B1]  ::  7 Word.word)))) \<and> ((((((((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 13 :: int)::ii)
                                                    ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)
                                                    ::  7 Word.word)) = (vec_of_bits [B0,B1,B1,B1,B0,B1,B1]  ::  7 Word.word))))))))))) \<bind> (\<lambda> (w__53 ::
                             bool) . 
                           if w__53 then
                             (let (mappingpatterns_200 ::  1 Word.word) =
                               ((subrange_vec_dec v__225 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
                             bool_not_bits_backwards mappingpatterns_200 \<bind> (\<lambda> s .  return True))
                           else
                             and_boolM
                               ((let (mappingpatterns_220 ::  2 Word.word) =
                                 ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                               (let (mappingpatterns_210 ::  1 Word.word) =
                                 ((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
                               and_boolM
                                 (return ((encdec_csrop_backwards_matches mappingpatterns_220)))
                                 (if ((encdec_csrop_backwards_matches mappingpatterns_220)) then
                                    encdec_csrop_backwards mappingpatterns_220 \<bind> (\<lambda> op1 . 
                                    and_boolM
                                      (return ((bool_bits_backwards_matches mappingpatterns_210)))
                                      (if ((bool_bits_backwards_matches mappingpatterns_210)) then
                                         bool_bits_backwards mappingpatterns_210 \<bind> (\<lambda> is_imm . 
                                         return True)
                                       else return False) \<bind> (\<lambda> (w__55 :: bool) . 
                                    return w__55))
                                  else return False))))
                               (return (((((subrange_vec_dec v__225 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B1,B1,B1,B0,B0,B1,B1]  ::  7 Word.word))))) \<bind> (\<lambda> (w__58 ::
                               bool) . 
                             if w__58 then
                               (let (mappingpatterns_220 ::  2 Word.word) =
                                 ((subrange_vec_dec v__225 (( 13 :: int)::ii) (( 12 :: int)::ii)  ::  2 Word.word)) in
                               (let (mappingpatterns_210 ::  1 Word.word) =
                                 ((subrange_vec_dec v__225 (( 14 :: int)::ii) (( 14 :: int)::ii)  ::  1 Word.word)) in
                               encdec_csrop_backwards mappingpatterns_220 \<bind> (\<lambda> op1 . 
                               bool_bits_backwards mappingpatterns_210 \<bind> (\<lambda> is_imm . 
                               return True))))
                             else
                               return (if (((v__225 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0,B0,
                                                            B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,
                                                            B1,B1,B0,B0,B1,B1]
                                                ::  32 Word.word)))) then
                                         True
                                       else True))))))))))))))))))" 
  for  arg1  :: "(32)Word.word "


\<comment> \<open>\<open>val encdec_compressed_forwards : ast -> M (mword ty16)\<close>\<close>

fun encdec_compressed_forwards  :: " ast \<Rightarrow>((register_value),((16)Word.word),(exception))monad "  where 
     " encdec_compressed_forwards (C_NOP (_)) = (
      return ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                 ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                     ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                         ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                             (vec_of_bits [B0,B1]  ::  2 Word.word)
                            ::  7 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))"
|" encdec_compressed_forwards (C_ADDI4SPN ((rd, v__438))) = (
      if ((let (nz96 :: 4 bits) = ((subrange_vec_dec v__438 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
        (let (nz96 :: 4 bits) = ((subrange_vec_dec v__438 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
        (let (nz54 :: 2 bits) = ((subrange_vec_dec v__438 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
        (let (nz3 :: 1 bits) = ((subrange_vec_dec v__438 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
        (let (nz2 :: 1 bits) = ((subrange_vec_dec v__438 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        (((concat_vec nz96 ((concat_vec nz54 ((concat_vec nz3 nz2  ::  2 Word.word))  ::  4 Word.word))
             ::  8 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)))))))) then
        (let (nz96 :: 4 bits) = ((subrange_vec_dec v__438 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
        (let (nz96 :: 4 bits) = ((subrange_vec_dec v__438 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
        (let (nz54 :: 2 bits) = ((subrange_vec_dec v__438 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
        (let (nz3 :: 1 bits) = ((subrange_vec_dec v__438 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
        (let (nz2 :: 1 bits) = ((subrange_vec_dec v__438 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        return ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                   ((concat_vec nz54
                       ((concat_vec nz96
                           ((concat_vec nz2
                               ((concat_vec nz3
                                   ((concat_vec rd (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  5 Word.word))
                                  ::  6 Word.word))
                              ::  7 Word.word))
                          ::  11 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__438  :: "(8)Word.word " 
  and  rd  :: "(3)Word.word "
|" encdec_compressed_forwards (C_LW ((v__439, rs1, rd))) = (
      (let (ui6 :: 1 bits) = ((subrange_vec_dec v__439 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (ui6 :: 1 bits) = ((subrange_vec_dec v__439 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (ui53 :: 3 bits) = ((subrange_vec_dec v__439 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) in
      (let (ui2 :: 1 bits) = ((subrange_vec_dec v__439 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      return ((concat_vec (vec_of_bits [B0,B1,B0]  ::  3 Word.word)
                 ((concat_vec ui53
                     ((concat_vec rs1
                         ((concat_vec ui2
                             ((concat_vec ui6
                                 ((concat_vec rd (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  5 Word.word))
                                ::  6 Word.word))
                            ::  7 Word.word))
                        ::  10 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))))))" 
  for  v__439  :: "(5)Word.word " 
  and  rs1  :: "(3)Word.word " 
  and  rd  :: "(3)Word.word "
|" encdec_compressed_forwards (C_LD ((v__440, rs1, rd))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__440 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__440 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui53 :: 3 bits) = ((subrange_vec_dec v__440 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec (vec_of_bits [B0,B1,B1]  ::  3 Word.word)
                   ((concat_vec ui53
                       ((concat_vec rs1
                           ((concat_vec ui76
                               ((concat_vec rd (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  5 Word.word))
                              ::  7 Word.word))
                          ::  10 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__440  :: "(5)Word.word " 
  and  rs1  :: "(3)Word.word " 
  and  rd  :: "(3)Word.word "
|" encdec_compressed_forwards (C_SW ((v__441, rs1, rs2))) = (
      (let (ui6 :: 1 bits) = ((subrange_vec_dec v__441 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (ui6 :: 1 bits) = ((subrange_vec_dec v__441 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (ui53 :: 3 bits) = ((subrange_vec_dec v__441 (( 3 :: int)::ii) (( 1 :: int)::ii)  ::  3 Word.word)) in
      (let (ui2 :: 1 bits) = ((subrange_vec_dec v__441 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
      return ((concat_vec (vec_of_bits [B1,B1,B0]  ::  3 Word.word)
                 ((concat_vec ui53
                     ((concat_vec rs1
                         ((concat_vec ui2
                             ((concat_vec ui6
                                 ((concat_vec rs2 (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  5 Word.word))
                                ::  6 Word.word))
                            ::  7 Word.word))
                        ::  10 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))))))" 
  for  v__441  :: "(5)Word.word " 
  and  rs2  :: "(3)Word.word " 
  and  rs1  :: "(3)Word.word "
|" encdec_compressed_forwards (C_SD ((v__442, rs1, rs2))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__442 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__442 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (ui53 :: 3 bits) = ((subrange_vec_dec v__442 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec (vec_of_bits [B1,B1,B1]  ::  3 Word.word)
                   ((concat_vec ui53
                       ((concat_vec rs1
                           ((concat_vec ui76
                               ((concat_vec rs2 (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  5 Word.word))
                              ::  7 Word.word))
                          ::  10 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__442  :: "(5)Word.word " 
  and  rs2  :: "(3)Word.word " 
  and  rs1  :: "(3)Word.word "
|" encdec_compressed_forwards (C_ADDI ((v__443, rsd))) = (
      if ((let (nzi5 :: 1 bits) = ((subrange_vec_dec v__443 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__443 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__443 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        ((((((concat_vec nzi5 nzi40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg)))))))))) then
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__443 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__443 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__443 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                   ((concat_vec nzi5
                       ((concat_vec rsd
                           ((concat_vec nzi40 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsd  :: "(5)Word.word " 
  and  v__443  :: "(6)Word.word "
|" encdec_compressed_forwards (C_JAL (v__444)) = (
      if ((((( 32 :: int)::ii) = (( 32 :: int)::ii)))) then
        (let (i11 :: 1 bits) = ((subrange_vec_dec v__444 (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word)) in
        (let (i98 :: 2 bits) = ((subrange_vec_dec v__444 (( 8 :: int)::ii) (( 7 :: int)::ii)  ::  2 Word.word)) in
        (let (i7 :: 1 bits) = ((subrange_vec_dec v__444 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
        (let (i6 :: 1 bits) = ((subrange_vec_dec v__444 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (i5 :: 1 bits) = ((subrange_vec_dec v__444 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
        (let (i4 :: 1 bits) = ((subrange_vec_dec v__444 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) in
        (let (i31 :: 3 bits) = ((subrange_vec_dec v__444 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        (let (i11 :: 1 bits) = ((subrange_vec_dec v__444 (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word)) in
        (let (i10 :: 1 bits) = ((subrange_vec_dec v__444 (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word)) in
        return ((concat_vec (vec_of_bits [B0,B0,B1]  ::  3 Word.word)
                   ((concat_vec i11
                       ((concat_vec i4
                           ((concat_vec i98
                               ((concat_vec i10
                                   ((concat_vec i6
                                       ((concat_vec i7
                                           ((concat_vec i31
                                               ((concat_vec i5 (vec_of_bits [B0,B1]  ::  2 Word.word)
                                                  ::  3 Word.word))
                                              ::  6 Word.word))
                                          ::  7 Word.word))
                                      ::  8 Word.word))
                                  ::  9 Word.word))
                              ::  11 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__444  :: "(11)Word.word "
|" encdec_compressed_forwards (C_ADDIW ((v__445, rsd))) = (
      if ((((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))))
      then
        (let (imm5 :: 1 bits) = ((subrange_vec_dec v__445 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm5 :: 1 bits) = ((subrange_vec_dec v__445 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm40 :: 5 bits) = ((subrange_vec_dec v__445 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec (vec_of_bits [B0,B0,B1]  ::  3 Word.word)
                   ((concat_vec imm5
                       ((concat_vec rsd
                           ((concat_vec imm40 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__445  :: "(6)Word.word " 
  and  rsd  :: "(5)Word.word "
|" encdec_compressed_forwards (C_LI ((v__446, rd))) = (
      if (((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) then
        (let (imm5 :: 1 bits) = ((subrange_vec_dec v__446 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm5 :: 1 bits) = ((subrange_vec_dec v__446 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm40 :: 5 bits) = ((subrange_vec_dec v__446 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec (vec_of_bits [B0,B1,B0]  ::  3 Word.word)
                   ((concat_vec imm5
                       ((concat_vec rd
                           ((concat_vec imm40 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__446  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_compressed_forwards (C_ADDI16SP (v__447)) = (
      if ((let (nzi9 :: 1 bits) = ((subrange_vec_dec v__447 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi9 :: 1 bits) = ((subrange_vec_dec v__447 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__447 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__447 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__447 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__447 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        (((concat_vec nzi9
              ((concat_vec nzi87
                  ((concat_vec nzi6 ((concat_vec nzi5 nzi4  ::  2 Word.word))  ::  3 Word.word))
                 ::  5 Word.word))
             ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))))) then
        (let (nzi9 :: 1 bits) = ((subrange_vec_dec v__447 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi9 :: 1 bits) = ((subrange_vec_dec v__447 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__447 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__447 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__447 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__447 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        return ((concat_vec (vec_of_bits [B0,B1,B1]  ::  3 Word.word)
                   ((concat_vec nzi9
                       ((concat_vec (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)
                           ((concat_vec nzi4
                               ((concat_vec nzi6
                                   ((concat_vec nzi87
                                       ((concat_vec nzi5 (vec_of_bits [B0,B1]  ::  2 Word.word)
                                          ::  3 Word.word))
                                      ::  5 Word.word))
                                  ::  6 Word.word))
                              ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__447  :: "(6)Word.word "
|" encdec_compressed_forwards (C_LUI ((v__448, rd))) = (
      if ((let (imm17 :: 1 bits) = ((subrange_vec_dec v__448 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm17 :: 1 bits) = ((subrange_vec_dec v__448 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__448 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno sp))))) \<and> (((((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))))))) then
        (let (imm17 :: 1 bits) = ((subrange_vec_dec v__448 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm17 :: 1 bits) = ((subrange_vec_dec v__448 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__448 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec (vec_of_bits [B0,B1,B1]  ::  3 Word.word)
                   ((concat_vec imm17
                       ((concat_vec rd
                           ((concat_vec imm1612 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__448  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_compressed_forwards (C_SRLI ((v__449, rsd))) = (
      if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__449 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__449 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__449 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))) then
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__449 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__449 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__449 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                   ((concat_vec nzui5
                       ((concat_vec (vec_of_bits [B0,B0]  ::  2 Word.word)
                           ((concat_vec rsd
                               ((concat_vec nzui40 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  7 Word.word))
                              ::  10 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__449  :: "(6)Word.word " 
  and  rsd  :: "(3)Word.word "
|" encdec_compressed_forwards (C_SRAI ((v__450, rsd))) = (
      if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__450 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__450 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__450 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))) then
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__450 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__450 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__450 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                   ((concat_vec nzui5
                       ((concat_vec (vec_of_bits [B0,B1]  ::  2 Word.word)
                           ((concat_vec rsd
                               ((concat_vec nzui40 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  7 Word.word))
                              ::  10 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__450  :: "(6)Word.word " 
  and  rsd  :: "(3)Word.word "
|" encdec_compressed_forwards (C_ANDI ((v__451, rsd))) = (
      (let (i5 :: 1 bits) = ((subrange_vec_dec v__451 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
      (let (i5 :: 1 bits) = ((subrange_vec_dec v__451 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
      (let (i40 :: 5 bits) = ((subrange_vec_dec v__451 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
      return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                 ((concat_vec i5
                     ((concat_vec (vec_of_bits [B1,B0]  ::  2 Word.word)
                         ((concat_vec rsd
                             ((concat_vec i40 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))))))" 
  for  v__451  :: "(6)Word.word " 
  and  rsd  :: "(3)Word.word "
|" encdec_compressed_forwards (C_SUB ((rsd, rs2))) = (
      return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                 ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                     ((concat_vec (vec_of_bits [B1,B1]  ::  2 Word.word)
                         ((concat_vec rsd
                             ((concat_vec (vec_of_bits [B0,B0]  ::  2 Word.word)
                                 ((concat_vec rs2 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards (C_XOR ((rsd, rs2))) = (
      return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                 ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                     ((concat_vec (vec_of_bits [B1,B1]  ::  2 Word.word)
                         ((concat_vec rsd
                             ((concat_vec (vec_of_bits [B0,B1]  ::  2 Word.word)
                                 ((concat_vec rs2 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards (C_OR ((rsd, rs2))) = (
      return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                 ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                     ((concat_vec (vec_of_bits [B1,B1]  ::  2 Word.word)
                         ((concat_vec rsd
                             ((concat_vec (vec_of_bits [B1,B0]  ::  2 Word.word)
                                 ((concat_vec rs2 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards (C_AND ((rsd, rs2))) = (
      return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                 ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                     ((concat_vec (vec_of_bits [B1,B1]  ::  2 Word.word)
                         ((concat_vec rsd
                             ((concat_vec (vec_of_bits [B1,B1]  ::  2 Word.word)
                                 ((concat_vec rs2 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards (C_SUBW ((rsd, rs2))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                   ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
                       ((concat_vec (vec_of_bits [B1,B1]  ::  2 Word.word)
                           ((concat_vec rsd
                               ((concat_vec (vec_of_bits [B0,B0]  ::  2 Word.word)
                                   ((concat_vec rs2 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  5 Word.word))
                                  ::  7 Word.word))
                              ::  10 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards (C_ADDW ((rsd, rs2))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                   ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
                       ((concat_vec (vec_of_bits [B1,B1]  ::  2 Word.word)
                           ((concat_vec rsd
                               ((concat_vec (vec_of_bits [B0,B1]  ::  2 Word.word)
                                   ((concat_vec rs2 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  5 Word.word))
                                  ::  7 Word.word))
                              ::  10 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards (C_J (v__452)) = (
      (let (i11 :: 1 bits) = ((subrange_vec_dec v__452 (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word)) in
      (let (i98 :: 2 bits) = ((subrange_vec_dec v__452 (( 8 :: int)::ii) (( 7 :: int)::ii)  ::  2 Word.word)) in
      (let (i7 :: 1 bits) = ((subrange_vec_dec v__452 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
      (let (i6 :: 1 bits) = ((subrange_vec_dec v__452 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
      (let (i5 :: 1 bits) = ((subrange_vec_dec v__452 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (i4 :: 1 bits) = ((subrange_vec_dec v__452 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) in
      (let (i31 :: 3 bits) = ((subrange_vec_dec v__452 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
      (let (i11 :: 1 bits) = ((subrange_vec_dec v__452 (( 10 :: int)::ii) (( 10 :: int)::ii)  ::  1 Word.word)) in
      (let (i10 :: 1 bits) = ((subrange_vec_dec v__452 (( 9 :: int)::ii) (( 9 :: int)::ii)  ::  1 Word.word)) in
      return ((concat_vec (vec_of_bits [B1,B0,B1]  ::  3 Word.word)
                 ((concat_vec i11
                     ((concat_vec i4
                         ((concat_vec i98
                             ((concat_vec i10
                                 ((concat_vec i6
                                     ((concat_vec i7
                                         ((concat_vec i31
                                             ((concat_vec i5 (vec_of_bits [B0,B1]  ::  2 Word.word)
                                                ::  3 Word.word))
                                            ::  6 Word.word))
                                        ::  7 Word.word))
                                    ::  8 Word.word))
                                ::  9 Word.word))
                            ::  11 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))))))))))))" 
  for  v__452  :: "(11)Word.word "
|" encdec_compressed_forwards (C_BEQZ ((v__453, rs))) = (
      (let (i8 :: 1 bits) = ((subrange_vec_dec v__453 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
      (let (i8 :: 1 bits) = ((subrange_vec_dec v__453 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
      (let (i76 :: 2 bits) = ((subrange_vec_dec v__453 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
      (let (i5 :: 1 bits) = ((subrange_vec_dec v__453 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (i43 :: 2 bits) = ((subrange_vec_dec v__453 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
      (let (i21 :: 2 bits) = ((subrange_vec_dec v__453 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
      return ((concat_vec (vec_of_bits [B1,B1,B0]  ::  3 Word.word)
                 ((concat_vec i8
                     ((concat_vec i43
                         ((concat_vec rs
                             ((concat_vec i76
                                 ((concat_vec i21
                                     ((concat_vec i5 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  3 Word.word))
                                    ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))))))))" 
  for  rs  :: "(3)Word.word " 
  and  v__453  :: "(8)Word.word "
|" encdec_compressed_forwards (C_BNEZ ((v__454, rs))) = (
      (let (i8 :: 1 bits) = ((subrange_vec_dec v__454 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
      (let (i8 :: 1 bits) = ((subrange_vec_dec v__454 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
      (let (i76 :: 2 bits) = ((subrange_vec_dec v__454 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
      (let (i5 :: 1 bits) = ((subrange_vec_dec v__454 (( 4 :: int)::ii) (( 4 :: int)::ii)  ::  1 Word.word)) in
      (let (i43 :: 2 bits) = ((subrange_vec_dec v__454 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
      (let (i21 :: 2 bits) = ((subrange_vec_dec v__454 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
      return ((concat_vec (vec_of_bits [B1,B1,B1]  ::  3 Word.word)
                 ((concat_vec i8
                     ((concat_vec i43
                         ((concat_vec rs
                             ((concat_vec i76
                                 ((concat_vec i21
                                     ((concat_vec i5 (vec_of_bits [B0,B1]  ::  2 Word.word)  ::  3 Word.word))
                                    ::  5 Word.word))
                                ::  7 Word.word))
                            ::  10 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))))))))" 
  for  v__454  :: "(8)Word.word " 
  and  rs  :: "(3)Word.word "
|" encdec_compressed_forwards (C_SLLI ((v__455, rsd))) = (
      if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__455 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__455 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__455 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        ((((((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ((bool_to_bits False  ::  1 Word.word))))))))))))))))
      then
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__455 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__455 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__455 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        return ((concat_vec (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                   ((concat_vec nzui5
                       ((concat_vec rsd
                           ((concat_vec nzui40 (vec_of_bits [B1,B0]  ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__455  :: "(6)Word.word " 
  and  rsd  :: "(5)Word.word "
|" encdec_compressed_forwards (C_LWSP ((v__456, rd))) = (
      if (((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) then
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__456 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
        (let (ui76 :: 2 bits) = ((subrange_vec_dec v__456 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
        (let (ui5 :: 1 bits) = ((subrange_vec_dec v__456 (( 3 :: int)::ii) (( 3 :: int)::ii)  ::  1 Word.word)) in
        (let (ui42 :: 3 bits) = ((subrange_vec_dec v__456 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec (vec_of_bits [B0,B1,B0]  ::  3 Word.word)
                   ((concat_vec ui5
                       ((concat_vec rd
                           ((concat_vec ui42
                               ((concat_vec ui76 (vec_of_bits [B1,B0]  ::  2 Word.word)  ::  4 Word.word))
                              ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__456  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_compressed_forwards (C_LDSP ((v__457, rd))) = (
      if ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))))
      then
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__457 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__457 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui5 :: 1 bits) = ((subrange_vec_dec v__457 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
        (let (ui43 :: 2 bits) = ((subrange_vec_dec v__457 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) in
        return ((concat_vec (vec_of_bits [B0,B1,B1]  ::  3 Word.word)
                   ((concat_vec ui5
                       ((concat_vec rd
                           ((concat_vec ui43
                               ((concat_vec ui86 (vec_of_bits [B1,B0]  ::  2 Word.word)  ::  5 Word.word))
                              ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__457  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_compressed_forwards (C_SWSP ((v__458, rs2))) = (
      (let (ui76 :: 2 bits) = ((subrange_vec_dec v__458 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
      (let (ui76 :: 2 bits) = ((subrange_vec_dec v__458 (( 5 :: int)::ii) (( 4 :: int)::ii)  ::  2 Word.word)) in
      (let (ui52 :: 4 bits) = ((subrange_vec_dec v__458 (( 3 :: int)::ii) (( 0 :: int)::ii)  ::  4 Word.word)) in
      return ((concat_vec (vec_of_bits [B1,B1,B0]  ::  3 Word.word)
                 ((concat_vec ui52
                     ((concat_vec ui76
                         ((concat_vec rs2 (vec_of_bits [B1,B0]  ::  2 Word.word)  ::  7 Word.word))
                        ::  9 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word))))))" 
  for  v__458  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|" encdec_compressed_forwards (C_SDSP ((v__459, rs2))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__459 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui86 :: 3 bits) = ((subrange_vec_dec v__459 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
        (let (ui53 :: 3 bits) = ((subrange_vec_dec v__459 (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) in
        return ((concat_vec (vec_of_bits [B1,B1,B1]  ::  3 Word.word)
                   ((concat_vec ui53
                       ((concat_vec ui86
                           ((concat_vec rs2 (vec_of_bits [B1,B0]  ::  2 Word.word)  ::  7 Word.word))
                          ::  10 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word)))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  v__459  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|" encdec_compressed_forwards (C_JR (rs1)) = (
      if (((((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) then
        return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                   ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                               (vec_of_bits [B1,B0]  ::  2 Word.word)
                              ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs1  :: "(5)Word.word "
|" encdec_compressed_forwards (C_JALR (rs1)) = (
      if (((((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) then
        return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                   ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
                       ((concat_vec rs1
                           ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                               (vec_of_bits [B1,B0]  ::  2 Word.word)
                              ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs1  :: "(5)Word.word "
|" encdec_compressed_forwards (C_MV ((rd, rs2))) = (
      if ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg)))))))) then
        return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                   ((concat_vec (vec_of_bits [B0]  ::  1 Word.word)
                       ((concat_vec rd
                           ((concat_vec rs2 (vec_of_bits [B1,B0]  ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_compressed_forwards (C_EBREAK (_)) = (
      return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                 ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
                     ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                         ((concat_vec (vec_of_bits [B0,B0,B0,B0,B0]  ::  5 Word.word)
                             (vec_of_bits [B1,B0]  ::  2 Word.word)
                            ::  7 Word.word))
                        ::  12 Word.word))
                    ::  13 Word.word))
                ::  16 Word.word)))"
|" encdec_compressed_forwards (C_ADD ((rsd, rs2))) = (
      if ((((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg)))))))) then
        return ((concat_vec (vec_of_bits [B1,B0,B0]  ::  3 Word.word)
                   ((concat_vec (vec_of_bits [B1]  ::  1 Word.word)
                       ((concat_vec rsd
                           ((concat_vec rs2 (vec_of_bits [B1,B0]  ::  2 Word.word)  ::  7 Word.word))
                          ::  12 Word.word))
                      ::  13 Word.word))
                  ::  16 Word.word))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsd  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word "
|" encdec_compressed_forwards (C_ILLEGAL (s)) = ( return s )" 
  for  s  :: "(16)Word.word "
|" encdec_compressed_forwards _ = ( assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )"


\<comment> \<open>\<open>val encdec_compressed_backwards : mword ty16 -> ast\<close>\<close>

definition encdec_compressed_backwards  :: "(16)Word.word \<Rightarrow> ast "  where 
     " encdec_compressed_backwards arg1 = (
   (let v__460 = arg1 in
   if (((v__460 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  16 Word.word))))
   then
     C_NOP () 
   else if (((((let (nz96 :: 4 bits) = ((subrange_vec_dec v__460 (( 10 :: int)::ii) (( 7 :: int)::ii)  ::  4 Word.word)) in
               (let (nz54 :: 2 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 11 :: int)::ii)  ::  2 Word.word)) in
               (let (nz3 :: 1 bits) = ((subrange_vec_dec v__460 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
               (let (nz2 :: 1 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
               (((concat_vec nz96
                     ((concat_vec nz54 ((concat_vec nz3 nz2  ::  2 Word.word))  ::  4 Word.word))
                    ::  8 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     (let (rd :: cregidx) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (nz96 :: 4 bits) = ((subrange_vec_dec v__460 (( 10 :: int)::ii) (( 7 :: int)::ii)  ::  4 Word.word)) in
     (let (nz54 :: 2 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 11 :: int)::ii)  ::  2 Word.word)) in
     (let (nz3 :: 1 bits) = ((subrange_vec_dec v__460 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (nz2 :: 1 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     C_ADDI4SPN (rd,
                 (concat_vec nz96
                    ((concat_vec nz54 ((concat_vec nz3 nz2  ::  2 Word.word))  ::  4 Word.word))
                   ::  8 Word.word)))))))
   else if ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     (let (ui6 :: 1 bits) = ((subrange_vec_dec v__460 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (ui2 :: 1 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (rs1 :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rd :: cregidx) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     C_LW ((concat_vec ui6 ((concat_vec ui53 ui2  ::  4 Word.word))  ::  5 Word.word), rs1, rd))))))
   else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (rs1 :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rd :: cregidx) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     C_LD ((concat_vec ui76 ui53  ::  5 Word.word), rs1, rd)))))
   else if ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     (let (ui6 :: 1 bits) = ((subrange_vec_dec v__460 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (ui2 :: 1 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (rs1 :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     C_SW ((concat_vec ui6 ((concat_vec ui53 ui2  ::  4 Word.word))  ::  5 Word.word), rs1, rs2))))))
   else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: 3 bits) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (rs1 :: 3 bits) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     C_SD ((concat_vec ui76 ui53  ::  5 Word.word), rs1, rs2)))))
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((concat_vec nzi5 nzi40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg)))))))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     C_ADDI ((concat_vec nzi5 nzi40  ::  6 Word.word), rsd))))
   else if (((((((( 32 :: int)::ii) = (( 32 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (i98 :: 2 bits) = ((subrange_vec_dec v__460 (( 10 :: int)::ii) (( 9 :: int)::ii)  ::  2 Word.word)) in
     (let (i7 :: 1 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (i6 :: 1 bits) = ((subrange_vec_dec v__460 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__460 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     (let (i4 :: 1 bits) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word)) in
     (let (i31 :: 3 bits) = ((subrange_vec_dec v__460 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
     (let (i11 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i10 :: 1 bits) = ((subrange_vec_dec v__460 (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word)) in
     C_JAL ((concat_vec i11
               ((concat_vec i10
                   ((concat_vec i98
                       ((concat_vec i7
                           ((concat_vec i6
                               ((concat_vec i5 ((concat_vec i4 i31  ::  4 Word.word))  ::  5 Word.word))
                              ::  6 Word.word))
                          ::  7 Word.word))
                      ::  9 Word.word))
                  ::  10 Word.word))
              ::  11 Word.word))))))))))
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii))))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (imm40 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     C_ADDIW ((concat_vec imm5 imm40  ::  6 Word.word), rsd))))
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (imm40 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     C_LI ((concat_vec imm5 imm40  ::  6 Word.word), rd))))
   else if (((((let (nzi9 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
               (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__460 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__460 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
               (((concat_vec nzi9
                     ((concat_vec nzi87
                         ((concat_vec nzi6 ((concat_vec nzi5 nzi4  ::  2 Word.word))  ::  3 Word.word))
                        ::  5 Word.word))
                    ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> ((((((((regidx_to_regno ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)))) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))))))))) then
     (let (nzi9 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
     (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__460 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__460 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     C_ADDI16SP ((concat_vec nzi9
                    ((concat_vec nzi87
                        ((concat_vec nzi6 ((concat_vec nzi5 nzi4  ::  2 Word.word))  ::  3 Word.word))
                       ::  5 Word.word))
                   ::  6 Word.word)))))))
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (imm17 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno sp))))) \<and> (((((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (imm17 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     C_LUI ((concat_vec imm17 imm1612  ::  6 Word.word), rd))))
   else if (((((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     C_SRLI ((concat_vec nzui5 nzui40  ::  6 Word.word), rsd))))
   else if (((((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     C_SRAI ((concat_vec nzui5 nzui40  ::  6 Word.word), rsd))))
   else if ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i40 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     C_ANDI ((concat_vec i5 i40  ::  6 Word.word), rsd))))
   else if ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     C_SUB (rsd, rs2)))
   else if ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     C_XOR (rsd, rs2)))
   else if ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     C_OR (rsd, rs2)))
   else if ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     C_AND (rsd, rs2)))
   else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     C_SUBW (rsd, rs2)))
   else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))))))))) then
     (let (rsd :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: cregidx) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     C_ADDW (rsd, rs2)))
   else if ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (i98 :: 2 bits) = ((subrange_vec_dec v__460 (( 10 :: int)::ii) (( 9 :: int)::ii)  ::  2 Word.word)) in
     (let (i7 :: 1 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
     (let (i6 :: 1 bits) = ((subrange_vec_dec v__460 (( 7 :: int)::ii) (( 7 :: int)::ii)  ::  1 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__460 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     (let (i4 :: 1 bits) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 11 :: int)::ii)  ::  1 Word.word)) in
     (let (i31 :: 3 bits) = ((subrange_vec_dec v__460 (( 5 :: int)::ii) (( 3 :: int)::ii)  ::  3 Word.word)) in
     (let (i11 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i10 :: 1 bits) = ((subrange_vec_dec v__460 (( 8 :: int)::ii) (( 8 :: int)::ii)  ::  1 Word.word)) in
     C_J ((concat_vec i11
             ((concat_vec i10
                 ((concat_vec i98
                     ((concat_vec i7
                         ((concat_vec i6
                             ((concat_vec i5 ((concat_vec i4 i31  ::  4 Word.word))  ::  5 Word.word))
                            ::  6 Word.word))
                        ::  7 Word.word))
                    ::  9 Word.word))
                ::  10 Word.word))
            ::  11 Word.word))))))))))
   else if ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (rs :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (i8 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i76 :: 2 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__460 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     (let (i43 :: 2 bits) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (i21 :: 2 bits) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
     C_BEQZ ((concat_vec i8
                ((concat_vec i76 ((concat_vec i5 ((concat_vec i43 i21  ::  4 Word.word))  ::  5 Word.word))
                   ::  7 Word.word))
               ::  8 Word.word),
             rs)))))))
   else if ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     (let (rs :: cregidx) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (i8 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (i76 :: 2 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (i5 :: 1 bits) = ((subrange_vec_dec v__460 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
     (let (i43 :: 2 bits) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) in
     (let (i21 :: 2 bits) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
     C_BNEZ ((concat_vec i8
                ((concat_vec i76 ((concat_vec i5 ((concat_vec i43 i21  ::  4 Word.word))  ::  5 Word.word))
                   ::  7 Word.word))
               ::  8 Word.word),
             rs)))))))
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ((bool_to_bits False  ::  1 Word.word)))))))))))))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     (let (rsd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     C_SLLI ((concat_vec nzui5 nzui40  ::  6 Word.word), rsd))))
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__460 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
     (let (ui5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (ui42 :: 3 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 4 :: int)::ii)  ::  3 Word.word)) in
     (let (rd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     C_LWSP ((concat_vec ui76 ((concat_vec ui5 ui42  ::  4 Word.word))  ::  6 Word.word), rd)))))
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii))))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     (let (ui86 :: 3 bits) = ((subrange_vec_dec v__460 (( 4 :: int)::ii) (( 2 :: int)::ii)  ::  3 Word.word)) in
     (let (ui5 :: 1 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
     (let (ui43 :: 2 bits) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) in
     (let (rd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     C_LDSP ((concat_vec ui86 ((concat_vec ui5 ui43  ::  3 Word.word))  ::  6 Word.word), rd)))))
   else if ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     (let (ui76 :: 2 bits) = ((subrange_vec_dec v__460 (( 8 :: int)::ii) (( 7 :: int)::ii)  ::  2 Word.word)) in
     (let (ui52 :: 4 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 9 :: int)::ii)  ::  4 Word.word)) in
     (let (rs2 :: regidx) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     C_SWSP ((concat_vec ui76 ui52  ::  6 Word.word), rs2))))
   else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     (let (ui86 :: 3 bits) = ((subrange_vec_dec v__460 (( 9 :: int)::ii) (( 7 :: int)::ii)  ::  3 Word.word)) in
     (let (ui53 :: 3 bits) = ((subrange_vec_dec v__460 (( 12 :: int)::ii) (( 10 :: int)::ii)  ::  3 Word.word)) in
     (let (rs2 :: regidx) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     C_SDSP ((concat_vec ui86 ui53  ::  6 Word.word), rs2))))
   else if (((((let (rs1 :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0]  ::  7 Word.word)))))))))) then
     (let (rs1 :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     C_JR rs1)
   else if (((((let (rs1 :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0]  ::  7 Word.word)))))))))) then
     (let (rs1 :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     C_JALR rs1)
   else if (((((let (rs2 :: regidx) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (let (rd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg))))))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     (let (rs2 :: regidx) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     (let (rd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     C_MV (rd, rs2)))
   else if (((v__460 = (vec_of_bits [B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  16 Word.word)))) then
     C_EBREAK () 
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (rs2 :: regidx) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg))))))))) \<and> ((((((((subrange_vec_dec v__460 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__460 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     (let (rsd :: regidx) = ((subrange_vec_dec v__460 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
     (let (rs2 :: regidx) = ((subrange_vec_dec v__460 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
     C_ADD (rsd, rs2)))
   else C_ILLEGAL v__460))" 
  for  arg1  :: "(16)Word.word "


\<comment> \<open>\<open>val encdec_compressed_forwards_matches : ast -> bool\<close>\<close>

fun encdec_compressed_forwards_matches  :: " ast \<Rightarrow> bool "  where 
     " encdec_compressed_forwards_matches (C_NOP (_)) = ( True )"
|" encdec_compressed_forwards_matches (C_ADDI4SPN ((rd, v__596))) = (
      if ((let (nz96 :: 4 bits) = ((subrange_vec_dec v__596 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
        (let (nz96 :: 4 bits) = ((subrange_vec_dec v__596 (( 7 :: int)::ii) (( 4 :: int)::ii)  ::  4 Word.word)) in
        (let (nz54 :: 2 bits) = ((subrange_vec_dec v__596 (( 3 :: int)::ii) (( 2 :: int)::ii)  ::  2 Word.word)) in
        (let (nz3 :: 1 bits) = ((subrange_vec_dec v__596 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
        (let (nz2 :: 1 bits) = ((subrange_vec_dec v__596 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        (((concat_vec nz96 ((concat_vec nz54 ((concat_vec nz3 nz2  ::  2 Word.word))  ::  4 Word.word))
             ::  8 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)))))))) then
        True
      else False )" 
  for  v__596  :: "(8)Word.word " 
  and  rd  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_LW ((v__597, rs1, rd))) = ( True )" 
  for  v__597  :: "(5)Word.word " 
  and  rs1  :: "(3)Word.word " 
  and  rd  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_LD ((v__598, rs1, rd))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  v__598  :: "(5)Word.word " 
  and  rs1  :: "(3)Word.word " 
  and  rd  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_SW ((v__599, rs1, rs2))) = ( True )" 
  for  v__599  :: "(5)Word.word " 
  and  rs2  :: "(3)Word.word " 
  and  rs1  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_SD ((v__600, rs1, rs2))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  v__600  :: "(5)Word.word " 
  and  rs2  :: "(3)Word.word " 
  and  rs1  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_ADDI ((v__601, rsd))) = (
      if ((let (nzi5 :: 1 bits) = ((subrange_vec_dec v__601 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__601 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__601 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        ((((((concat_vec nzi5 nzi40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg)))))))))) then
        True
      else False )" 
  for  v__601  :: "(6)Word.word " 
  and  rsd  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_JAL (v__602)) = ( if ((((( 32 :: int)::ii) = (( 32 :: int)::ii)))) then True else False )" 
  for  v__602  :: "(11)Word.word "
|" encdec_compressed_forwards_matches (C_ADDIW ((v__603, rsd))) = (
      if ((((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))))
      then
        True
      else False )" 
  for  v__603  :: "(6)Word.word " 
  and  rsd  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_LI ((v__604, rd))) = (
      if (((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) then True else False )" 
  for  v__604  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_ADDI16SP (v__605)) = (
      if ((let (nzi9 :: 1 bits) = ((subrange_vec_dec v__605 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi9 :: 1 bits) = ((subrange_vec_dec v__605 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__605 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
        (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__605 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__605 (( 1 :: int)::ii) (( 1 :: int)::ii)  ::  1 Word.word)) in
        (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__605 (( 0 :: int)::ii) (( 0 :: int)::ii)  ::  1 Word.word)) in
        (((concat_vec nzi9
              ((concat_vec nzi87
                  ((concat_vec nzi6 ((concat_vec nzi5 nzi4  ::  2 Word.word))  ::  3 Word.word))
                 ::  5 Word.word))
             ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))))) then
        True
      else False )" 
  for  v__605  :: "(6)Word.word "
|" encdec_compressed_forwards_matches (C_LUI ((v__606, rd))) = (
      if ((let (imm17 :: 1 bits) = ((subrange_vec_dec v__606 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm17 :: 1 bits) = ((subrange_vec_dec v__606 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__606 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno sp))))) \<and> (((((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))))))) then
        True
      else False )" 
  for  v__606  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_SRLI ((v__607, rsd))) = (
      if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__607 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__607 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__607 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))) then
        True
      else False )" 
  for  v__607  :: "(6)Word.word " 
  and  rsd  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_SRAI ((v__608, rsd))) = (
      if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__608 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__608 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__608 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))) then
        True
      else False )" 
  for  v__608  :: "(6)Word.word " 
  and  rsd  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_ANDI ((v__609, rsd))) = ( True )" 
  for  v__609  :: "(6)Word.word " 
  and  rsd  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_SUB ((rsd, rs2))) = ( True )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_XOR ((rsd, rs2))) = ( True )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_OR ((rsd, rs2))) = ( True )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_AND ((rsd, rs2))) = ( True )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_SUBW ((rsd, rs2))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_ADDW ((rsd, rs2))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_J (v__610)) = ( True )" 
  for  v__610  :: "(11)Word.word "
|" encdec_compressed_forwards_matches (C_BEQZ ((v__611, rs))) = ( True )" 
  for  v__611  :: "(8)Word.word " 
  and  rs  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_BNEZ ((v__612, rs))) = ( True )" 
  for  v__612  :: "(8)Word.word " 
  and  rs  :: "(3)Word.word "
|" encdec_compressed_forwards_matches (C_SLLI ((v__613, rsd))) = (
      if ((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__613 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__613 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
        (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__613 (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word)) in
        ((((((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ((bool_to_bits False  ::  1 Word.word))))))))))))))))
      then
        True
      else False )" 
  for  v__613  :: "(6)Word.word " 
  and  rsd  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_LWSP ((v__614, rd))) = (
      if (((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) then True else False )" 
  for  v__614  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_LDSP ((v__615, rd))) = (
      if ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))))
      then
        True
      else False )" 
  for  v__615  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_SWSP ((v__616, rs2))) = ( True )" 
  for  v__616  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_SDSP ((v__617, rs2))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  v__617  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_JR (rs1)) = ( if (((((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) then True else False )" 
  for  rs1  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_JALR (rs1)) = (
      if (((((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) then True else False )" 
  for  rs1  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_MV ((rd, rs2))) = (
      if ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg)))))))) then
        True
      else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_EBREAK (_)) = ( True )"
|" encdec_compressed_forwards_matches (C_ADD ((rsd, rs2))) = (
      if ((((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg)))))))) then
        True
      else False )" 
  for  rsd  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word "
|" encdec_compressed_forwards_matches (C_ILLEGAL (s)) = ( True )" 
  for  s  :: "(16)Word.word "
|" encdec_compressed_forwards_matches _ = ( False )"


\<comment> \<open>\<open>val encdec_compressed_backwards_matches : mword ty16 -> bool\<close>\<close>

definition encdec_compressed_backwards_matches  :: "(16)Word.word \<Rightarrow> bool "  where 
     " encdec_compressed_backwards_matches arg1 = (
   (let v__618 = arg1 in
   if (((v__618 = (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1]  ::  16 Word.word))))
   then
     True
   else if (((((let (nz96 :: 4 bits) = ((subrange_vec_dec v__618 (( 10 :: int)::ii) (( 7 :: int)::ii)  ::  4 Word.word)) in
               (let (nz54 :: 2 bits) = ((subrange_vec_dec v__618 (( 12 :: int)::ii) (( 11 :: int)::ii)  ::  2 Word.word)) in
               (let (nz3 :: 1 bits) = ((subrange_vec_dec v__618 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
               (let (nz2 :: 1 bits) = ((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
               (((concat_vec nz96
                     ((concat_vec nz54 ((concat_vec nz3 nz2  ::  2 Word.word))  ::  4 Word.word))
                    ::  8 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     True
   else if ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     True
   else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     True
   else if ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
     True
   else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))))))))) then
     True
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__618 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi40 :: 5 bits) = ((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((concat_vec nzi5 nzi40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg)))))))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     True
   else if (((((((( 32 :: int)::ii) = (( 32 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     True
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii))))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     True
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     True
   else if (((((let (nzi9 :: 1 bits) = ((subrange_vec_dec v__618 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi87 :: 2 bits) = ((subrange_vec_dec v__618 (( 4 :: int)::ii) (( 3 :: int)::ii)  ::  2 Word.word)) in
               (let (nzi6 :: 1 bits) = ((subrange_vec_dec v__618 (( 5 :: int)::ii) (( 5 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi5 :: 1 bits) = ((subrange_vec_dec v__618 (( 2 :: int)::ii) (( 2 :: int)::ii)  ::  1 Word.word)) in
               (let (nzi4 :: 1 bits) = ((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 6 :: int)::ii)  ::  1 Word.word)) in
               (((concat_vec nzi9
                     ((concat_vec nzi87
                         ((concat_vec nzi6 ((concat_vec nzi5 nzi4  ::  2 Word.word))  ::  3 Word.word))
                        ::  5 Word.word))
                    ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> ((((((((regidx_to_regno ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)))) = ((regidx_to_regno (vec_of_bits [B0,B0,B0,B1,B0]  ::  5 Word.word)))))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))))))))) then
     True
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (imm17 :: 1 bits) = ((subrange_vec_dec v__618 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (imm1612 :: 5 bits) = ((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno sp))))) \<and> (((((concat_vec imm17 imm1612  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     True
   else if (((((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__618 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))))))))) then
     True
   else if (((((let (nzui5 :: 1 bits) = ((subrange_vec_dec v__618 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))))))))) then
     True
   else if ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B0]  ::  3 Word.word)))) \<and> ((((((((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 10 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     True
   else if ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     True
   else if ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     True
   else if ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     True
   else if ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B0,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))))))))) then
     True
   else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))))))))) then
     True
   else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 10 :: int)::ii)  ::  6 Word.word)) = (vec_of_bits [B1,B0,B0,B1,B1,B1]  ::  6 Word.word)))) \<and> ((((((((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 5 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))))))))) then
     True
   else if ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B0,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     True
   else if ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     True
   else if ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
     True
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (nzui5 :: 1 bits) = ((subrange_vec_dec v__618 (( 12 :: int)::ii) (( 12 :: int)::ii)  ::  1 Word.word)) in
               (let (nzui40 :: 5 bits) = ((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((concat_vec nzui5 nzui40  ::  6 Word.word)) \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> ((((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<or> (((nzui5 = ((bool_to_bits False  ::  1 Word.word)))))))))))))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     True
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     True
   else if (((((let (rd :: regidx) = ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii))))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     True
   else if ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B0]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
     True
   else if (((((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 13 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B1,B1,B1]  ::  3 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     True
   else if (((((let (rs1 :: regidx) = ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0]  ::  7 Word.word)))))))))) then
     True
   else if (((((let (rs1 :: regidx) = ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 0 :: int)::ii)  ::  7 Word.word)) = (vec_of_bits [B0,B0,B0,B0,B0,B1,B0]  ::  7 Word.word)))))))))) then
     True
   else if (((((let (rs2 :: regidx) = ((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               (let (rd :: regidx) = ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg))))))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B0]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     True
   else if (((v__618 = (vec_of_bits [B1,B0,B0,B1,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B1,B0]  ::  16 Word.word)))) then
     True
   else if (((((let (rsd :: regidx) = ((subrange_vec_dec v__618 (( 11 :: int)::ii) (( 7 :: int)::ii)  ::  5 Word.word)) in
               (let (rs2 :: regidx) = ((subrange_vec_dec v__618 (( 6 :: int)::ii) (( 2 :: int)::ii)  ::  5 Word.word)) in
               ((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg))))))))) \<and> ((((((((subrange_vec_dec v__618 (( 15 :: int)::ii) (( 12 :: int)::ii)  ::  4 Word.word)) = (vec_of_bits [B1,B0,B0,B1]  ::  4 Word.word)))) \<and> (((((subrange_vec_dec v__618 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))))))))) then
     True
   else True))" 
  for  arg1  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_WFI : unit -> M Retired\<close>\<close>

definition execute_WFI  :: " unit \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_WFI _ = (
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (case  w__0 of
     Machine => platform_wfi ()  \<then> return RETIRE_SUCCESS
   | Supervisor =>
      read_reg mstatus_ref \<bind> (\<lambda> (w__1 :: Mstatus) . 
      if (((((get_Mstatus_TW w__1  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))) then
        handle_illegal ()  \<then> return RETIRE_FAIL
      else platform_wfi ()  \<then> return RETIRE_SUCCESS)
   | User => handle_illegal ()  \<then> return RETIRE_FAIL
   )))"


\<comment> \<open>\<open>val execute_UTYPE : mword ty20 -> mword ty5 -> uop -> M Retired\<close>\<close>

definition execute_UTYPE  :: "(20)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> uop \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_UTYPE imm rd op1 = (
   (let (off :: xlenbits) =
     ((EXTS (( 32 :: int)::ii)
        ((concat_vec imm (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0,B0]  ::  12 Word.word)
           ::  32 Word.word))
       ::  32 Word.word)) in
   (case  op1 of
     RISCV_LUI => return off
   | RISCV_AUIPC =>
      (get_arch_pc ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
      return ((add_vec w__0 off  ::  32 Word.word)))
   ) \<bind> (\<lambda> (ret :: xlenbits) . 
   wX ((regidx_to_regno rd)) ret \<then> return RETIRE_SUCCESS)))" 
  for  imm  :: "(20)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " uop "


\<comment> \<open>\<open>val execute_URET : unit -> M Retired\<close>\<close>

definition execute_URET  :: " unit \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_URET _ = (
   haveUsrMode ()  \<bind> (\<lambda> (w__0 :: bool) . 
   (if ((\<not> w__0)) then handle_illegal () 
    else
      read_reg cur_privilege_ref \<bind> (\<lambda> (w__1 :: Privilege) . 
      (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
      (exception_handler w__1 (CTL_URET () ) w__2  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 ::  32 Word.word) . 
      set_next_pc w__3)))) \<then>
   return RETIRE_FAIL))"


\<comment> \<open>\<open>val execute_STORECON : bool -> bool -> mword ty5 -> mword ty5 -> word_width -> mword ty5 -> M Retired\<close>\<close>

definition execute_STORECON  :: " bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_STORECON aq rl rs2 rs1 width rd = (
   speculate_conditional_success ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if (((w__0 = False))) then
     wX ((regidx_to_regno rd)) ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)) \<then>
     return RETIRE_SUCCESS
   else
     haveAtomics ()  \<bind> (\<lambda> (w__1 :: bool) . 
     if w__1 then
       ext_data_get_addr rs1 ((zeros_implicit (( 32 :: int)::ii)  ::  32 Word.word)) Write width \<bind> (\<lambda> (w__2 :: unit
         Ext_DataAddr_Check) . 
       (case  w__2 of
         Ext_DataAddr_Error (e) =>
          (let (_ :: unit) = (ext_handle_data_check_error e) in
          return RETIRE_FAIL)
       | Ext_DataAddr_OK (vaddr) =>
          (let (aligned :: bool) =
            ((case  width of
              BYTE => True
            | HALF =>
               (((cast_unit_vec0 ((access_vec_dec vaddr (( 0 :: int)::ii)))  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word))
            | WORD =>
               (((subrange_vec_dec vaddr (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))
            | DOUBLE =>
               (((subrange_vec_dec vaddr (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))
            )) in
          if ((\<not> aligned)) then handle_mem_exception vaddr E_SAMO_Addr_Align \<then> return RETIRE_FAIL
          else if (((((match_reservation vaddr)) = False))) then
            wX ((regidx_to_regno rd)) ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)) \<then>
            ((let (_ :: unit) = (cancel_reservation () ) in
            return RETIRE_SUCCESS))
          else
            (translateAddr vaddr Write  :: ( (( 32 Word.word), ExceptionType)TR_Result) M) \<bind> (\<lambda> (w__3 :: (( 32 Word.word), ExceptionType)
              TR_Result) . 
            (case  w__3 of
              TR_Failure (e) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
            | TR_Address (addr) =>
               (case  (width, (( 32 :: int)::ii)) of
                 (WORD, _) => mem_write_ea addr (( 4 :: int)::ii) aq rl True
               | _ => internal_error (''STORECON expected word or double'')
               ) \<bind> (\<lambda> (eares :: unit MemoryOpResult) . 
               (case  eares of
                 MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
               | MemValue (_) =>
                  (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs2_val . 
                  (case  (width, (( 32 :: int)::ii)) of
                    (WORD, _) =>
                     mem_write_value addr (( 4 :: int)::ii)
                       ((subrange_vec_dec rs2_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) aq rl True
                  | _ => internal_error (''STORECON expected word or double'')
                  ) \<bind> (\<lambda> (res :: bool MemoryOpResult) . 
                  (case  res of
                    MemValue (True) =>
                     wX ((regidx_to_regno rd))
                       ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  32 Word.word)) \<then>
                     ((let (_ :: unit) = (cancel_reservation () ) in
                     return RETIRE_SUCCESS))
                  | MemValue (False) =>
                     wX ((regidx_to_regno rd))
                       ((EXTZ (( 32 :: int)::ii) (vec_of_bits [B1]  ::  1 Word.word)  ::  32 Word.word)) \<then>
                     ((let (_ :: unit) = (cancel_reservation () ) in
                     return RETIRE_SUCCESS))
                  | MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
                  )))
               ))
            )))
       ))
     else handle_illegal ()  \<then> return RETIRE_FAIL)))" 
  for  aq  :: " bool " 
  and  rl  :: " bool " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  width  :: " word_width " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_STORE : mword ty12 -> mword ty5 -> mword ty5 -> word_width -> bool -> bool -> M Retired\<close>\<close>

definition execute_STORE  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_STORE imm rs2 rs1 width aq rl = (
   (let (offset :: xlenbits) = ((EXTS (( 32 :: int)::ii) imm  ::  32 Word.word)) in
   ext_data_get_addr rs1 offset Write width \<bind> (\<lambda> (w__0 :: unit Ext_DataAddr_Check) . 
   (case  w__0 of
     Ext_DataAddr_Error (e) =>
      (let (_ :: unit) = (ext_handle_data_check_error e) in
      return RETIRE_FAIL)
   | Ext_DataAddr_OK (vaddr) =>
      if ((check_misaligned vaddr width)) then
        handle_mem_exception vaddr E_SAMO_Addr_Align \<then> return RETIRE_FAIL
      else
        (translateAddr vaddr Write  :: ( (( 32 Word.word), ExceptionType)TR_Result) M) \<bind> (\<lambda> (w__1 :: (( 32 Word.word), ExceptionType)
          TR_Result) . 
        (case  w__1 of
          TR_Failure (e) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
        | TR_Address (addr) =>
           (case  width of
             BYTE => mem_write_ea addr (( 1 :: int)::ii) aq rl False
           | HALF => mem_write_ea addr (( 2 :: int)::ii) aq rl False
           | WORD => mem_write_ea addr (( 4 :: int)::ii) aq rl False
           | DOUBLE => mem_write_ea addr (( 8 :: int)::ii) aq rl False
           ) \<bind> (\<lambda> (eares :: unit MemoryOpResult) . 
           (case  eares of
             MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
           | MemValue (_) =>
              (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs2_val . 
              (case  (width, (( 32 :: int)::ii)) of
                (BYTE, _) =>
                 mem_write_value addr (( 1 :: int)::ii) ((subrange_vec_dec rs2_val (( 7 :: int)::ii) (( 0 :: int)::ii)  ::  8 Word.word))
                   aq rl False
              | (HALF, _) =>
                 mem_write_value addr (( 2 :: int)::ii)
                   ((subrange_vec_dec rs2_val (( 15 :: int)::ii) (( 0 :: int)::ii)  ::  16 Word.word)) aq rl False
              | (WORD, _) =>
                 mem_write_value addr (( 4 :: int)::ii)
                   ((subrange_vec_dec rs2_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) aq rl False
              ) \<bind> (\<lambda> (res :: bool MemoryOpResult) . 
              (case  res of
                MemValue (True) => return RETIRE_SUCCESS
              | MemValue (False) => internal_error (''store got false from mem_write_value'')
              | MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
              )))
           ))
        ))
   ))))" 
  for  imm  :: "(12)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  width  :: " word_width " 
  and  aq  :: " bool " 
  and  rl  :: " bool "


\<comment> \<open>\<open>val execute_SRET : unit -> M Retired\<close>\<close>

definition execute_SRET  :: " unit \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_SRET _ = (
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (case  w__0 of
     User => handle_illegal () 
   | Supervisor =>
      or_boolM (haveSupMode ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1))))
        (read_reg mstatus_ref \<bind> (\<lambda> (w__2 :: Mstatus) . 
         return (((((get_Mstatus_TSR w__2  ::  1 Word.word)) = ((bool_to_bits True  ::  1 Word.word))))))) \<bind> (\<lambda> (w__3 ::
        bool) . 
      if w__3 then handle_illegal () 
      else
        read_reg cur_privilege_ref \<bind> (\<lambda> (w__4 :: Privilege) . 
        (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__5 ::  32 Word.word) . 
        (exception_handler w__4 (CTL_SRET () ) w__5  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__6 ::  32 Word.word) . 
        set_next_pc w__6))))
   | Machine =>
      haveSupMode ()  \<bind> (\<lambda> (w__7 :: bool) . 
      if ((\<not> w__7)) then handle_illegal () 
      else
        read_reg cur_privilege_ref \<bind> (\<lambda> (w__8 :: Privilege) . 
        (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 ::  32 Word.word) . 
        (exception_handler w__8 (CTL_SRET () ) w__9  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 ::  32 Word.word) . 
        set_next_pc w__10))))
   ) \<then>
   return RETIRE_FAIL))"


\<comment> \<open>\<open>val execute_SHIFTW : mword ty5 -> mword ty5 -> mword ty5 -> sop -> M Retired\<close>\<close>

definition execute_SHIFTW  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> sop \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_SHIFTW shamt rs1 rd op1 = (
   (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   (let rs1_val = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (let (result :: 32 bits) =
     ((case  op1 of
       RISCV_SLLI => (shift_bits_left rs1_val shamt  ::  32 Word.word)
     | RISCV_SRLI => (shift_bits_right rs1_val shamt  ::  32 Word.word)
     | RISCV_SRAI => (shift_right_arith32 rs1_val shamt  ::  32 Word.word)
     )) in
   wX ((regidx_to_regno rd)) ((EXTS (( 32 :: int)::ii) result  ::  32 Word.word)) \<then> return RETIRE_SUCCESS))))" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " sop "


\<comment> \<open>\<open>val execute_SHIFTIWOP : mword ty5 -> mword ty5 -> mword ty5 -> sopw -> M Retired\<close>\<close>

definition execute_SHIFTIWOP  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> sopw \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_SHIFTIWOP shamt rs1 rd op1 = (
   (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (let (result :: 32 bits) =
     ((case  op1 of
       RISCV_SLLIW =>
        (shift_bits_left ((subrange_vec_dec rs1_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) shamt
          ::  32 Word.word)
     | RISCV_SRLIW =>
        (shift_bits_right ((subrange_vec_dec rs1_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) shamt
          ::  32 Word.word)
     | RISCV_SRAIW =>
        (shift_right_arith32 ((subrange_vec_dec rs1_val (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) shamt
          ::  32 Word.word)
     )) in
   wX ((regidx_to_regno rd)) ((EXTS (( 32 :: int)::ii) result  ::  32 Word.word)) \<then> return RETIRE_SUCCESS)))" 
  for  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " sopw "


\<comment> \<open>\<open>val execute_SHIFTIOP : mword ty6 -> mword ty5 -> mword ty5 -> sop -> M Retired\<close>\<close>

definition execute_SHIFTIOP  :: "(6)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> sop \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_SHIFTIOP shamt rs1 rd op1 = (
   (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (let (result :: xlenbits) =
     ((case  op1 of
       RISCV_SLLI =>
        (shift_bits_left rs1_val ((subrange_vec_dec shamt (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))  ::  32 Word.word)
     | RISCV_SRLI =>
        (shift_bits_right rs1_val ((subrange_vec_dec shamt (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     | RISCV_SRAI =>
        (shift_right_arith32 rs1_val ((subrange_vec_dec shamt (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     )) in
   wX ((regidx_to_regno rd)) result \<then> return RETIRE_SUCCESS)))" 
  for  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " sop "


\<comment> \<open>\<open>val execute_SFENCE_VMA : mword ty5 -> mword ty5 -> M Retired\<close>\<close>

definition execute_SFENCE_VMA  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_SFENCE_VMA rs1 rs2 = (
   (if (((((regidx_to_regno rs1)) = (( 0 :: int)::ii)))) then return None
    else
      (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
      return (Some w__0))) \<bind> (\<lambda> (addr ::  xlenbits option) . 
   (if (((((regidx_to_regno rs2)) = (( 0 :: int)::ii)))) then return None
    else
      (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
      return (Some w__1))) \<bind> (\<lambda> (asid ::  xlenbits option) . 
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__2 :: Privilege) . 
   (case  w__2 of
     User => handle_illegal ()  \<then> return RETIRE_FAIL
   | Supervisor =>
      read_reg mstatus_ref \<bind> (\<lambda> (w__3 :: Mstatus) . 
      read_reg mstatus_ref \<bind> (\<lambda> (w__4 :: Mstatus) . 
      (let p__1 =
        (architecture ((get_mstatus_SXL w__3  ::  2 Word.word)), (get_Mstatus_TVM w__4  ::  1 Word.word)) in
      (case  p__1 of
        (Some (g__0), v_0) =>
         if (((v_0 = ((bool_to_bits True  ::  1 Word.word))))) then
           handle_illegal ()  \<then> return RETIRE_FAIL
         else if (((v_0 = ((bool_to_bits False  ::  1 Word.word))))) then
           flush_TLB asid addr \<then> return RETIRE_SUCCESS
         else
           (case  (Some g__0, v_0) of
             (_, _) => internal_error (''unimplemented sfence architecture'')
           )
      | (_, _) => internal_error (''unimplemented sfence architecture'')
      ))))
   | Machine => flush_TLB asid addr \<then> return RETIRE_SUCCESS
   )))))" 
  for  rs1  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_RTYPEW : mword ty5 -> mword ty5 -> mword ty5 -> ropw -> M Retired\<close>\<close>

definition execute_RTYPEW  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> ropw \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_RTYPEW rs2 rs1 rd op1 = (
   (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   (let rs1_val = ((subrange_vec_dec w__0 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
   (let rs2_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
   (let (result :: 32 bits) =
     ((case  op1 of
       RISCV_ADDW => (add_vec rs1_val rs2_val  ::  32 Word.word)
     | RISCV_SUBW => (sub_vec rs1_val rs2_val  ::  32 Word.word)
     | RISCV_SLLW =>
        (shift_bits_left rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     | RISCV_SRLW =>
        (shift_bits_right rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     | RISCV_SRAW =>
        (shift_right_arith32 rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     )) in
   wX ((regidx_to_regno rd)) ((EXTS (( 32 :: int)::ii) result  ::  32 Word.word)) \<then> return RETIRE_SUCCESS))))))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " ropw "


\<comment> \<open>\<open>val execute_RTYPE : mword ty5 -> mword ty5 -> mword ty5 -> rop -> M Retired\<close>\<close>

definition execute_RTYPE  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> rop \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_RTYPE rs2 rs1 rd op1 = (
   (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs2_val . 
   (let (result :: xlenbits) =
     ((case  op1 of
       RISCV_ADD => (add_vec rs1_val rs2_val  ::  32 Word.word)
     | RISCV_SLT =>
        (EXTZ (( 32 :: int)::ii) ((bool_to_bits ((zopz0zI_s rs1_val rs2_val))  ::  1 Word.word))  ::  32 Word.word)
     | RISCV_SLTU =>
        (EXTZ (( 32 :: int)::ii) ((bool_to_bits ((zopz0zI_u rs1_val rs2_val))  ::  1 Word.word))  ::  32 Word.word)
     | RISCV_AND => (and_vec rs1_val rs2_val  ::  32 Word.word)
     | RISCV_OR => (or_vec rs1_val rs2_val  ::  32 Word.word)
     | RISCV_XOR => (xor_vec rs1_val rs2_val  ::  32 Word.word)
     | RISCV_SLL =>
        (shift_bits_left rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     | RISCV_SRL =>
        (shift_bits_right rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     | RISCV_SUB => (sub_vec rs1_val rs2_val  ::  32 Word.word)
     | RISCV_SRA =>
        (shift_right_arith32 rs1_val ((subrange_vec_dec rs2_val (( 4 :: int)::ii) (( 0 :: int)::ii)  ::  5 Word.word))
          ::  32 Word.word)
     )) in
   wX ((regidx_to_regno rd)) result \<then> return RETIRE_SUCCESS))))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " rop "


\<comment> \<open>\<open>val execute_RISCV_JALR : mword ty12 -> mword ty5 -> mword ty5 -> M Retired\<close>\<close>

definition execute_RISCV_JALR  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_RISCV_JALR imm rs1 rd = (
   (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   (let (t :: xlenbits) = ((add_vec w__0 ((EXTS (( 32 :: int)::ii) imm  ::  32 Word.word))  ::  32 Word.word)) in
   (case  ((ext_control_check_addr t)) of
     Ext_ControlAddr_Error (e) =>
      (let (_ :: unit) = (ext_handle_control_check_error e) in
      return RETIRE_FAIL)
   | Ext_ControlAddr_OK (addr) =>
      (let target = ((update_vec_dec addr (( 0 :: int)::ii) B0  ::  32 Word.word)) in
      and_boolM (return ((bit_to_bool ((access_vec_dec target (( 1 :: int)::ii))))))
        (haveRVC ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))) \<bind> (\<lambda> (w__2 :: bool) . 
      if w__2 then handle_mem_exception target E_Fetch_Addr_Align \<then> return RETIRE_FAIL
      else
        (get_next_pc ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 ::  32 Word.word) . 
        (wX ((regidx_to_regno rd)) w__3 \<then> set_next_pc target) \<then> return RETIRE_SUCCESS)))
   ))))" 
  for  imm  :: "(12)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_RISCV_JAL : mword ty21 -> mword ty5 -> M Retired\<close>\<close>

definition execute_RISCV_JAL  :: "(21)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_RISCV_JAL imm rd = (
   (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   (let (t :: xlenbits) = ((add_vec w__0 ((EXTS (( 32 :: int)::ii) imm  ::  32 Word.word))  ::  32 Word.word)) in
   (case  ((ext_control_check_pc t)) of
     Ext_ControlAddr_Error (e) =>
      (let (_ :: unit) = (ext_handle_control_check_error e) in
      return RETIRE_FAIL)
   | Ext_ControlAddr_OK (target) =>
      and_boolM (return ((bit_to_bool ((access_vec_dec target (( 1 :: int)::ii))))))
        (haveRVC ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))) \<bind> (\<lambda> (w__2 :: bool) . 
      if w__2 then handle_mem_exception target E_Fetch_Addr_Align \<then> return RETIRE_FAIL
      else
        (get_next_pc ()   :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 ::  32 Word.word) . 
        (wX ((regidx_to_regno rd)) w__3 \<then> set_next_pc target) \<then> return RETIRE_SUCCESS))
   ))))" 
  for  imm  :: "(21)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_REMW : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M Retired\<close>\<close>

definition execute_REMW  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_REMW rs2 rs1 rd s = (
   haveMulDiv ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
     (let rs1_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
     (let rs2_val = ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
     (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
     (let (r :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then rs1_int else hardware_mod rs1_int rs2_int) in
     wX ((regidx_to_regno rd)) ((EXTS (( 32 :: int)::ii) ((to_bits (( 32 :: int)::ii) r  ::  32 Word.word))  ::  32 Word.word)) \<then>
     return RETIRE_SUCCESS)))))))
   else handle_illegal ()  \<then> return RETIRE_FAIL))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "


\<comment> \<open>\<open>val execute_REM : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M Retired\<close>\<close>

definition execute_REM  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_REM rs2 rs1 rd s = (
   haveMulDiv ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs1_val . 
     (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs2_val . 
     (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
     (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
     (let (r :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then rs1_int else hardware_mod rs1_int rs2_int) in
     wX ((regidx_to_regno rd)) ((to_bits (( 32 :: int)::ii) r  ::  32 Word.word)) \<then> return RETIRE_SUCCESS)))))
   else handle_illegal ()  \<then> return RETIRE_FAIL))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "


\<comment> \<open>\<open>val execute_MULW : mword ty5 -> mword ty5 -> mword ty5 -> M Retired\<close>\<close>

definition execute_MULW  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_MULW rs2 rs1 rd = (
   haveMulDiv ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
     (let rs1_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
     (let rs2_val = ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (let (rs1_int :: ii) = (Word.sint rs1_val) in
     (let (rs2_int :: ii) = (Word.sint rs2_val) in
     (let result32 =
       ((subrange_vec_dec ((to_bits (( 64 :: int)::ii) ((rs1_int * rs2_int))  ::  64 Word.word)) (( 31 :: int)::ii)
          (( 0 :: int)::ii)
         ::  32 Word.word)) in
     (let (result :: xlenbits) = ((EXTS (( 32 :: int)::ii) result32  ::  32 Word.word)) in
     wX ((regidx_to_regno rd)) result \<then> return RETIRE_SUCCESS))))))))
   else handle_illegal ()  \<then> return RETIRE_FAIL))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_MUL : mword ty5 -> mword ty5 -> mword ty5 -> bool -> bool -> bool -> M Retired\<close>\<close>

definition execute_MUL  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_MUL rs2 rs1 rd high signed1 signed2 = (
   haveMulDiv ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs1_val . 
     (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs2_val . 
     (let (rs1_int :: ii) = (if signed1 then Word.sint rs1_val else Word.uint rs1_val) in
     (let (rs2_int :: ii) = (if signed2 then Word.sint rs2_val else Word.uint rs2_val) in
     (let result_wide =
       ((to_bits (((( 2 :: int)::ii) * (( 32 :: int)::ii))) ((rs1_int * rs2_int))  ::  64 Word.word)) in
     (let result =
       (if high then
         (subrange_vec_dec result_wide (((((( 2 :: int)::ii) * (( 32 :: int)::ii))) - (( 1 :: int)::ii)))
            (( 32 :: int)::ii)
           ::  32 Word.word)
       else (subrange_vec_dec result_wide (((( 32 :: int)::ii) - (( 1 :: int)::ii))) (( 0 :: int)::ii)  ::  32 Word.word)) in
     wX ((regidx_to_regno rd)) result \<then> return RETIRE_SUCCESS))))))
   else handle_illegal ()  \<then> return RETIRE_FAIL))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  high  :: " bool " 
  and  signed1  :: " bool " 
  and  signed2  :: " bool "


\<comment> \<open>\<open>val execute_MRET : unit -> M Retired\<close>\<close>

definition execute_MRET  :: " unit \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_MRET _ = (
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (if (((((privLevel_to_bits w__0  ::  2 Word.word)) = ((privLevel_to_bits Machine  ::  2 Word.word)))))
    then
      read_reg cur_privilege_ref \<bind> (\<lambda> (w__1 :: Privilege) . 
      (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
      (exception_handler w__1 (CTL_MRET () ) w__2  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 ::  32 Word.word) . 
      set_next_pc w__3)))
    else handle_illegal () ) \<then>
   return RETIRE_FAIL))"


\<comment> \<open>\<open>val execute_LOADRES : bool -> bool -> mword ty5 -> word_width -> mword ty5 -> M Retired\<close>\<close>

definition execute_LOADRES  :: " bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_LOADRES aq rl rs1 width rd = (
   haveAtomics ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     ext_data_get_addr rs1 ((zeros_implicit (( 32 :: int)::ii)  ::  32 Word.word)) Read width \<bind> (\<lambda> (w__1 :: unit
       Ext_DataAddr_Check) . 
     (case  w__1 of
       Ext_DataAddr_Error (e) =>
        (let (_ :: unit) = (ext_handle_data_check_error e) in
        return RETIRE_FAIL)
     | Ext_DataAddr_OK (vaddr) =>
        (let (aligned :: bool) =
          ((case  width of
            BYTE => True
          | HALF =>
             (((cast_unit_vec0 ((access_vec_dec vaddr (( 0 :: int)::ii)))  ::  1 Word.word)) = (vec_of_bits [B0]  ::  1 Word.word))
          | WORD =>
             (((subrange_vec_dec vaddr (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))
          | DOUBLE =>
             (((subrange_vec_dec vaddr (( 2 :: int)::ii) (( 0 :: int)::ii)  ::  3 Word.word)) = (vec_of_bits [B0,B0,B0]  ::  3 Word.word))
          )) in
        if ((\<not> aligned)) then handle_mem_exception vaddr E_Load_Addr_Align \<then> return RETIRE_FAIL
        else
          (translateAddr vaddr Read  :: ( (( 32 Word.word), ExceptionType)TR_Result) M) \<bind> (\<lambda> (w__2 :: (( 32 Word.word), ExceptionType)
            TR_Result) . 
          (case  w__2 of
            TR_Failure (e) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
          | TR_Address (addr) =>
             (case  (width, (( 32 :: int)::ii)) of
               (WORD, _) =>
                (mem_read Read addr (( 4 :: int)::ii) aq rl True  :: ( ( 32 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__3 :: ( 32 Word.word)
                  MemoryOpResult) . 
                process_loadres rd vaddr w__3 False)
             | _ => internal_error (''LOADRES expected WORD or DOUBLE'')
             )
          )))
     ))
   else handle_illegal ()  \<then> return RETIRE_FAIL))" 
  for  aq  :: " bool " 
  and  rl  :: " bool " 
  and  rs1  :: "(5)Word.word " 
  and  width  :: " word_width " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_LOAD : mword ty12 -> mword ty5 -> mword ty5 -> bool -> word_width -> bool -> bool -> M Retired\<close>\<close>

definition execute_LOAD  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> word_width \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_LOAD imm rs1 rd is_unsigned width aq rl = (
   (let (offset :: xlenbits) = ((EXTS (( 32 :: int)::ii) imm  ::  32 Word.word)) in
   ext_data_get_addr rs1 offset Read width \<bind> (\<lambda> (w__0 :: unit Ext_DataAddr_Check) . 
   (case  w__0 of
     Ext_DataAddr_Error (e) =>
      (let (_ :: unit) = (ext_handle_data_check_error e) in
      return RETIRE_FAIL)
   | Ext_DataAddr_OK (vaddr) =>
      if ((check_misaligned vaddr width)) then
        handle_mem_exception vaddr E_Load_Addr_Align \<then> return RETIRE_FAIL
      else
        (translateAddr vaddr Read  :: ( (( 32 Word.word), ExceptionType)TR_Result) M) \<bind> (\<lambda> (w__1 :: (( 32 Word.word), ExceptionType)
          TR_Result) . 
        (case  w__1 of
          TR_Failure (e) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
        | TR_Address (addr) =>
           (case  (width, (( 32 :: int)::ii)) of
             (BYTE, _) =>
              (mem_read Read addr (( 1 :: int)::ii) aq rl False  :: ( ( 8 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__2 :: ( 8 Word.word)
                MemoryOpResult) . 
              process_load rd vaddr w__2 is_unsigned)
           | (HALF, _) =>
              (mem_read Read addr (( 2 :: int)::ii) aq rl False  :: ( ( 16 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__4 :: ( 16 Word.word)
                MemoryOpResult) . 
              process_load rd vaddr w__4 is_unsigned)
           | (WORD, _) =>
              (mem_read Read addr (( 4 :: int)::ii) aq rl False  :: ( ( 32 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__6 :: ( 32 Word.word)
                MemoryOpResult) . 
              process_load rd vaddr w__6 is_unsigned)
           )
        ))
   ))))" 
  for  imm  :: "(12)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  is_unsigned  :: " bool " 
  and  width  :: " word_width " 
  and  aq  :: " bool " 
  and  rl  :: " bool "


\<comment> \<open>\<open>val execute_ITYPE : mword ty12 -> mword ty5 -> mword ty5 -> iop -> M Retired\<close>\<close>

definition execute_ITYPE  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> iop \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_ITYPE imm rs1 rd op1 = (
   (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (let (immext :: xlenbits) = ((EXTS (( 32 :: int)::ii) imm  ::  32 Word.word)) in
   (let (result :: xlenbits) =
     ((case  op1 of
       RISCV_ADDI => (add_vec rs1_val immext  ::  32 Word.word)
     | RISCV_SLTI =>
        (EXTZ (( 32 :: int)::ii) ((bool_to_bits ((zopz0zI_s rs1_val immext))  ::  1 Word.word))  ::  32 Word.word)
     | RISCV_SLTIU =>
        (EXTZ (( 32 :: int)::ii) ((bool_to_bits ((zopz0zI_u rs1_val immext))  ::  1 Word.word))  ::  32 Word.word)
     | RISCV_ANDI => (and_vec rs1_val immext  ::  32 Word.word)
     | RISCV_ORI => (or_vec rs1_val immext  ::  32 Word.word)
     | RISCV_XORI => (xor_vec rs1_val immext  ::  32 Word.word)
     )) in
   wX ((regidx_to_regno rd)) result \<then> return RETIRE_SUCCESS))))" 
  for  imm  :: "(12)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  op1  :: " iop "


\<comment> \<open>\<open>val execute_ILLEGAL : mword ty32 -> M Retired\<close>\<close>

definition execute_ILLEGAL  :: "(32)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_ILLEGAL s = ( handle_illegal ()  \<then> return RETIRE_FAIL )" 
  for  s  :: "(32)Word.word "


\<comment> \<open>\<open>val execute_FENCE_TSO : mword ty4 -> mword ty4 -> M Retired\<close>\<close>

definition execute_FENCE_TSO  :: "(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_FENCE_TSO pred succ = (
   (case  (pred, succ) of
     (v__794, v__795) =>
      if ((((((((subrange_vec_dec v__794 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__795 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
        barrier Barrier_RISCV_tso
      else
        return (if ((((((((subrange_vec_dec v__794 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__795 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
                  () 
                else
                  (let (_ :: unit) = (print_endline (''FIXME: unsupported fence'')) in
                  () ))
   ) \<then>
   return RETIRE_SUCCESS )" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_FENCEI : unit -> Retired\<close>\<close>

definition execute_FENCEI  :: " unit \<Rightarrow> Retired "  where 
     " execute_FENCEI _ = ( RETIRE_SUCCESS )"


\<comment> \<open>\<open>val execute_FENCE : mword ty4 -> mword ty4 -> M Retired\<close>\<close>

definition execute_FENCE  :: "(4)Word.word \<Rightarrow>(4)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_FENCE pred succ = (
   (case  (pred, succ) of
     (v__754, v__755) =>
      if ((((((((subrange_vec_dec v__754 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__755 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
        barrier Barrier_RISCV_rw_rw
      else if ((((((((subrange_vec_dec v__754 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__755 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
        barrier Barrier_RISCV_r_rw
      else if ((((((((subrange_vec_dec v__754 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__755 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
        barrier Barrier_RISCV_r_r
      else if ((((((((subrange_vec_dec v__754 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__755 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
        barrier Barrier_RISCV_rw_w
      else if ((((((((subrange_vec_dec v__754 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__755 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
        barrier Barrier_RISCV_w_w
      else if ((((((((subrange_vec_dec v__754 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__755 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word))))))) then
        barrier Barrier_RISCV_w_rw
      else if ((((((((subrange_vec_dec v__754 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__755 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
        barrier Barrier_RISCV_rw_r
      else if ((((((((subrange_vec_dec v__754 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__755 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word))))))) then
        barrier Barrier_RISCV_r_w
      else if ((((((((subrange_vec_dec v__754 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B1]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__755 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B0]  ::  2 Word.word))))))) then
        barrier Barrier_RISCV_w_r
      else
        return (if ((((((((subrange_vec_dec v__754 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word)))) \<and> (((((subrange_vec_dec v__755 (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B0,B0]  ::  2 Word.word))))))) then
                  () 
                else
                  (let (_ :: unit) = (print_endline (''FIXME: unsupported fence'')) in
                  () ))
   ) \<then>
   return RETIRE_SUCCESS )" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "


\<comment> \<open>\<open>val execute_ECALL : unit -> M Retired\<close>\<close>

definition execute_ECALL  :: " unit \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_ECALL _ = (
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__0 :: Privilege) . 
   (let (t :: sync_exception) =
     ((| sync_exception_trap =
          ((case  w__0 of
            User => E_U_EnvCall
          | Supervisor => E_S_EnvCall
          | Machine => E_M_EnvCall
          )), 
        sync_exception_excinfo = None, 
        sync_exception_ext_exception = None |)) in
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__1 :: Privilege) . 
   (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
   (exception_handler w__1 (CTL_TRAP t) w__2  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__3 ::  32 Word.word) . 
   set_next_pc w__3 \<then> return RETIRE_FAIL))))))"


\<comment> \<open>\<open>val execute_EBREAK : unit -> M Retired\<close>\<close>

definition execute_EBREAK  :: " unit \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_EBREAK _ = (
   (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   handle_mem_exception w__0 E_Breakpoint \<then> return RETIRE_FAIL))"


\<comment> \<open>\<open>val execute_DIVW : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M Retired\<close>\<close>

definition execute_DIVW  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_DIVW rs2 rs1 rd s = (
   haveMulDiv ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
     (let rs1_val = ((subrange_vec_dec w__1 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__2 ::  32 Word.word) . 
     (let rs2_val = ((subrange_vec_dec w__2 (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) in
     (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
     (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
     (let (q :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then ((( 0 :: int)-( 1 :: int))::ii) else hardware_quot rs1_int rs2_int) in
     (let (q' :: ii) =
       (if (((s \<and> ((q > ((((pow2 (( 31 :: int)::ii))) - (( 1 :: int)::ii)))))))) then
         (( 0 :: int)::ii) - ((pow (( 2 :: int)::ii) (( 31 :: int)::ii)))
       else q) in
     wX ((regidx_to_regno rd)) ((EXTS (( 32 :: int)::ii) ((to_bits (( 32 :: int)::ii) q'  ::  32 Word.word))  ::  32 Word.word)) \<then>
     return RETIRE_SUCCESS))))))))
   else handle_illegal ()  \<then> return RETIRE_FAIL))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "


\<comment> \<open>\<open>val execute_DIV : mword ty5 -> mword ty5 -> mword ty5 -> bool -> M Retired\<close>\<close>

definition execute_DIV  :: "(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_DIV rs2 rs1 rd s = (
   haveMulDiv ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs1_val . 
     (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs2_val . 
     (let (rs1_int :: ii) = (if s then Word.sint rs1_val else Word.uint rs1_val) in
     (let (rs2_int :: ii) = (if s then Word.sint rs2_val else Word.uint rs2_val) in
     (let (q :: ii) = (if (((rs2_int = (( 0 :: int)::ii)))) then ((( 0 :: int)-( 1 :: int))::ii) else hardware_quot rs1_int rs2_int) in
     (let (q' :: ii) = (if (((s \<and> ((q > xlen_max_signed))))) then xlen_min_signed else q) in
     wX ((regidx_to_regno rd)) ((to_bits (( 32 :: int)::ii) q'  ::  32 Word.word)) \<then> return RETIRE_SUCCESS))))))
   else handle_illegal ()  \<then> return RETIRE_FAIL))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "


\<comment> \<open>\<open>val execute_C_NOP : unit -> Retired\<close>\<close>

definition execute_C_NOP  :: " unit \<Rightarrow> Retired "  where 
     " execute_C_NOP _ = ( RETIRE_SUCCESS )"


\<comment> \<open>\<open>val execute_C_ILLEGAL : mword ty16 -> M Retired\<close>\<close>

definition execute_C_ILLEGAL  :: "(16)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_C_ILLEGAL s = ( handle_illegal ()  \<then> return RETIRE_FAIL )" 
  for  s  :: "(16)Word.word "


\<comment> \<open>\<open>val execute_CSR : mword ty12 -> mword ty5 -> mword ty5 -> bool -> csrop -> M Retired\<close>\<close>

definition execute_CSR  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bool \<Rightarrow> csrop \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_CSR csr rs1 rd is_imm op1 = (
   (if is_imm then return ((EXTZ (( 32 :: int)::ii) rs1  ::  32 Word.word))
    else (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M)) \<bind> (\<lambda> (rs1_val :: xlenbits) . 
   (let (isWrite :: bool) =
     ((case  op1 of
       CSRRW => True
     | _ => if is_imm then (((Word.uint rs1_val)) \<noteq> (( 0 :: int)::ii)) else (((Word.uint rs1)) \<noteq> (( 0 :: int)::ii))
     )) in
   read_reg cur_privilege_ref \<bind> (\<lambda> (w__1 :: Privilege) . 
   check_CSR csr w__1 isWrite \<bind> (\<lambda> (w__2 :: bool) . 
   if ((\<not> w__2)) then handle_illegal ()  \<then> return RETIRE_FAIL
   else
     (readCSR csr  :: ( 32 Word.word) M) \<bind> (\<lambda> csr_val . 
     ((if isWrite then
        (let (new_val :: xlenbits) =
          ((case  op1 of
            CSRRW => rs1_val
          | CSRRS => (or_vec csr_val rs1_val  ::  32 Word.word)
          | CSRRC => (and_vec csr_val ((not_vec rs1_val  ::  32 Word.word))  ::  32 Word.word)
          )) in
        writeCSR csr new_val)
      else return () ) \<then>
     wX ((regidx_to_regno rd)) csr_val) \<then> return RETIRE_SUCCESS))))))" 
  for  csr  :: "(12)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  is_imm  :: " bool " 
  and  op1  :: " csrop "


\<comment> \<open>\<open>val execute_BTYPE : mword ty13 -> mword ty5 -> mword ty5 -> bop -> M Retired\<close>\<close>

definition execute_BTYPE  :: "(13)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> bop \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_BTYPE imm rs2 rs1 op1 = (
   (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs1_val . 
   (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> rs2_val . 
   (let (taken :: bool) =
     ((case  op1 of
       RISCV_BEQ => (rs1_val = rs2_val)
     | RISCV_BNE => (rs1_val \<noteq> rs2_val)
     | RISCV_BLT => zopz0zI_s rs1_val rs2_val
     | RISCV_BGE => zopz0zKzJ_s rs1_val rs2_val
     | RISCV_BLTU => zopz0zI_u rs1_val rs2_val
     | RISCV_BGEU => zopz0zKzJ_u rs1_val rs2_val
     )) in
   (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   (let (t :: xlenbits) = ((add_vec w__0 ((EXTS (( 32 :: int)::ii) imm  ::  32 Word.word))  ::  32 Word.word)) in
   if taken then
     (case  ((ext_control_check_pc t)) of
       Ext_ControlAddr_Error (e) =>
        (let (_ :: unit) = (ext_handle_control_check_error e) in
        return RETIRE_FAIL)
     | Ext_ControlAddr_OK (target) =>
        and_boolM (return ((bit_to_bool ((access_vec_dec target (( 1 :: int)::ii))))))
          (haveRVC ()  \<bind> (\<lambda> (w__1 :: bool) .  return ((\<not> w__1)))) \<bind> (\<lambda> (w__2 :: bool) . 
        if w__2 then handle_mem_exception target E_Fetch_Addr_Align \<then> return RETIRE_FAIL
        else set_next_pc target \<then> return RETIRE_SUCCESS)
     )
   else return RETIRE_SUCCESS))))))" 
  for  imm  :: "(13)Word.word " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  op1  :: " bop "


\<comment> \<open>\<open>val execute_AMO : amoop -> bool -> bool -> mword ty5 -> mword ty5 -> word_width -> mword ty5 -> M Retired\<close>\<close>

definition execute_AMO  :: " amoop \<Rightarrow> bool \<Rightarrow> bool \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow> word_width \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_AMO op1 aq rl rs2 rs1 width rd = (
   haveAtomics ()  \<bind> (\<lambda> (w__0 :: bool) . 
   if w__0 then
     ext_data_get_addr rs1 ((zeros_implicit (( 32 :: int)::ii)  ::  32 Word.word)) ReadWrite width \<bind> (\<lambda> (w__1 :: unit
       Ext_DataAddr_Check) . 
     (case  w__1 of
       Ext_DataAddr_Error (e) =>
        (let (_ :: unit) = (ext_handle_data_check_error e) in
        return RETIRE_FAIL)
     | Ext_DataAddr_OK (vaddr) =>
        (translateAddr vaddr ReadWrite  :: ( (( 32 Word.word), ExceptionType)TR_Result) M) \<bind> (\<lambda> (w__2 :: (( 32 Word.word), ExceptionType)
          TR_Result) . 
        (case  w__2 of
          TR_Failure (e) => handle_mem_exception vaddr e \<then> return RETIRE_FAIL
        | TR_Address (addr) =>
           (case  (width, (( 32 :: int)::ii)) of
             (WORD, _) => mem_write_ea addr (( 4 :: int)::ii) (((aq \<and> rl))) rl True
           | _ => internal_error (''AMO expected WORD or DOUBLE'')
           ) \<bind> (\<lambda> (eares :: unit MemoryOpResult) . 
           (rX ((regidx_to_regno rs2))  :: ( 32 Word.word) M) \<bind> (\<lambda> (rs2_val :: xlenbits) . 
           (case  eares of
             MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
           | MemValue (_) =>
              (case  (width, (( 32 :: int)::ii)) of
                (WORD, _) =>
                 (mem_read ReadWrite addr (( 4 :: int)::ii) aq (((aq \<and> rl))) True
                   :: ( ( 32 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__5 :: ( 32 Word.word) MemoryOpResult) . 
                 return ((extend_value False w__5  :: ( 32 Word.word) MemoryOpResult)))
              | _ =>
                 (internal_error (''AMO expected WORD or DOUBLE'')  :: ( ( 32 Word.word)MemoryOpResult) M)
              ) \<bind> (\<lambda> (rval :: xlenbits MemoryOpResult) . 
              (case  rval of
                MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
              | MemValue (loaded) =>
                 (let (result :: xlenbits) =
                   ((case  op1 of
                     AMOSWAP => rs2_val
                   | AMOADD => (add_vec rs2_val loaded  ::  32 Word.word)
                   | AMOXOR => (xor_vec rs2_val loaded  ::  32 Word.word)
                   | AMOAND => (and_vec rs2_val loaded  ::  32 Word.word)
                   | AMOOR => (or_vec rs2_val loaded  ::  32 Word.word)
                   | AMOMIN =>
                      (to_bits (( 32 :: int)::ii) ((min ((Word.sint rs2_val)) ((Word.sint loaded))))  ::  32 Word.word)
                   | AMOMAX =>
                      (to_bits (( 32 :: int)::ii) ((max ((Word.sint rs2_val)) ((Word.sint loaded))))  ::  32 Word.word)
                   | AMOMINU =>
                      (to_bits (( 32 :: int)::ii) ((min ((Word.uint rs2_val)) ((Word.uint loaded))))  ::  32 Word.word)
                   | AMOMAXU =>
                      (to_bits (( 32 :: int)::ii) ((max ((Word.uint rs2_val)) ((Word.uint loaded))))  ::  32 Word.word)
                   )) in
                 (case  (width, (( 32 :: int)::ii)) of
                   (WORD, _) =>
                    mem_write_value addr (( 4 :: int)::ii)
                      ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word)) (((aq \<and> rl))) rl
                      True
                 | _ => internal_error (''AMO expected WORD or DOUBLE'')
                 ) \<bind> (\<lambda> (wval :: bool MemoryOpResult) . 
                 (case  wval of
                   MemValue (True) => wX ((regidx_to_regno rd)) loaded \<then> return RETIRE_SUCCESS
                 | MemValue (False) => internal_error (''AMO got false from mem_write_value'')
                 | MemException (e) => handle_mem_exception addr e \<then> return RETIRE_FAIL
                 )))
              ))
           )))
        ))
     ))
   else handle_illegal ()  \<then> return RETIRE_FAIL))" 
  for  op1  :: " amoop " 
  and  aq  :: " bool " 
  and  rl  :: " bool " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  width  :: " word_width " 
  and  rd  :: "(5)Word.word "


\<comment> \<open>\<open>val execute_ADDIW : mword ty12 -> mword ty5 -> mword ty5 -> M Retired\<close>\<close>

definition execute_ADDIW  :: "(12)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>(5)Word.word \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute_ADDIW imm rs1 rd = (
   (rX ((regidx_to_regno rs1))  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   (let (result :: xlenbits) = ((add_vec ((EXTS (( 32 :: int)::ii) imm  ::  32 Word.word)) w__0  ::  32 Word.word)) in
   wX ((regidx_to_regno rd))
     ((EXTS (( 32 :: int)::ii) ((subrange_vec_dec result (( 31 :: int)::ii) (( 0 :: int)::ii)  ::  32 Word.word))  ::  32 Word.word)) \<then>
   return RETIRE_SUCCESS)))" 
  for  imm  :: "(12)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "


function (sequential,domintros)  execute  :: " ast \<Rightarrow>((register_value),(Retired),(exception))monad "  where 
     " execute (C_ADDI4SPN ((rdc, nzimm))) = (
      (let (imm :: 12 bits) =
        ((concat_vec (vec_of_bits [B0,B0]  ::  2 Word.word)
           ((concat_vec nzimm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  10 Word.word))
          ::  12 Word.word)) in
      (let rd = ((creg2reg_idx rdc  ::  5 Word.word)) in
      execute (ITYPE (imm, sp, rd, RISCV_ADDI)))))" 
  for  nzimm  :: "(8)Word.word " 
  and  rdc  :: "(3)Word.word "
|" execute (C_LW ((uimm, rsc, rdc))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  7 Word.word))
          ::  12 Word.word)) in
      (let rd = ((creg2reg_idx rdc  ::  5 Word.word)) in
      (let rs = ((creg2reg_idx rsc  ::  5 Word.word)) in
      execute (LOAD (imm, rs, rd, False, WORD, False, False))))))" 
  for  rsc  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word " 
  and  rdc  :: "(3)Word.word "
|" execute (C_LD ((uimm, rsc, rdc))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0,B0]  ::  3 Word.word)  ::  8 Word.word))
          ::  12 Word.word)) in
      (let rd = ((creg2reg_idx rdc  ::  5 Word.word)) in
      (let rs = ((creg2reg_idx rsc  ::  5 Word.word)) in
      execute (LOAD (imm, rs, rd, False, DOUBLE, False, False))))))" 
  for  rsc  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word " 
  and  rdc  :: "(3)Word.word "
|" execute (C_SW ((uimm, rsc1, rsc2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  7 Word.word))
          ::  12 Word.word)) in
      (let rs1 = ((creg2reg_idx rsc1  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rsc2  ::  5 Word.word)) in
      execute (STORE (imm, rs2, rs1, WORD, False, False))))))" 
  for  rsc2  :: "(3)Word.word " 
  and  rsc1  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word "
|" execute (C_SD ((uimm, rsc1, rsc2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0,B0]  ::  3 Word.word)  ::  8 Word.word))
          ::  12 Word.word)) in
      (let rs1 = ((creg2reg_idx rsc1  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rsc2  ::  5 Word.word)) in
      execute (STORE (imm, rs2, rs1, DOUBLE, False, False))))))" 
  for  rsc2  :: "(3)Word.word " 
  and  rsc1  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word "
|" execute (C_ADDI ((nzi, rsd))) = (
      (let (imm :: 12 bits) = ((EXTS (( 12 :: int)::ii) nzi  ::  12 Word.word)) in
      execute (ITYPE (imm, rsd, rsd, RISCV_ADDI))))" 
  for  nzi  :: "(6)Word.word " 
  and  rsd  :: "(5)Word.word "
|" execute (C_JAL (imm)) = (
      execute
        (RISCV_JAL ((EXTS (( 21 :: int)::ii) ((concat_vec imm (vec_of_bits [B0]  ::  1 Word.word)  ::  12 Word.word))
                      ::  21 Word.word),
                    ra)))" 
  for  imm  :: "(11)Word.word "
|" execute (C_ADDIW ((imm, rsd))) = ( execute (ADDIW ((EXTS (( 12 :: int)::ii) imm  ::  12 Word.word), rsd, rsd)))" 
  for  rsd  :: "(5)Word.word " 
  and  imm  :: "(6)Word.word "
|" execute (C_LI ((imm, rd))) = (
      (let (imm :: 12 bits) = ((EXTS (( 12 :: int)::ii) imm  ::  12 Word.word)) in
      execute (ITYPE (imm, zreg, rd, RISCV_ADDI))))" 
  for  imm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (C_ADDI16SP (imm)) = (
      (let (imm :: 12 bits) =
        ((EXTS (( 12 :: int)::ii) ((concat_vec imm (vec_of_bits [B0,B0,B0,B0]  ::  4 Word.word)  ::  10 Word.word))
          ::  12 Word.word)) in
      execute (ITYPE (imm, sp, sp, RISCV_ADDI))))" 
  for  imm  :: "(6)Word.word "
|" execute (C_LUI ((imm, rd))) = (
      (let (res :: 20 bits) = ((EXTS (( 20 :: int)::ii) imm  ::  20 Word.word)) in
      execute (UTYPE (res, rd, RISCV_LUI))))" 
  for  imm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (C_SRLI ((shamt, rsd))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      execute (SHIFTIOP (shamt, rsd, rsd, RISCV_SRLI))))" 
  for  rsd  :: "(3)Word.word " 
  and  shamt  :: "(6)Word.word "
|" execute (C_SRAI ((shamt, rsd))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      execute (SHIFTIOP (shamt, rsd, rsd, RISCV_SRAI))))" 
  for  rsd  :: "(3)Word.word " 
  and  shamt  :: "(6)Word.word "
|" execute (C_ANDI ((imm, rsd))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      execute (ITYPE ((EXTS (( 12 :: int)::ii) imm  ::  12 Word.word), rsd, rsd, RISCV_ANDI))))" 
  for  rsd  :: "(3)Word.word " 
  and  imm  :: "(6)Word.word "
|" execute (C_SUB ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2, rsd, rsd, RISCV_SUB)))))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" execute (C_XOR ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2, rsd, rsd, RISCV_XOR)))))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" execute (C_OR ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2, rsd, rsd, RISCV_OR)))))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" execute (C_AND ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPE (rs2, rsd, rsd, RISCV_AND)))))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" execute (C_SUBW ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPEW (rs2, rsd, rsd, RISCV_SUBW)))))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" execute (C_ADDW ((rsd, rs2))) = (
      (let rsd = ((creg2reg_idx rsd  ::  5 Word.word)) in
      (let rs2 = ((creg2reg_idx rs2  ::  5 Word.word)) in
      execute (RTYPEW (rs2, rsd, rsd, RISCV_ADDW)))))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" execute (C_J (imm)) = (
      execute
        (RISCV_JAL ((EXTS (( 21 :: int)::ii) ((concat_vec imm (vec_of_bits [B0]  ::  1 Word.word)  ::  12 Word.word))
                      ::  21 Word.word),
                    zreg)))" 
  for  imm  :: "(11)Word.word "
|" execute (C_BEQZ ((imm, rs))) = (
      execute
        (BTYPE ((EXTS (( 13 :: int)::ii) ((concat_vec imm (vec_of_bits [B0]  ::  1 Word.word)  ::  9 Word.word))
                  ::  13 Word.word),
                zreg,
                (creg2reg_idx rs  ::  5 Word.word),
                RISCV_BEQ)))" 
  for  rs  :: "(3)Word.word " 
  and  imm  :: "(8)Word.word "
|" execute (C_BNEZ ((imm, rs))) = (
      execute
        (BTYPE ((EXTS (( 13 :: int)::ii) ((concat_vec imm (vec_of_bits [B0]  ::  1 Word.word)  ::  9 Word.word))
                  ::  13 Word.word),
                zreg,
                (creg2reg_idx rs  ::  5 Word.word),
                RISCV_BNE)))" 
  for  rs  :: "(3)Word.word " 
  and  imm  :: "(8)Word.word "
|" execute (C_SLLI ((shamt, rsd))) = ( execute (SHIFTIOP (shamt, rsd, rsd, RISCV_SLLI)))" 
  for  rsd  :: "(5)Word.word " 
  and  shamt  :: "(6)Word.word "
|" execute (C_LWSP ((uimm, rd))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  8 Word.word))
          ::  12 Word.word)) in
      execute (LOAD (imm, sp, rd, False, WORD, False, False))))" 
  for  uimm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (C_LDSP ((uimm, rd))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0,B0]  ::  3 Word.word)  ::  9 Word.word))
          ::  12 Word.word)) in
      execute (LOAD (imm, sp, rd, False, DOUBLE, False, False))))" 
  for  uimm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (C_SWSP ((uimm, rs2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0]  ::  2 Word.word)  ::  8 Word.word))
          ::  12 Word.word)) in
      execute (STORE (imm, rs2, sp, WORD, False, False))))" 
  for  uimm  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|" execute (C_SDSP ((uimm, rs2))) = (
      (let (imm :: 12 bits) =
        ((EXTZ (( 12 :: int)::ii) ((concat_vec uimm (vec_of_bits [B0,B0,B0]  ::  3 Word.word)  ::  9 Word.word))
          ::  12 Word.word)) in
      execute (STORE (imm, rs2, sp, DOUBLE, False, False))))" 
  for  uimm  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|" execute (C_JR (rs1)) = (
      execute (RISCV_JALR ((EXTZ (( 12 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  12 Word.word), rs1, zreg)))" 
  for  rs1  :: "(5)Word.word "
|" execute (C_JALR (rs1)) = (
      execute (RISCV_JALR ((EXTZ (( 12 :: int)::ii) (vec_of_bits [B0]  ::  1 Word.word)  ::  12 Word.word), rs1, ra)))" 
  for  rs1  :: "(5)Word.word "
|" execute (C_MV ((rd, rs2))) = ( execute (RTYPE (rs2, zreg, rd, RISCV_ADD)))" 
  for  rs2  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (C_EBREAK (_)) = ( execute (EBREAK () ))"
|" execute (C_ADD ((rsd, rs2))) = ( execute (RTYPE (rs2, rsd, rsd, RISCV_ADD)))" 
  for  rsd  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word "
|" execute (UTYPE ((imm, rd, op1))) = ( execute_UTYPE imm rd op1 )" 
  for  op1  :: " uop " 
  and  imm  :: "(20)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (RISCV_JAL ((imm, rd))) = ( execute_RISCV_JAL imm rd )" 
  for  imm  :: "(21)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (BTYPE ((imm, rs2, rs1, op1))) = ( execute_BTYPE imm rs2 rs1 op1 )" 
  for  op1  :: " bop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(13)Word.word "
|" execute (ITYPE ((imm, rs1, rd, op1))) = ( execute_ITYPE imm rs1 rd op1 )" 
  for  op1  :: " iop " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (SHIFTIOP ((shamt, rs1, rd, op1))) = ( execute_SHIFTIOP shamt rs1 rd op1 )" 
  for  op1  :: " sop " 
  and  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (RTYPE ((rs2, rs1, rd, op1))) = ( execute_RTYPE rs2 rs1 rd op1 )" 
  for  op1  :: " rop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (LOAD ((imm, rs1, rd, is_unsigned, width, aq, rl))) = (
      execute_LOAD imm rs1 rd is_unsigned width aq rl )" 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  is_unsigned  :: " bool " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|" execute (STORE ((imm, rs2, rs1, width, aq, rl))) = ( execute_STORE imm rs2 rs1 width aq rl )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|" execute (ADDIW ((imm, rs1, rd))) = ( execute_ADDIW imm rs1 rd )" 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (SHIFTW ((shamt, rs1, rd, op1))) = ( execute_SHIFTW shamt rs1 rd op1 )" 
  for  op1  :: " sop " 
  and  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (RTYPEW ((rs2, rs1, rd, op1))) = ( execute_RTYPEW rs2 rs1 rd op1 )" 
  for  op1  :: " ropw " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (SHIFTIWOP ((shamt, rs1, rd, op1))) = ( execute_SHIFTIWOP shamt rs1 rd op1 )" 
  for  op1  :: " sopw " 
  and  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (FENCE ((pred, succ))) = ( execute_FENCE pred succ )" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|" execute (FENCE_TSO ((pred, succ))) = ( execute_FENCE_TSO pred succ )" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|" execute (FENCEI (arg0)) = ( return ((execute_FENCEI arg0)))" 
  for  arg0  :: " unit "
|" execute (ECALL (arg0)) = ( execute_ECALL arg0 )" 
  for  arg0  :: " unit "
|" execute (MRET (arg0)) = ( execute_MRET arg0 )" 
  for  arg0  :: " unit "
|" execute (SRET (arg0)) = ( execute_SRET arg0 )" 
  for  arg0  :: " unit "
|" execute (EBREAK (arg0)) = ( execute_EBREAK arg0 )" 
  for  arg0  :: " unit "
|" execute (WFI (arg0)) = ( execute_WFI arg0 )" 
  for  arg0  :: " unit "
|" execute (SFENCE_VMA ((rs1, rs2))) = ( execute_SFENCE_VMA rs1 rs2 )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word "
|" execute (LOADRES ((aq, rl, rs1, width, rd))) = ( execute_LOADRES aq rl rs1 width rd )" 
  for  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|" execute (STORECON ((aq, rl, rs2, rs1, width, rd))) = ( execute_STORECON aq rl rs2 rs1 width rd )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|" execute (AMO ((op1, aq, rl, rs2, rs1, width, rd))) = ( execute_AMO op1 aq rl rs2 rs1 width rd )" 
  for  op1  :: " amoop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|" execute (C_NOP (arg0)) = ( return ((execute_C_NOP arg0)))" 
  for  arg0  :: " unit "
|" execute (MUL ((rs2, rs1, rd, high, signed1, signed2))) = ( execute_MUL rs2 rs1 rd high signed1 signed2 )" 
  for  signed2  :: " bool " 
  and  signed1  :: " bool " 
  and  high  :: " bool " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (DIV ((rs2, rs1, rd, s))) = ( execute_DIV rs2 rs1 rd s )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" execute (REM ((rs2, rs1, rd, s))) = ( execute_REM rs2 rs1 rd s )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" execute (MULW ((rs2, rs1, rd))) = ( execute_MULW rs2 rs1 rd )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (DIVW ((rs2, rs1, rd, s))) = ( execute_DIVW rs2 rs1 rd s )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" execute (REMW ((rs2, rs1, rd, s))) = ( execute_REMW rs2 rs1 rd s )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" execute (CSR ((csr, rs1, rd, is_imm, op1))) = ( execute_CSR csr rs1 rd is_imm op1 )" 
  for  op1  :: " csrop " 
  and  is_imm  :: " bool " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  csr  :: "(12)Word.word "
|" execute (URET (arg0)) = ( execute_URET arg0 )" 
  for  arg0  :: " unit "
|" execute (RISCV_JALR ((imm, rs1, rd))) = ( execute_RISCV_JALR imm rs1 rd )" 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" execute (ILLEGAL (s)) = ( execute_ILLEGAL s )" 
  for  s  :: "(32)Word.word "
|" execute (C_ILLEGAL (s)) = ( execute_C_ILLEGAL s )" 
  for  s  :: "(16)Word.word " 
by pat_completeness auto


\<comment> \<open>\<open>val assembly_forwards : ast -> M string\<close>\<close>

fun assembly_forwards  :: " ast \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " assembly_forwards (UTYPE ((imm, rd, op1))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__0 :: string) . 
      return ((string_append ((utype_mnemonic_forwards op1))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__0
                         ((string_append ((sep_forwards () ))
                             ((string_append ((decimal_string_of_bits imm)) ('''')))))))))))))" 
  for  op1  :: " uop " 
  and  imm  :: "(20)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (RISCV_JAL ((imm, rd))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__1 :: string) . 
      return ((string_append (''jal'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__1
                         ((string_append ((sep_forwards () ))
                             ((string_append ((decimal_string_of_bits imm)) ('''')))))))))))))" 
  for  imm  :: "(21)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (RISCV_JALR ((imm, rs1, rd))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__2 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__3 :: string) . 
      return ((string_append (''jalr'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__2
                         ((string_append ((sep_forwards () ))
                             ((string_append w__3
                                 ((string_append ((sep_forwards () ))
                                     ((string_append ((decimal_string_of_bits imm)) (''''))))))))))))))))))" 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (BTYPE ((imm, rs2, rs1, op1))) = (
      reg_name_forwards rs1 \<bind> (\<lambda> (w__4 :: string) . 
      reg_name_forwards rs2 \<bind> (\<lambda> (w__5 :: string) . 
      return ((string_append ((btype_mnemonic_forwards op1))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__4
                         ((string_append ((sep_forwards () ))
                             ((string_append w__5
                                 ((string_append ((sep_forwards () ))
                                     ((string_append ((decimal_string_of_bits imm)) (''''))))))))))))))))))" 
  for  op1  :: " bop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(13)Word.word "
|" assembly_forwards (ITYPE ((imm, rs1, rd, op1))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__6 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__7 :: string) . 
      return ((string_append ((itype_mnemonic_forwards op1))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__6
                         ((string_append ((sep_forwards () ))
                             ((string_append w__7
                                 ((string_append ((sep_forwards () ))
                                     ((string_append ((decimal_string_of_bits imm)) (''''))))))))))))))))))" 
  for  op1  :: " iop " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (SHIFTIOP ((shamt, rs1, rd, op1))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__8 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__9 :: string) . 
      return ((string_append ((shiftiop_mnemonic_forwards op1))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__8
                         ((string_append ((sep_forwards () ))
                             ((string_append w__9
                                 ((string_append ((sep_forwards () ))
                                     ((string_append ((decimal_string_of_bits shamt)) (''''))))))))))))))))))" 
  for  op1  :: " sop " 
  and  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (RTYPE ((rs2, rs1, rd, op1))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__10 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__11 :: string) . 
      reg_name_forwards rs2 \<bind> (\<lambda> (w__12 :: string) . 
      return ((string_append ((rtype_mnemonic_forwards op1))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__10
                         ((string_append ((sep_forwards () ))
                             ((string_append w__11
                                 ((string_append ((sep_forwards () )) ((string_append w__12 ('''')))))))))))))))))))" 
  for  op1  :: " rop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (LOAD ((imm, rs1, rd, is_unsigned, size1, aq, rl))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__13 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__14 :: string) . 
      return ((string_append (''l'')
                 ((string_append ((size_mnemonic_forwards size1))
                     ((string_append ((maybe_u_forwards is_unsigned))
                         ((string_append ((maybe_aq_forwards aq))
                             ((string_append ((maybe_rl_forwards rl))
                                 ((string_append ((spc_forwards () ))
                                     ((string_append w__13
                                         ((string_append ((sep_forwards () ))
                                             ((string_append ((decimal_string_of_bits imm))
                                                 ((string_append ((opt_spc_forwards () ))
                                                     ((string_append (''('')
                                                         ((string_append ((opt_spc_forwards () ))
                                                             ((string_append w__14
                                                                 ((string_append
                                                                     ((opt_spc_forwards () ))
                                                                     ((string_append ('')'') (''''))))))))))))))))))))))))))))))))))" 
  for  size1  :: " word_width " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  is_unsigned  :: " bool " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" assembly_forwards (STORE ((imm, rs2, rs1, size1, aq, rl))) = (
      reg_name_forwards rs2 \<bind> (\<lambda> (w__15 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__16 :: string) . 
      return ((string_append (''s'')
                 ((string_append ((size_mnemonic_forwards size1))
                     ((string_append ((maybe_aq_forwards aq))
                         ((string_append ((maybe_rl_forwards rl))
                             ((string_append ((spc_forwards () ))
                                 ((string_append w__15
                                     ((string_append ((sep_forwards () ))
                                         ((string_append ((decimal_string_of_bits imm))
                                             ((string_append ((opt_spc_forwards () ))
                                                 ((string_append (''('')
                                                     ((string_append ((opt_spc_forwards () ))
                                                         ((string_append w__16
                                                             ((string_append ((opt_spc_forwards () ))
                                                                 ((string_append ('')'') (''''))))))))))))))))))))))))))))))))" 
  for  size1  :: " word_width " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" assembly_forwards (ADDIW ((imm, rs1, rd))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        reg_name_forwards rd \<bind> (\<lambda> (w__17 :: string) . 
        reg_name_forwards rs1 \<bind> (\<lambda> (w__18 :: string) . 
        return ((string_append (''addiw'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__17
                           ((string_append ((sep_forwards () ))
                               ((string_append w__18
                                   ((string_append ((sep_forwards () ))
                                       ((string_append ((decimal_string_of_bits imm)) ('''')))))))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (SHIFTW ((shamt, rs1, rd, op1))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        reg_name_forwards rd \<bind> (\<lambda> (w__21 :: string) . 
        reg_name_forwards rs1 \<bind> (\<lambda> (w__22 :: string) . 
        return ((string_append ((shiftw_mnemonic_forwards op1))
                   ((string_append ((spc_forwards () ))
                       ((string_append w__21
                           ((string_append ((sep_forwards () ))
                               ((string_append w__22
                                   ((string_append ((sep_forwards () ))
                                       ((string_append ((decimal_string_of_bits shamt)) ('''')))))))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  op1  :: " sop " 
  and  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (RTYPEW ((rs2, rs1, rd, op1))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        reg_name_forwards rd \<bind> (\<lambda> (w__25 :: string) . 
        reg_name_forwards rs1 \<bind> (\<lambda> (w__26 :: string) . 
        reg_name_forwards rs2 \<bind> (\<lambda> (w__27 :: string) . 
        return ((string_append ((rtypew_mnemonic_forwards op1))
                   ((string_append ((spc_forwards () ))
                       ((string_append w__25
                           ((string_append ((sep_forwards () ))
                               ((string_append w__26
                                   ((string_append ((sep_forwards () )) ((string_append w__27 (''''))))))))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  op1  :: " ropw " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (SHIFTIWOP ((shamt, rs1, rd, op1))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        reg_name_forwards rd \<bind> (\<lambda> (w__30 :: string) . 
        reg_name_forwards rs1 \<bind> (\<lambda> (w__31 :: string) . 
        return ((string_append ((shiftiwop_mnemonic_forwards op1))
                   ((string_append ((spc_forwards () ))
                       ((string_append w__30
                           ((string_append ((sep_forwards () ))
                               ((string_append w__31
                                   ((string_append ((sep_forwards () ))
                                       ((string_append ((decimal_string_of_bits shamt)) ('''')))))))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  op1  :: " sopw " 
  and  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (FENCE ((pred, succ))) = (
      fence_bits_forwards pred \<bind> (\<lambda> (w__34 :: string) . 
      fence_bits_forwards succ \<bind> (\<lambda> (w__35 :: string) . 
      return ((string_append (''fence'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__34
                         ((string_append ((sep_forwards () )) ((string_append w__35 (''''))))))))))))))" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|" assembly_forwards (FENCE_TSO ((pred, succ))) = (
      fence_bits_forwards pred \<bind> (\<lambda> (w__36 :: string) . 
      fence_bits_forwards succ \<bind> (\<lambda> (w__37 :: string) . 
      return ((string_append (''fence.tso'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__36
                         ((string_append ((sep_forwards () )) ((string_append w__37 (''''))))))))))))))" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|" assembly_forwards (FENCEI (_)) = ( return (''fence.i''))"
|" assembly_forwards (ECALL (_)) = ( return (''ecall''))"
|" assembly_forwards (MRET (_)) = ( return (''mret''))"
|" assembly_forwards (SRET (_)) = ( return (''sret''))"
|" assembly_forwards (EBREAK (_)) = ( return (''ebreak''))"
|" assembly_forwards (WFI (_)) = ( return (''wfi''))"
|" assembly_forwards (SFENCE_VMA ((rs1, rs2))) = (
      reg_name_forwards rs1 \<bind> (\<lambda> (w__38 :: string) . 
      reg_name_forwards rs2 \<bind> (\<lambda> (w__39 :: string) . 
      return ((string_append (''sfence.vma'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__38
                         ((string_append ((sep_forwards () )) ((string_append w__39 (''''))))))))))))))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word "
|" assembly_forwards (LOADRES ((aq, rl, rs1, size1, rd))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__40 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__41 :: string) . 
      return ((string_append (''lr.'')
                 ((string_append ((size_mnemonic_forwards size1))
                     ((string_append ((maybe_aq_forwards aq))
                         ((string_append ((maybe_rl_forwards rl))
                             ((string_append ((spc_forwards () ))
                                 ((string_append w__40
                                     ((string_append ((sep_forwards () )) ((string_append w__41 (''''))))))))))))))))))))" 
  for  size1  :: " word_width " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" assembly_forwards (STORECON ((aq, rl, rs2, rs1, size1, rd))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__42 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__43 :: string) . 
      reg_name_forwards rs2 \<bind> (\<lambda> (w__44 :: string) . 
      return ((string_append (''sc.'')
                 ((string_append ((size_mnemonic_forwards size1))
                     ((string_append ((maybe_aq_forwards aq))
                         ((string_append ((maybe_rl_forwards rl))
                             ((string_append ((spc_forwards () ))
                                 ((string_append w__42
                                     ((string_append ((sep_forwards () ))
                                         ((string_append w__43
                                             ((string_append ((sep_forwards () ))
                                                 ((string_append w__44 ('''')))))))))))))))))))))))))" 
  for  size1  :: " word_width " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" assembly_forwards (AMO ((op1, aq, rl, rs2, rs1, width, rd))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__45 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__46 :: string) . 
      reg_name_forwards rs2 \<bind> (\<lambda> (w__47 :: string) . 
      return ((string_append ((amo_mnemonic_forwards op1))
                 ((string_append (''.'')
                     ((string_append ((size_mnemonic_forwards width))
                         ((string_append ((maybe_aq_forwards aq))
                             ((string_append ((maybe_rl_forwards rl))
                                 ((string_append ((spc_forwards () ))
                                     ((string_append w__45
                                         ((string_append ((sep_forwards () ))
                                             ((string_append w__46
                                                 ((string_append ((sep_forwards () ))
                                                     ((string_append w__47 ('''')))))))))))))))))))))))))))" 
  for  op1  :: " amoop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|" assembly_forwards (C_NOP (_)) = ( return (''c.nop''))"
|" assembly_forwards (C_ADDI4SPN ((rdc, nzimm))) = (
      if (((nzimm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)))) then
        creg_name_forwards rdc \<bind> (\<lambda> (w__48 :: string) . 
        return ((string_append (''c.addi4spn'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__48
                           ((string_append ((sep_forwards () ))
                               ((string_append
                                   ((decimal_string_of_bits
                                       ((concat_vec nzimm (vec_of_bits [B0,B0]  ::  2 Word.word)
                                          ::  10 Word.word)))) (''''))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  nzimm  :: "(8)Word.word " 
  and  rdc  :: "(3)Word.word "
|" assembly_forwards (C_LW ((uimm, rsc, rdc))) = (
      creg_name_forwards rdc \<bind> (\<lambda> (w__51 :: string) . 
      creg_name_forwards rsc \<bind> (\<lambda> (w__52 :: string) . 
      return ((string_append (''c.lw'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__51
                         ((string_append ((sep_forwards () ))
                             ((string_append w__52
                                 ((string_append ((sep_forwards () ))
                                     ((string_append
                                         ((decimal_string_of_bits
                                             ((concat_vec uimm (vec_of_bits [B0,B0]  ::  2 Word.word)
                                                ::  7 Word.word)))) (''''))))))))))))))))))" 
  for  rsc  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word " 
  and  rdc  :: "(3)Word.word "
|" assembly_forwards (C_LD ((uimm, rsc, rdc))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        creg_name_forwards rdc \<bind> (\<lambda> (w__53 :: string) . 
        creg_name_forwards rsc \<bind> (\<lambda> (w__54 :: string) . 
        return ((string_append (''c.ld'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__53
                           ((string_append ((sep_forwards () ))
                               ((string_append w__54
                                   ((string_append ((sep_forwards () ))
                                       ((string_append
                                           ((decimal_string_of_bits
                                               ((concat_vec uimm
                                                   (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                                                  ::  8 Word.word)))) ('''')))))))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsc  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word " 
  and  rdc  :: "(3)Word.word "
|" assembly_forwards (C_SW ((uimm, rsc1, rsc2))) = (
      creg_name_forwards rsc1 \<bind> (\<lambda> (w__57 :: string) . 
      creg_name_forwards rsc2 \<bind> (\<lambda> (w__58 :: string) . 
      return ((string_append (''c.sw'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__57
                         ((string_append ((sep_forwards () ))
                             ((string_append w__58
                                 ((string_append ((sep_forwards () ))
                                     ((string_append
                                         ((decimal_string_of_bits
                                             ((concat_vec uimm (vec_of_bits [B0,B0]  ::  2 Word.word)
                                                ::  7 Word.word)))) (''''))))))))))))))))))" 
  for  rsc2  :: "(3)Word.word " 
  and  rsc1  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word "
|" assembly_forwards (C_SD ((uimm, rsc1, rsc2))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        creg_name_forwards rsc1 \<bind> (\<lambda> (w__59 :: string) . 
        creg_name_forwards rsc2 \<bind> (\<lambda> (w__60 :: string) . 
        return ((string_append (''c.sd'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__59
                           ((string_append ((sep_forwards () ))
                               ((string_append w__60
                                   ((string_append ((sep_forwards () ))
                                       ((string_append
                                           ((decimal_string_of_bits
                                               ((concat_vec uimm
                                                   (vec_of_bits [B0,B0,B0]  ::  3 Word.word)
                                                  ::  8 Word.word)))) ('''')))))))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsc2  :: "(3)Word.word " 
  and  rsc1  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word "
|" assembly_forwards (C_ADDI ((nzi, rsd))) = (
      if ((((((nzi \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg)))))))) then
        reg_name_forwards rsd \<bind> (\<lambda> (w__63 :: string) . 
        return ((string_append (''c.addi'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__63
                           ((string_append ((sep_forwards () ))
                               ((string_append ((decimal_string_of_bits nzi)) (''''))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  nzi  :: "(6)Word.word " 
  and  rsd  :: "(5)Word.word "
|" assembly_forwards (C_JAL (imm)) = (
      if ((((( 32 :: int)::ii) = (( 32 :: int)::ii)))) then
        return ((string_append (''c.jal'')
                   ((string_append ((spc_forwards () ))
                       ((string_append
                           ((decimal_string_of_bits
                               ((concat_vec imm (vec_of_bits [B0]  ::  1 Word.word)  ::  12 Word.word)))) ('''')))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  imm  :: "(11)Word.word "
|" assembly_forwards (C_ADDIW ((imm, rsd))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        reg_name_forwards rsd \<bind> (\<lambda> (w__68 :: string) . 
        return ((string_append (''c.addiw'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__68
                           ((string_append ((sep_forwards () ))
                               ((string_append ((decimal_string_of_bits imm)) (''''))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsd  :: "(5)Word.word " 
  and  imm  :: "(6)Word.word "
|" assembly_forwards (C_LI ((imm, rd))) = (
      if (((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) then
        reg_name_forwards rd \<bind> (\<lambda> (w__71 :: string) . 
        return ((string_append (''c.li'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__71
                           ((string_append ((sep_forwards () ))
                               ((string_append ((decimal_string_of_bits imm)) (''''))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  imm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (C_ADDI16SP (imm)) = (
      if (((imm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) then
        return ((string_append (''c.addi16sp'')
                   ((string_append ((spc_forwards () ))
                       ((string_append ((decimal_string_of_bits imm)) ('''')))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  imm  :: "(6)Word.word "
|" assembly_forwards (C_LUI ((imm, rd))) = (
      if ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno sp))))) \<and> (((imm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))))) then
        reg_name_forwards rd \<bind> (\<lambda> (w__76 :: string) . 
        return ((string_append (''c.lui'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__76
                           ((string_append ((sep_forwards () ))
                               ((string_append ((decimal_string_of_bits imm)) (''''))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  imm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (C_SRLI ((shamt, rsd))) = (
      if (((shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) then
        creg_name_forwards rsd \<bind> (\<lambda> (w__79 :: string) . 
        return ((string_append (''c.srli'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__79
                           ((string_append ((sep_forwards () ))
                               ((string_append ((decimal_string_of_bits shamt)) (''''))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsd  :: "(3)Word.word " 
  and  shamt  :: "(6)Word.word "
|" assembly_forwards (C_SRAI ((shamt, rsd))) = (
      if (((shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) then
        creg_name_forwards rsd \<bind> (\<lambda> (w__82 :: string) . 
        return ((string_append (''c.srai'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__82
                           ((string_append ((sep_forwards () ))
                               ((string_append ((decimal_string_of_bits shamt)) (''''))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsd  :: "(3)Word.word " 
  and  shamt  :: "(6)Word.word "
|" assembly_forwards (C_ANDI ((imm, rsd))) = (
      creg_name_forwards rsd \<bind> (\<lambda> (w__85 :: string) . 
      return ((string_append (''c.andi'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__85
                         ((string_append ((sep_forwards () ))
                             ((string_append ((decimal_string_of_bits imm)) ('''')))))))))))))" 
  for  rsd  :: "(3)Word.word " 
  and  imm  :: "(6)Word.word "
|" assembly_forwards (C_SUB ((rsd, rs2))) = (
      creg_name_forwards rsd \<bind> (\<lambda> (w__86 :: string) . 
      creg_name_forwards rs2 \<bind> (\<lambda> (w__87 :: string) . 
      return ((string_append (''c.sub'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__86
                         ((string_append ((sep_forwards () )) ((string_append w__87 (''''))))))))))))))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards (C_XOR ((rsd, rs2))) = (
      creg_name_forwards rsd \<bind> (\<lambda> (w__88 :: string) . 
      creg_name_forwards rs2 \<bind> (\<lambda> (w__89 :: string) . 
      return ((string_append (''c.xor'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__88
                         ((string_append ((sep_forwards () )) ((string_append w__89 (''''))))))))))))))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards (C_OR ((rsd, rs2))) = (
      creg_name_forwards rsd \<bind> (\<lambda> (w__90 :: string) . 
      creg_name_forwards rs2 \<bind> (\<lambda> (w__91 :: string) . 
      return ((string_append (''c.or'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__90
                         ((string_append ((sep_forwards () )) ((string_append w__91 (''''))))))))))))))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards (C_AND ((rsd, rs2))) = (
      creg_name_forwards rsd \<bind> (\<lambda> (w__92 :: string) . 
      creg_name_forwards rs2 \<bind> (\<lambda> (w__93 :: string) . 
      return ((string_append (''c.and'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__92
                         ((string_append ((sep_forwards () )) ((string_append w__93 (''''))))))))))))))" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards (C_SUBW ((rsd, rs2))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        creg_name_forwards rsd \<bind> (\<lambda> (w__94 :: string) . 
        creg_name_forwards rs2 \<bind> (\<lambda> (w__95 :: string) . 
        return ((string_append (''c.subw'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__94
                           ((string_append ((sep_forwards () )) ((string_append w__95 ('''')))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards (C_ADDW ((rsd, rs2))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        creg_name_forwards rsd \<bind> (\<lambda> (w__98 :: string) . 
        creg_name_forwards rs2 \<bind> (\<lambda> (w__99 :: string) . 
        return ((string_append (''c.addw'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__98
                           ((string_append ((sep_forwards () )) ((string_append w__99 ('''')))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards (C_J (imm)) = (
      return ((string_append (''c.j'')
                 ((string_append ((spc_forwards () ))
                     ((string_append ((decimal_string_of_bits imm)) (''''))))))))" 
  for  imm  :: "(11)Word.word "
|" assembly_forwards (C_BEQZ ((imm, rs))) = (
      creg_name_forwards rs \<bind> (\<lambda> (w__102 :: string) . 
      return ((string_append (''c.beqz'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__102
                         ((string_append ((sep_forwards () ))
                             ((string_append ((decimal_string_of_bits imm)) ('''')))))))))))))" 
  for  rs  :: "(3)Word.word " 
  and  imm  :: "(8)Word.word "
|" assembly_forwards (C_BNEZ ((imm, rs))) = (
      creg_name_forwards rs \<bind> (\<lambda> (w__103 :: string) . 
      return ((string_append (''c.bnez'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__103
                         ((string_append ((sep_forwards () ))
                             ((string_append ((decimal_string_of_bits imm)) ('''')))))))))))))" 
  for  rs  :: "(3)Word.word " 
  and  imm  :: "(8)Word.word "
|" assembly_forwards (C_SLLI ((shamt, rsd))) = (
      if ((((((shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg)))))))) then
        reg_name_forwards rsd \<bind> (\<lambda> (w__104 :: string) . 
        return ((string_append (''c.slli'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__104
                           ((string_append ((sep_forwards () ))
                               ((string_append ((decimal_string_of_bits shamt)) (''''))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsd  :: "(5)Word.word " 
  and  shamt  :: "(6)Word.word "
|" assembly_forwards (C_LWSP ((uimm, rd))) = (
      if (((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) then
        reg_name_forwards rd \<bind> (\<lambda> (w__107 :: string) . 
        return ((string_append (''c.lwsp'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__107
                           ((string_append ((sep_forwards () ))
                               ((string_append ((decimal_string_of_bits uimm)) (''''))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  uimm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (C_LDSP ((uimm, rd))) = (
      if ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))))
      then
        reg_name_forwards rd \<bind> (\<lambda> (w__110 :: string) . 
        return ((string_append (''c.ldsp'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__110
                           ((string_append ((sep_forwards () ))
                               ((string_append ((decimal_string_of_bits uimm)) (''''))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  uimm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (C_SWSP ((uimm, rd))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__113 :: string) . 
      return ((string_append (''c.swsp'')
                 ((string_append ((spc_forwards () ))
                     ((string_append w__113
                         ((string_append ((sep_forwards () ))
                             ((string_append ((decimal_string_of_bits uimm)) ('''')))))))))))))" 
  for  uimm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (C_SDSP ((uimm, rs2))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        reg_name_forwards rs2 \<bind> (\<lambda> (w__114 :: string) . 
        return ((string_append (''c.sdsp'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__114
                           ((string_append ((sep_forwards () ))
                               ((string_append ((decimal_string_of_bits uimm)) (''''))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  uimm  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|" assembly_forwards (C_JR (rs1)) = (
      if (((((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) then
        reg_name_forwards rs1 \<bind> (\<lambda> (w__117 :: string) . 
        return ((string_append (''c.jr'')
                   ((string_append ((spc_forwards () )) ((string_append w__117 (''''))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs1  :: "(5)Word.word "
|" assembly_forwards (C_JALR (rs1)) = (
      if (((((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) then
        reg_name_forwards rs1 \<bind> (\<lambda> (w__120 :: string) . 
        return ((string_append (''c.jalr'')
                   ((string_append ((spc_forwards () )) ((string_append w__120 (''''))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs1  :: "(5)Word.word "
|" assembly_forwards (C_MV ((rd, rs2))) = (
      if ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg)))))))) then
        reg_name_forwards rd \<bind> (\<lambda> (w__123 :: string) . 
        reg_name_forwards rs2 \<bind> (\<lambda> (w__124 :: string) . 
        return ((string_append (''c.mv'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__123
                           ((string_append ((sep_forwards () )) ((string_append w__124 ('''')))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (C_EBREAK (_)) = ( return (''c.ebreak''))"
|" assembly_forwards (C_ADD ((rsd, rs2))) = (
      if ((((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg)))))))) then
        reg_name_forwards rsd \<bind> (\<lambda> (w__127 :: string) . 
        reg_name_forwards rs2 \<bind> (\<lambda> (w__128 :: string) . 
        return ((string_append (''c.add'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__127
                           ((string_append ((sep_forwards () )) ((string_append w__128 ('''')))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rsd  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word "
|" assembly_forwards (MUL ((rs2, rs1, rd, high, signed1, signed2))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__131 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__132 :: string) . 
      reg_name_forwards rs2 \<bind> (\<lambda> (w__133 :: string) . 
      return ((string_append ((mul_mnemonic_forwards (high, signed1, signed2)))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__131
                         ((string_append ((sep_forwards () ))
                             ((string_append w__132
                                 ((string_append ((sep_forwards () )) ((string_append w__133 ('''')))))))))))))))))))" 
  for  signed2  :: " bool " 
  and  signed1  :: " bool " 
  and  high  :: " bool " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (DIV ((rs2, rs1, rd, s))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__134 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__135 :: string) . 
      reg_name_forwards rs2 \<bind> (\<lambda> (w__136 :: string) . 
      return ((string_append (''div'')
                 ((string_append ((maybe_not_u_forwards s))
                     ((string_append ((spc_forwards () ))
                         ((string_append w__134
                             ((string_append ((sep_forwards () ))
                                 ((string_append w__135
                                     ((string_append ((sep_forwards () )) ((string_append w__136 ('''')))))))))))))))))))))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" assembly_forwards (REM ((rs2, rs1, rd, s))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__137 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__138 :: string) . 
      reg_name_forwards rs2 \<bind> (\<lambda> (w__139 :: string) . 
      return ((string_append (''rem'')
                 ((string_append ((maybe_not_u_forwards s))
                     ((string_append ((spc_forwards () ))
                         ((string_append w__137
                             ((string_append ((sep_forwards () ))
                                 ((string_append w__138
                                     ((string_append ((sep_forwards () )) ((string_append w__139 ('''')))))))))))))))))))))" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" assembly_forwards (MULW ((rs2, rs1, rd))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        reg_name_forwards rd \<bind> (\<lambda> (w__140 :: string) . 
        reg_name_forwards rs1 \<bind> (\<lambda> (w__141 :: string) . 
        reg_name_forwards rs2 \<bind> (\<lambda> (w__142 :: string) . 
        return ((string_append (''mulw'')
                   ((string_append ((spc_forwards () ))
                       ((string_append w__140
                           ((string_append ((sep_forwards () ))
                               ((string_append w__141
                                   ((string_append ((sep_forwards () )) ((string_append w__142 (''''))))))))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards (DIVW ((rs2, rs1, rd, s))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        reg_name_forwards rd \<bind> (\<lambda> (w__145 :: string) . 
        reg_name_forwards rs1 \<bind> (\<lambda> (w__146 :: string) . 
        reg_name_forwards rs2 \<bind> (\<lambda> (w__147 :: string) . 
        return ((string_append (''div'')
                   ((string_append ((maybe_not_u_forwards s))
                       ((string_append (''w'')
                           ((string_append ((spc_forwards () ))
                               ((string_append w__145
                                   ((string_append ((sep_forwards () ))
                                       ((string_append w__146
                                           ((string_append ((sep_forwards () ))
                                               ((string_append w__147 (''''))))))))))))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" assembly_forwards (REMW ((rs2, rs1, rd, s))) = (
      if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then
        reg_name_forwards rd \<bind> (\<lambda> (w__150 :: string) . 
        reg_name_forwards rs1 \<bind> (\<lambda> (w__151 :: string) . 
        reg_name_forwards rs2 \<bind> (\<lambda> (w__152 :: string) . 
        return ((string_append (''rem'')
                   ((string_append ((maybe_not_u_forwards s))
                       ((string_append (''w'')
                           ((string_append ((spc_forwards () ))
                               ((string_append w__150
                                   ((string_append ((sep_forwards () ))
                                       ((string_append w__151
                                           ((string_append ((sep_forwards () ))
                                               ((string_append w__152 (''''))))))))))))))))))))))
      else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 ()  )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" assembly_forwards (CSR ((csr, rs1, rd, True, op1))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__155 :: string) . 
      csr_name_map_forwards csr \<bind> (\<lambda> (w__156 :: string) . 
      return ((string_append ((csr_mnemonic_forwards op1))
                 ((string_append (''i'')
                     ((string_append ((spc_forwards () ))
                         ((string_append w__155
                             ((string_append ((sep_forwards () ))
                                 ((string_append ((decimal_string_of_bits rs1))
                                     ((string_append ((sep_forwards () )) ((string_append w__156 (''''))))))))))))))))))))" 
  for  op1  :: " csrop " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  csr  :: "(12)Word.word "
|" assembly_forwards (CSR ((csr, rs1, rd, False, op1))) = (
      reg_name_forwards rd \<bind> (\<lambda> (w__157 :: string) . 
      reg_name_forwards rs1 \<bind> (\<lambda> (w__158 :: string) . 
      csr_name_map_forwards csr \<bind> (\<lambda> (w__159 :: string) . 
      return ((string_append ((csr_mnemonic_forwards op1))
                 ((string_append ((spc_forwards () ))
                     ((string_append w__157
                         ((string_append ((sep_forwards () ))
                             ((string_append w__158
                                 ((string_append ((sep_forwards () )) ((string_append w__159 ('''')))))))))))))))))))" 
  for  op1  :: " csrop " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  csr  :: "(12)Word.word "
|" assembly_forwards (URET (_)) = ( return (''uret''))"
|" assembly_forwards (ILLEGAL (s)) = (
      return ((string_append (''illegal'')
                 ((string_append ((spc_forwards () ))
                     ((string_append ((decimal_string_of_bits s)) (''''))))))))" 
  for  s  :: "(32)Word.word "
|" assembly_forwards (C_ILLEGAL (s)) = (
      return ((string_append (''c.illegal'')
                 ((string_append ((spc_forwards () ))
                     ((string_append ((decimal_string_of_bits s)) (''''))))))))" 
  for  s  :: "(16)Word.word "


\<comment> \<open>\<open>val assembly_backwards : string -> M ast\<close>\<close>

\<comment> \<open>\<open>val _s1677_ : string -> maybe (mword ty16)\<close>\<close>

definition s1677  :: " string \<Rightarrow>((16)Word.word)option "  where 
     " s1677 s16780 = (
   (let s16790 = s16780 in
   if ((string_startswith s16790 (''c.illegal''))) then  
  (case  ((string_drop s16790 ((string_length (''c.illegal''))))) of
        s16800 =>
  (case  ((spc_matches_prefix0 s16800)) of
        Some ((_, s16810)) =>
  (case  ((string_drop s16800 s16810)) of
        s16820 =>
  (case  ((hex_bits_16_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s16820 :: (( 16 Word.word * ii)) option)) of
        Some ((s, s16830)) =>
  (let p00 = (string_drop s16820 s16830) in
  if (((p00 = ('''')))) then Some s else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s16780  :: " string "


\<comment> \<open>\<open>val _s1669_ : string -> maybe (mword ty32)\<close>\<close>

definition s1669  :: " string \<Rightarrow>((32)Word.word)option "  where 
     " s1669 s16700 = (
   (let s16710 = s16700 in
   if ((string_startswith s16710 (''illegal''))) then  
  (case  ((string_drop s16710 ((string_length (''illegal''))))) of
        s16720 =>
  (case  ((spc_matches_prefix0 s16720)) of
        Some ((_, s16730)) =>
  (case  ((string_drop s16720 s16730)) of
        s16740 =>
  (case  ((hex_bits_32_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s16740 :: (( 32 Word.word * ii)) option)) of
        Some ((s, s16750)) =>
  (let p00 = (string_drop s16740 s16750) in
  if (((p00 = ('''')))) then Some s else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s16700  :: " string "


\<comment> \<open>\<open>val _s1652_ : string -> maybe ((csrop * mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s1652  :: " string \<Rightarrow>(csrop*(5)Word.word*(5)Word.word*(12)Word.word)option "  where 
     " s1652 s16540 = (
      (case  ((csr_mnemonic_matches_prefix s16540)) of
        Some ((op1, s16550)) => 
  (case  ((string_drop s16540 s16550)) of
        s16560 =>
  (case  ((spc_matches_prefix0 s16560)) of
        Some ((_, s16570)) =>
  (case  ((string_drop s16560 s16570)) of
        s16580 =>
  (case  ((reg_name_matches_prefix s16580 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s16590)) =>
  (case  ((string_drop s16580 s16590)) of
        s16600 =>
  (case  ((sep_matches_prefix s16600)) of
        Some ((_, s16610)) =>
  (case  ((string_drop s16600 s16610)) of
        s16620 =>
  (case  ((reg_name_matches_prefix s16620 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s16630)) =>
  (case  ((string_drop s16620 s16630)) of
        s16640 =>
  (case  ((sep_matches_prefix s16640)) of
        Some ((_, s16650)) =>
  (case  ((string_drop s16640 s16650)) of
        s16660 =>
  (case  ((csr_name_map_matches_prefix s16660
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s16670)) =>
  (let p00 = (string_drop s16660 s16670) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, csr) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s16540  :: " string "


\<comment> \<open>\<open>val _s1634_ : string -> maybe ((csrop * mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s1634  :: " string \<Rightarrow>(csrop*(5)Word.word*(5)Word.word*(12)Word.word)option "  where 
     " s1634 s16360 = (
      (case  ((csr_mnemonic_matches_prefix s16360)) of
        Some ((op1, s16370)) =>
         (let s16380 = (string_drop s16360 s16370) in
         if ((string_startswith s16380 (''i''))) then  
  (case  ((string_drop s16380 ((string_length (''i''))))) of
        s16390 =>
  (case  ((spc_matches_prefix0 s16390)) of
        Some ((_, s16400)) =>
  (case  ((string_drop s16390 s16400)) of
        s16410 =>
  (case  ((reg_name_matches_prefix s16410 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s16420)) =>
  (case  ((string_drop s16410 s16420)) of
        s16430 =>
  (case  ((sep_matches_prefix s16430)) of
        Some ((_, s16440)) =>
  (case  ((string_drop s16430 s16440)) of
        s16450 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s16450 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s16460)) =>
  (case  ((string_drop s16450 s16460)) of
        s16470 =>
  (case  ((sep_matches_prefix s16470)) of
        Some ((_, s16480)) =>
  (case  ((string_drop s16470 s16480)) of
        s16490 =>
  (case  ((csr_name_map_matches_prefix s16490
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s16500)) =>
  (let p00 = (string_drop s16490 s16500) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, csr) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))" 
  for  s16360  :: " string "


\<comment> \<open>\<open>val _s1615_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1615  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1615 s16160 = (
   (let s16170 = s16160 in
   if ((string_startswith s16170 (''rem''))) then  
  (case  ((string_drop s16170 ((string_length (''rem''))))) of
        s16180 =>
  (case  ((maybe_not_u_matches_prefix s16180)) of
        Some ((s, s16190)) =>
  (let s16200 = (string_drop s16180 s16190) in
  if ((string_startswith s16200 (''w''))) then
    (case  ((string_drop s16200 ((string_length (''w''))))) of
          s16210 =>
    (case  ((spc_matches_prefix0 s16210)) of
          Some ((_, s16220)) =>
    (case  ((string_drop s16210 s16220)) of
          s16230 =>
    (case  ((reg_name_matches_prefix s16230 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s16240)) =>
    (case  ((string_drop s16230 s16240)) of
          s16250 =>
    (case  ((sep_matches_prefix s16250)) of
          Some ((_, s16260)) =>
    (case  ((string_drop s16250 s16260)) of
          s16270 =>
    (case  ((reg_name_matches_prefix s16270 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s16280)) =>
    (case  ((string_drop s16270 s16280)) of
          s16290 =>
    (case  ((sep_matches_prefix s16290)) of
          Some ((_, s16300)) =>
    (case  ((string_drop s16290 s16300)) of
          s16310 =>
    (case  ((reg_name_matches_prefix s16310 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s16320)) =>
    (let p00 = (string_drop s16310 s16320) in
    if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))" 
  for  s16160  :: " string "


\<comment> \<open>\<open>val _s1596_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1596  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1596 s15970 = (
   (let s15980 = s15970 in
   if ((string_startswith s15980 (''div''))) then  
  (case  ((string_drop s15980 ((string_length (''div''))))) of
        s15990 =>
  (case  ((maybe_not_u_matches_prefix s15990)) of
        Some ((s, s16000)) =>
  (let s16010 = (string_drop s15990 s16000) in
  if ((string_startswith s16010 (''w''))) then
    (case  ((string_drop s16010 ((string_length (''w''))))) of
          s16020 =>
    (case  ((spc_matches_prefix0 s16020)) of
          Some ((_, s16030)) =>
    (case  ((string_drop s16020 s16030)) of
          s16040 =>
    (case  ((reg_name_matches_prefix s16040 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s16050)) =>
    (case  ((string_drop s16040 s16050)) of
          s16060 =>
    (case  ((sep_matches_prefix s16060)) of
          Some ((_, s16070)) =>
    (case  ((string_drop s16060 s16070)) of
          s16080 =>
    (case  ((reg_name_matches_prefix s16080 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s16090)) =>
    (case  ((string_drop s16080 s16090)) of
          s16100 =>
    (case  ((sep_matches_prefix s16100)) of
          Some ((_, s16110)) =>
    (case  ((string_drop s16100 s16110)) of
          s16120 =>
    (case  ((reg_name_matches_prefix s16120 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s16130)) =>
    (let p00 = (string_drop s16120 s16130) in
    if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))" 
  for  s15970  :: " string "


\<comment> \<open>\<open>val _s1580_ : string -> maybe ((mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1580  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1580 s15810 = (
   (let s15820 = s15810 in
   if ((string_startswith s15820 (''mulw''))) then  
  (case  ((string_drop s15820 ((string_length (''mulw''))))) of
        s15830 =>
  (case  ((spc_matches_prefix0 s15830)) of
        Some ((_, s15840)) =>
  (case  ((string_drop s15830 s15840)) of
        s15850 =>
  (case  ((reg_name_matches_prefix s15850 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s15860)) =>
  (case  ((string_drop s15850 s15860)) of
        s15870 =>
  (case  ((sep_matches_prefix s15870)) of
        Some ((_, s15880)) =>
  (case  ((string_drop s15870 s15880)) of
        s15890 =>
  (case  ((reg_name_matches_prefix s15890 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s15900)) =>
  (case  ((string_drop s15890 s15900)) of
        s15910 =>
  (case  ((sep_matches_prefix s15910)) of
        Some ((_, s15920)) =>
  (case  ((string_drop s15910 s15920)) of
        s15930 =>
  (case  ((reg_name_matches_prefix s15930 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s15940)) =>
  (let p00 = (string_drop s15930 s15940) in
  if (((p00 = ('''')))) then Some (rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s15810  :: " string "


\<comment> \<open>\<open>val _s1562_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1562  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1562 s15630 = (
   (let s15640 = s15630 in
   if ((string_startswith s15640 (''rem''))) then  
  (case  ((string_drop s15640 ((string_length (''rem''))))) of
        s15650 =>
  (case  ((maybe_not_u_matches_prefix s15650)) of
        Some ((s, s15660)) =>
  (case  ((string_drop s15650 s15660)) of
        s15670 =>
  (case  ((spc_matches_prefix0 s15670)) of
        Some ((_, s15680)) =>
  (case  ((string_drop s15670 s15680)) of
        s15690 =>
  (case  ((reg_name_matches_prefix s15690 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s15700)) =>
  (case  ((string_drop s15690 s15700)) of
        s15710 =>
  (case  ((sep_matches_prefix s15710)) of
        Some ((_, s15720)) =>
  (case  ((string_drop s15710 s15720)) of
        s15730 =>
  (case  ((reg_name_matches_prefix s15730 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s15740)) =>
  (case  ((string_drop s15730 s15740)) of
        s15750 =>
  (case  ((sep_matches_prefix s15750)) of
        Some ((_, s15760)) =>
  (case  ((string_drop s15750 s15760)) of
        s15770 =>
  (case  ((reg_name_matches_prefix s15770 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s15780)) =>
  (let p00 = (string_drop s15770 s15780) in
  if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s15630  :: " string "


\<comment> \<open>\<open>val _s1544_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1544  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1544 s15450 = (
   (let s15460 = s15450 in
   if ((string_startswith s15460 (''div''))) then  
  (case  ((string_drop s15460 ((string_length (''div''))))) of
        s15470 =>
  (case  ((maybe_not_u_matches_prefix s15470)) of
        Some ((s, s15480)) =>
  (case  ((string_drop s15470 s15480)) of
        s15490 =>
  (case  ((spc_matches_prefix0 s15490)) of
        Some ((_, s15500)) =>
  (case  ((string_drop s15490 s15500)) of
        s15510 =>
  (case  ((reg_name_matches_prefix s15510 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s15520)) =>
  (case  ((string_drop s15510 s15520)) of
        s15530 =>
  (case  ((sep_matches_prefix s15530)) of
        Some ((_, s15540)) =>
  (case  ((string_drop s15530 s15540)) of
        s15550 =>
  (case  ((reg_name_matches_prefix s15550 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s15560)) =>
  (case  ((string_drop s15550 s15560)) of
        s15570 =>
  (case  ((sep_matches_prefix s15570)) of
        Some ((_, s15580)) =>
  (case  ((string_drop s15570 s15580)) of
        s15590 =>
  (case  ((reg_name_matches_prefix s15590 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s15600)) =>
  (let p00 = (string_drop s15590 s15600) in
  if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s15450  :: " string "


\<comment> \<open>\<open>val _s1527_ : string -> maybe ((bool * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1527  :: " string \<Rightarrow>(bool*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1527 s15290 = (
      (case  ((mul_mnemonic_matches_prefix s15290)) of
        Some (((high, signed1, signed2), s15300)) => 
  (case  ((string_drop s15290 s15300)) of
        s15310 =>
  (case  ((spc_matches_prefix0 s15310)) of
        Some ((_, s15320)) =>
  (case  ((string_drop s15310 s15320)) of
        s15330 =>
  (case  ((reg_name_matches_prefix s15330 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s15340)) =>
  (case  ((string_drop s15330 s15340)) of
        s15350 =>
  (case  ((sep_matches_prefix s15350)) of
        Some ((_, s15360)) =>
  (case  ((string_drop s15350 s15360)) of
        s15370 =>
  (case  ((reg_name_matches_prefix s15370 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s15380)) =>
  (case  ((string_drop s15370 s15380)) of
        s15390 =>
  (case  ((sep_matches_prefix s15390)) of
        Some ((_, s15400)) =>
  (case  ((string_drop s15390 s15400)) of
        s15410 =>
  (case  ((reg_name_matches_prefix s15410 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s15420)) =>
  (let p00 = (string_drop s15410 s15420) in
  if (((p00 = ('''')))) then Some (high, signed1, signed2, rd, rs1, rs2) else
    None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s15290  :: " string "


\<comment> \<open>\<open>val _s1515_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s1515  :: " string \<Rightarrow>((5)Word.word*(5)Word.word)option "  where 
     " s1515 s15160 = (
   (let s15170 = s15160 in
   if ((string_startswith s15170 (''c.add''))) then  
  (case  ((string_drop s15170 ((string_length (''c.add''))))) of
        s15180 =>
  (case  ((spc_matches_prefix0 s15180)) of
        Some ((_, s15190)) =>
  (case  ((string_drop s15180 s15190)) of
        s15200 =>
  (case  ((reg_name_matches_prefix s15200 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s15210)) =>
  (case  ((string_drop s15200 s15210)) of
        s15220 =>
  (case  ((sep_matches_prefix s15220)) of
        Some ((_, s15230)) =>
  (case  ((string_drop s15220 s15230)) of
        s15240 =>
  (case  ((reg_name_matches_prefix s15240 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s15250)) =>
  (let p00 = (string_drop s15240 s15250) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s15160  :: " string "


\<comment> \<open>\<open>val _s1503_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s1503  :: " string \<Rightarrow>((5)Word.word*(5)Word.word)option "  where 
     " s1503 s15040 = (
   (let s15050 = s15040 in
   if ((string_startswith s15050 (''c.mv''))) then  
  (case  ((string_drop s15050 ((string_length (''c.mv''))))) of
        s15060 =>
  (case  ((spc_matches_prefix0 s15060)) of
        Some ((_, s15070)) =>
  (case  ((string_drop s15060 s15070)) of
        s15080 =>
  (case  ((reg_name_matches_prefix s15080 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s15090)) =>
  (case  ((string_drop s15080 s15090)) of
        s15100 =>
  (case  ((sep_matches_prefix s15100)) of
        Some ((_, s15110)) =>
  (case  ((string_drop s15100 s15110)) of
        s15120 =>
  (case  ((reg_name_matches_prefix s15120 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s15130)) =>
  (let p00 = (string_drop s15120 s15130) in
  if (((p00 = ('''')))) then Some (rd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s15040  :: " string "


\<comment> \<open>\<open>val _s1495_ : string -> maybe (mword ty5)\<close>\<close>

definition s1495  :: " string \<Rightarrow>((5)Word.word)option "  where 
     " s1495 s14960 = (
   (let s14970 = s14960 in
   if ((string_startswith s14970 (''c.jalr''))) then  
  (case  ((string_drop s14970 ((string_length (''c.jalr''))))) of
        s14980 =>
  (case  ((spc_matches_prefix0 s14980)) of
        Some ((_, s14990)) =>
  (case  ((string_drop s14980 s14990)) of
        s15000 =>
  (case  ((reg_name_matches_prefix s15000 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s15010)) =>
  (let p00 = (string_drop s15000 s15010) in
  if (((p00 = ('''')))) then Some rs1 else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s14960  :: " string "


\<comment> \<open>\<open>val _s1487_ : string -> maybe (mword ty5)\<close>\<close>

definition s1487  :: " string \<Rightarrow>((5)Word.word)option "  where 
     " s1487 s14880 = (
   (let s14890 = s14880 in
   if ((string_startswith s14890 (''c.jr''))) then  
  (case  ((string_drop s14890 ((string_length (''c.jr''))))) of
        s14900 =>
  (case  ((spc_matches_prefix0 s14900)) of
        Some ((_, s14910)) =>
  (case  ((string_drop s14900 s14910)) of
        s14920 =>
  (case  ((reg_name_matches_prefix s14920 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s14930)) =>
  (let p00 = (string_drop s14920 s14930) in
  if (((p00 = ('''')))) then Some rs1 else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s14880  :: " string "


\<comment> \<open>\<open>val _s1475_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1475  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s1475 s14760 = (
   (let s14770 = s14760 in
   if ((string_startswith s14770 (''c.sdsp''))) then  
  (case  ((string_drop s14770 ((string_length (''c.sdsp''))))) of
        s14780 =>
  (case  ((spc_matches_prefix0 s14780)) of
        Some ((_, s14790)) =>
  (case  ((string_drop s14780 s14790)) of
        s14800 =>
  (case  ((reg_name_matches_prefix s14800 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s14810)) =>
  (case  ((string_drop s14800 s14810)) of
        s14820 =>
  (case  ((sep_matches_prefix s14820)) of
        Some ((_, s14830)) =>
  (case  ((string_drop s14820 s14830)) of
        s14840 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s14840 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s14850)) =>
  (let p00 = (string_drop s14840 s14850) in
  if (((p00 = ('''')))) then Some (rs2, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s14760  :: " string "


\<comment> \<open>\<open>val _s1463_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1463  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s1463 s14640 = (
   (let s14650 = s14640 in
   if ((string_startswith s14650 (''c.swsp''))) then  
  (case  ((string_drop s14650 ((string_length (''c.swsp''))))) of
        s14660 =>
  (case  ((spc_matches_prefix0 s14660)) of
        Some ((_, s14670)) =>
  (case  ((string_drop s14660 s14670)) of
        s14680 =>
  (case  ((reg_name_matches_prefix s14680 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s14690)) =>
  (case  ((string_drop s14680 s14690)) of
        s14700 =>
  (case  ((sep_matches_prefix s14700)) of
        Some ((_, s14710)) =>
  (case  ((string_drop s14700 s14710)) of
        s14720 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s14720 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s14730)) =>
  (let p00 = (string_drop s14720 s14730) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s14640  :: " string "


\<comment> \<open>\<open>val _s1451_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1451  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s1451 s14520 = (
   (let s14530 = s14520 in
   if ((string_startswith s14530 (''c.ldsp''))) then  
  (case  ((string_drop s14530 ((string_length (''c.ldsp''))))) of
        s14540 =>
  (case  ((spc_matches_prefix0 s14540)) of
        Some ((_, s14550)) =>
  (case  ((string_drop s14540 s14550)) of
        s14560 =>
  (case  ((reg_name_matches_prefix s14560 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s14570)) =>
  (case  ((string_drop s14560 s14570)) of
        s14580 =>
  (case  ((sep_matches_prefix s14580)) of
        Some ((_, s14590)) =>
  (case  ((string_drop s14580 s14590)) of
        s14600 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s14600 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s14610)) =>
  (let p00 = (string_drop s14600 s14610) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s14520  :: " string "


\<comment> \<open>\<open>val _s1439_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1439  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s1439 s14400 = (
   (let s14410 = s14400 in
   if ((string_startswith s14410 (''c.lwsp''))) then  
  (case  ((string_drop s14410 ((string_length (''c.lwsp''))))) of
        s14420 =>
  (case  ((spc_matches_prefix0 s14420)) of
        Some ((_, s14430)) =>
  (case  ((string_drop s14420 s14430)) of
        s14440 =>
  (case  ((reg_name_matches_prefix s14440 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s14450)) =>
  (case  ((string_drop s14440 s14450)) of
        s14460 =>
  (case  ((sep_matches_prefix s14460)) of
        Some ((_, s14470)) =>
  (case  ((string_drop s14460 s14470)) of
        s14480 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s14480 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s14490)) =>
  (let p00 = (string_drop s14480 s14490) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s14400  :: " string "


\<comment> \<open>\<open>val _s1427_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1427  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s1427 s14280 = (
   (let s14290 = s14280 in
   if ((string_startswith s14290 (''c.slli''))) then  
  (case  ((string_drop s14290 ((string_length (''c.slli''))))) of
        s14300 =>
  (case  ((spc_matches_prefix0 s14300)) of
        Some ((_, s14310)) =>
  (case  ((string_drop s14300 s14310)) of
        s14320 =>
  (case  ((reg_name_matches_prefix s14320 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s14330)) =>
  (case  ((string_drop s14320 s14330)) of
        s14340 =>
  (case  ((sep_matches_prefix s14340)) of
        Some ((_, s14350)) =>
  (case  ((string_drop s14340 s14350)) of
        s14360 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s14360 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s14370)) =>
  (let p00 = (string_drop s14360 s14370) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s14280  :: " string "


\<comment> \<open>\<open>val _s1415_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s1415  :: " string \<Rightarrow>((3)Word.word*(8)Word.word)option "  where 
     " s1415 s14160 = (
   (let s14170 = s14160 in
   if ((string_startswith s14170 (''c.bnez''))) then  
  (case  ((string_drop s14170 ((string_length (''c.bnez''))))) of
        s14180 =>
  (case  ((spc_matches_prefix0 s14180)) of
        Some ((_, s14190)) =>
  (case  ((string_drop s14180 s14190)) of
        s14200 =>
  (case  ((creg_name_matches_prefix s14200 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s14210)) =>
  (case  ((string_drop s14200 s14210)) of
        s14220 =>
  (case  ((sep_matches_prefix s14220)) of
        Some ((_, s14230)) =>
  (case  ((string_drop s14220 s14230)) of
        s14240 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s14240 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s14250)) =>
  (let p00 = (string_drop s14240 s14250) in
  if (((p00 = ('''')))) then Some (rs, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s14160  :: " string "


\<comment> \<open>\<open>val _s1403_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s1403  :: " string \<Rightarrow>((3)Word.word*(8)Word.word)option "  where 
     " s1403 s14040 = (
   (let s14050 = s14040 in
   if ((string_startswith s14050 (''c.beqz''))) then  
  (case  ((string_drop s14050 ((string_length (''c.beqz''))))) of
        s14060 =>
  (case  ((spc_matches_prefix0 s14060)) of
        Some ((_, s14070)) =>
  (case  ((string_drop s14060 s14070)) of
        s14080 =>
  (case  ((creg_name_matches_prefix s14080 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s14090)) =>
  (case  ((string_drop s14080 s14090)) of
        s14100 =>
  (case  ((sep_matches_prefix s14100)) of
        Some ((_, s14110)) =>
  (case  ((string_drop s14100 s14110)) of
        s14120 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s14120 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s14130)) =>
  (let p00 = (string_drop s14120 s14130) in
  if (((p00 = ('''')))) then Some (rs, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s14040  :: " string "


\<comment> \<open>\<open>val _s1395_ : string -> maybe (mword ty11)\<close>\<close>

definition s1395  :: " string \<Rightarrow>((11)Word.word)option "  where 
     " s1395 s13960 = (
   (let s13970 = s13960 in
   if ((string_startswith s13970 (''c.j''))) then  
  (case  ((string_drop s13970 ((string_length (''c.j''))))) of
        s13980 =>
  (case  ((spc_matches_prefix0 s13980)) of
        Some ((_, s13990)) =>
  (case  ((string_drop s13980 s13990)) of
        s14000 =>
  (case  ((hex_bits_11_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s14000 :: (( 11 Word.word * ii)) option)) of
        Some ((imm, s14010)) =>
  (let p00 = (string_drop s14000 s14010) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s13960  :: " string "


\<comment> \<open>\<open>val _s1383_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1383  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s1383 s13840 = (
   (let s13850 = s13840 in
   if ((string_startswith s13850 (''c.addw''))) then  
  (case  ((string_drop s13850 ((string_length (''c.addw''))))) of
        s13860 =>
  (case  ((spc_matches_prefix0 s13860)) of
        Some ((_, s13870)) =>
  (case  ((string_drop s13860 s13870)) of
        s13880 =>
  (case  ((creg_name_matches_prefix s13880 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s13890)) =>
  (case  ((string_drop s13880 s13890)) of
        s13900 =>
  (case  ((sep_matches_prefix s13900)) of
        Some ((_, s13910)) =>
  (case  ((string_drop s13900 s13910)) of
        s13920 =>
  (case  ((creg_name_matches_prefix s13920 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s13930)) =>
  (let p00 = (string_drop s13920 s13930) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s13840  :: " string "


\<comment> \<open>\<open>val _s1371_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1371  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s1371 s13720 = (
   (let s13730 = s13720 in
   if ((string_startswith s13730 (''c.subw''))) then  
  (case  ((string_drop s13730 ((string_length (''c.subw''))))) of
        s13740 =>
  (case  ((spc_matches_prefix0 s13740)) of
        Some ((_, s13750)) =>
  (case  ((string_drop s13740 s13750)) of
        s13760 =>
  (case  ((creg_name_matches_prefix s13760 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s13770)) =>
  (case  ((string_drop s13760 s13770)) of
        s13780 =>
  (case  ((sep_matches_prefix s13780)) of
        Some ((_, s13790)) =>
  (case  ((string_drop s13780 s13790)) of
        s13800 =>
  (case  ((creg_name_matches_prefix s13800 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s13810)) =>
  (let p00 = (string_drop s13800 s13810) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s13720  :: " string "


\<comment> \<open>\<open>val _s1359_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1359  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s1359 s13600 = (
   (let s13610 = s13600 in
   if ((string_startswith s13610 (''c.and''))) then  
  (case  ((string_drop s13610 ((string_length (''c.and''))))) of
        s13620 =>
  (case  ((spc_matches_prefix0 s13620)) of
        Some ((_, s13630)) =>
  (case  ((string_drop s13620 s13630)) of
        s13640 =>
  (case  ((creg_name_matches_prefix s13640 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s13650)) =>
  (case  ((string_drop s13640 s13650)) of
        s13660 =>
  (case  ((sep_matches_prefix s13660)) of
        Some ((_, s13670)) =>
  (case  ((string_drop s13660 s13670)) of
        s13680 =>
  (case  ((creg_name_matches_prefix s13680 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s13690)) =>
  (let p00 = (string_drop s13680 s13690) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s13600  :: " string "


\<comment> \<open>\<open>val _s1347_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1347  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s1347 s13480 = (
   (let s13490 = s13480 in
   if ((string_startswith s13490 (''c.or''))) then  
  (case  ((string_drop s13490 ((string_length (''c.or''))))) of
        s13500 =>
  (case  ((spc_matches_prefix0 s13500)) of
        Some ((_, s13510)) =>
  (case  ((string_drop s13500 s13510)) of
        s13520 =>
  (case  ((creg_name_matches_prefix s13520 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s13530)) =>
  (case  ((string_drop s13520 s13530)) of
        s13540 =>
  (case  ((sep_matches_prefix s13540)) of
        Some ((_, s13550)) =>
  (case  ((string_drop s13540 s13550)) of
        s13560 =>
  (case  ((creg_name_matches_prefix s13560 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s13570)) =>
  (let p00 = (string_drop s13560 s13570) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s13480  :: " string "


\<comment> \<open>\<open>val _s1335_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1335  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s1335 s13360 = (
   (let s13370 = s13360 in
   if ((string_startswith s13370 (''c.xor''))) then  
  (case  ((string_drop s13370 ((string_length (''c.xor''))))) of
        s13380 =>
  (case  ((spc_matches_prefix0 s13380)) of
        Some ((_, s13390)) =>
  (case  ((string_drop s13380 s13390)) of
        s13400 =>
  (case  ((creg_name_matches_prefix s13400 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s13410)) =>
  (case  ((string_drop s13400 s13410)) of
        s13420 =>
  (case  ((sep_matches_prefix s13420)) of
        Some ((_, s13430)) =>
  (case  ((string_drop s13420 s13430)) of
        s13440 =>
  (case  ((creg_name_matches_prefix s13440 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s13450)) =>
  (let p00 = (string_drop s13440 s13450) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s13360  :: " string "


\<comment> \<open>\<open>val _s1323_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s1323  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s1323 s13240 = (
   (let s13250 = s13240 in
   if ((string_startswith s13250 (''c.sub''))) then  
  (case  ((string_drop s13250 ((string_length (''c.sub''))))) of
        s13260 =>
  (case  ((spc_matches_prefix0 s13260)) of
        Some ((_, s13270)) =>
  (case  ((string_drop s13260 s13270)) of
        s13280 =>
  (case  ((creg_name_matches_prefix s13280 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s13290)) =>
  (case  ((string_drop s13280 s13290)) of
        s13300 =>
  (case  ((sep_matches_prefix s13300)) of
        Some ((_, s13310)) =>
  (case  ((string_drop s13300 s13310)) of
        s13320 =>
  (case  ((creg_name_matches_prefix s13320 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s13330)) =>
  (let p00 = (string_drop s13320 s13330) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s13240  :: " string "


\<comment> \<open>\<open>val _s1311_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s1311  :: " string \<Rightarrow>((3)Word.word*(6)Word.word)option "  where 
     " s1311 s13120 = (
   (let s13130 = s13120 in
   if ((string_startswith s13130 (''c.andi''))) then  
  (case  ((string_drop s13130 ((string_length (''c.andi''))))) of
        s13140 =>
  (case  ((spc_matches_prefix0 s13140)) of
        Some ((_, s13150)) =>
  (case  ((string_drop s13140 s13150)) of
        s13160 =>
  (case  ((creg_name_matches_prefix s13160 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s13170)) =>
  (case  ((string_drop s13160 s13170)) of
        s13180 =>
  (case  ((sep_matches_prefix s13180)) of
        Some ((_, s13190)) =>
  (case  ((string_drop s13180 s13190)) of
        s13200 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s13200 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s13210)) =>
  (let p00 = (string_drop s13200 s13210) in
  if (((p00 = ('''')))) then Some (rsd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s13120  :: " string "


\<comment> \<open>\<open>val _s1299_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s1299  :: " string \<Rightarrow>((3)Word.word*(6)Word.word)option "  where 
     " s1299 s13000 = (
   (let s13010 = s13000 in
   if ((string_startswith s13010 (''c.srai''))) then  
  (case  ((string_drop s13010 ((string_length (''c.srai''))))) of
        s13020 =>
  (case  ((spc_matches_prefix0 s13020)) of
        Some ((_, s13030)) =>
  (case  ((string_drop s13020 s13030)) of
        s13040 =>
  (case  ((creg_name_matches_prefix s13040 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s13050)) =>
  (case  ((string_drop s13040 s13050)) of
        s13060 =>
  (case  ((sep_matches_prefix s13060)) of
        Some ((_, s13070)) =>
  (case  ((string_drop s13060 s13070)) of
        s13080 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s13080 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s13090)) =>
  (let p00 = (string_drop s13080 s13090) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s13000  :: " string "


\<comment> \<open>\<open>val _s1287_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s1287  :: " string \<Rightarrow>((3)Word.word*(6)Word.word)option "  where 
     " s1287 s12880 = (
   (let s12890 = s12880 in
   if ((string_startswith s12890 (''c.srli''))) then  
  (case  ((string_drop s12890 ((string_length (''c.srli''))))) of
        s12900 =>
  (case  ((spc_matches_prefix0 s12900)) of
        Some ((_, s12910)) =>
  (case  ((string_drop s12900 s12910)) of
        s12920 =>
  (case  ((creg_name_matches_prefix s12920 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s12930)) =>
  (case  ((string_drop s12920 s12930)) of
        s12940 =>
  (case  ((sep_matches_prefix s12940)) of
        Some ((_, s12950)) =>
  (case  ((string_drop s12940 s12950)) of
        s12960 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s12960 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s12970)) =>
  (let p00 = (string_drop s12960 s12970) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s12880  :: " string "


\<comment> \<open>\<open>val _s1275_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1275  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s1275 s12760 = (
   (let s12770 = s12760 in
   if ((string_startswith s12770 (''c.lui''))) then  
  (case  ((string_drop s12770 ((string_length (''c.lui''))))) of
        s12780 =>
  (case  ((spc_matches_prefix0 s12780)) of
        Some ((_, s12790)) =>
  (case  ((string_drop s12780 s12790)) of
        s12800 =>
  (case  ((reg_name_matches_prefix s12800 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s12810)) =>
  (case  ((string_drop s12800 s12810)) of
        s12820 =>
  (case  ((sep_matches_prefix s12820)) of
        Some ((_, s12830)) =>
  (case  ((string_drop s12820 s12830)) of
        s12840 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s12840 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s12850)) =>
  (let p00 = (string_drop s12840 s12850) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s12760  :: " string "


\<comment> \<open>\<open>val _s1267_ : string -> maybe (mword ty6)\<close>\<close>

definition s1267  :: " string \<Rightarrow>((6)Word.word)option "  where 
     " s1267 s12680 = (
   (let s12690 = s12680 in
   if ((string_startswith s12690 (''c.addi16sp''))) then  
  (case  ((string_drop s12690 ((string_length (''c.addi16sp''))))) of
        s12700 =>
  (case  ((spc_matches_prefix0 s12700)) of
        Some ((_, s12710)) =>
  (case  ((string_drop s12700 s12710)) of
        s12720 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s12720 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s12730)) =>
  (let p00 = (string_drop s12720 s12730) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s12680  :: " string "


\<comment> \<open>\<open>val _s1255_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1255  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s1255 s12560 = (
   (let s12570 = s12560 in
   if ((string_startswith s12570 (''c.li''))) then  
  (case  ((string_drop s12570 ((string_length (''c.li''))))) of
        s12580 =>
  (case  ((spc_matches_prefix0 s12580)) of
        Some ((_, s12590)) =>
  (case  ((string_drop s12580 s12590)) of
        s12600 =>
  (case  ((reg_name_matches_prefix s12600 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s12610)) =>
  (case  ((string_drop s12600 s12610)) of
        s12620 =>
  (case  ((sep_matches_prefix s12620)) of
        Some ((_, s12630)) =>
  (case  ((string_drop s12620 s12630)) of
        s12640 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s12640 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s12650)) =>
  (let p00 = (string_drop s12640 s12650) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s12560  :: " string "


\<comment> \<open>\<open>val _s1243_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1243  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s1243 s12440 = (
   (let s12450 = s12440 in
   if ((string_startswith s12450 (''c.addiw''))) then  
  (case  ((string_drop s12450 ((string_length (''c.addiw''))))) of
        s12460 =>
  (case  ((spc_matches_prefix0 s12460)) of
        Some ((_, s12470)) =>
  (case  ((string_drop s12460 s12470)) of
        s12480 =>
  (case  ((reg_name_matches_prefix s12480 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s12490)) =>
  (case  ((string_drop s12480 s12490)) of
        s12500 =>
  (case  ((sep_matches_prefix s12500)) of
        Some ((_, s12510)) =>
  (case  ((string_drop s12500 s12510)) of
        s12520 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s12520 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s12530)) =>
  (let p00 = (string_drop s12520 s12530) in
  if (((p00 = ('''')))) then Some (rsd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s12440  :: " string "


\<comment> \<open>\<open>val _s1235_ : string -> maybe (mword ty11)\<close>\<close>

definition s1235  :: " string \<Rightarrow>((11)Word.word)option "  where 
     " s1235 s12360 = (
   (let s12370 = s12360 in
   if ((string_startswith s12370 (''c.jal''))) then  
  (case  ((string_drop s12370 ((string_length (''c.jal''))))) of
        s12380 =>
  (case  ((spc_matches_prefix0 s12380)) of
        Some ((_, s12390)) =>
  (case  ((string_drop s12380 s12390)) of
        s12400 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s12400 :: (( 12 Word.word * ii)) option)) of
        Some ((v__802, s12410)) =>
  if (((((subrange_vec_dec v__802 (( 0 :: int):: ii) (( 0 :: int):: ii) :: 1 Word.word))
          = (vec_of_bits [B0] :: 1 Word.word)))) then
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__802
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__802
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (let p00 = (string_drop s12400 s12410) in
    if (((p00 = ('''')))) then Some imm else None))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s12360  :: " string "


\<comment> \<open>\<open>val _s1223_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s1223  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s1223 s12240 = (
   (let s12250 = s12240 in
   if ((string_startswith s12250 (''c.addi''))) then  
  (case  ((string_drop s12250 ((string_length (''c.addi''))))) of
        s12260 =>
  (case  ((spc_matches_prefix0 s12260)) of
        Some ((_, s12270)) =>
  (case  ((string_drop s12260 s12270)) of
        s12280 =>
  (case  ((reg_name_matches_prefix s12280 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s12290)) =>
  (case  ((string_drop s12280 s12290)) of
        s12300 =>
  (case  ((sep_matches_prefix s12300)) of
        Some ((_, s12310)) =>
  (case  ((string_drop s12300 s12310)) of
        s12320 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s12320 :: (( 6 Word.word * ii)) option)) of
        Some ((nzi, s12330)) =>
  (let p00 = (string_drop s12320 s12330) in
  if (((p00 = ('''')))) then Some (rsd, nzi) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s12240  :: " string "


\<comment> \<open>\<open>val _s1207_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s1207  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option "  where 
     " s1207 s12080 = (
   (let s12090 = s12080 in
   if ((string_startswith s12090 (''c.sd''))) then  
  (case  ((string_drop s12090 ((string_length (''c.sd''))))) of
        s12100 =>
  (case  ((spc_matches_prefix0 s12100)) of
        Some ((_, s12110)) =>
  (case  ((string_drop s12100 s12110)) of
        s12120 =>
  (case  ((creg_name_matches_prefix s12120 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s12130)) =>
  (case  ((string_drop s12120 s12130)) of
        s12140 =>
  (case  ((sep_matches_prefix s12140)) of
        Some ((_, s12150)) =>
  (case  ((string_drop s12140 s12150)) of
        s12160 =>
  (case  ((creg_name_matches_prefix s12160 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s12170)) =>
  (case  ((string_drop s12160 s12170)) of
        s12180 =>
  (case  ((sep_matches_prefix s12180)) of
        Some ((_, s12190)) =>
  (case  ((string_drop s12180 s12190)) of
        s12200 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s12200 :: (( 8 Word.word * ii)) option)) of
        Some ((v__804, s12210)) =>
  if (((((subrange_vec_dec v__804 (( 2 :: int):: ii) (( 0 :: int):: ii) :: 3 Word.word))
          = (vec_of_bits [B0,B0,B0] :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__804 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__804 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s12200 s12210) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s12080  :: " string "


\<comment> \<open>\<open>val _s1191_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s1191  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option "  where 
     " s1191 s11920 = (
   (let s11930 = s11920 in
   if ((string_startswith s11930 (''c.sw''))) then  
  (case  ((string_drop s11930 ((string_length (''c.sw''))))) of
        s11940 =>
  (case  ((spc_matches_prefix0 s11940)) of
        Some ((_, s11950)) =>
  (case  ((string_drop s11940 s11950)) of
        s11960 =>
  (case  ((creg_name_matches_prefix s11960 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s11970)) =>
  (case  ((string_drop s11960 s11970)) of
        s11980 =>
  (case  ((sep_matches_prefix s11980)) of
        Some ((_, s11990)) =>
  (case  ((string_drop s11980 s11990)) of
        s12000 =>
  (case  ((creg_name_matches_prefix s12000 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s12010)) =>
  (case  ((string_drop s12000 s12010)) of
        s12020 =>
  (case  ((sep_matches_prefix s12020)) of
        Some ((_, s12030)) =>
  (case  ((string_drop s12020 s12030)) of
        s12040 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s12040 :: (( 7 Word.word * ii)) option)) of
        Some ((v__806, s12050)) =>
  if (((((subrange_vec_dec v__806 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = (vec_of_bits [B0,B0] :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__806 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__806 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s12040 s12050) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s11920  :: " string "


\<comment> \<open>\<open>val _s1175_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s1175  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option "  where 
     " s1175 s11760 = (
   (let s11770 = s11760 in
   if ((string_startswith s11770 (''c.ld''))) then  
  (case  ((string_drop s11770 ((string_length (''c.ld''))))) of
        s11780 =>
  (case  ((spc_matches_prefix0 s11780)) of
        Some ((_, s11790)) =>
  (case  ((string_drop s11780 s11790)) of
        s11800 =>
  (case  ((creg_name_matches_prefix s11800 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s11810)) =>
  (case  ((string_drop s11800 s11810)) of
        s11820 =>
  (case  ((sep_matches_prefix s11820)) of
        Some ((_, s11830)) =>
  (case  ((string_drop s11820 s11830)) of
        s11840 =>
  (case  ((creg_name_matches_prefix s11840 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s11850)) =>
  (case  ((string_drop s11840 s11850)) of
        s11860 =>
  (case  ((sep_matches_prefix s11860)) of
        Some ((_, s11870)) =>
  (case  ((string_drop s11860 s11870)) of
        s11880 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s11880 :: (( 8 Word.word * ii)) option)) of
        Some ((v__808, s11890)) =>
  if (((((subrange_vec_dec v__808 (( 2 :: int):: ii) (( 0 :: int):: ii) :: 3 Word.word))
          = (vec_of_bits [B0,B0,B0] :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__808 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__808 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s11880 s11890) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s11760  :: " string "


\<comment> \<open>\<open>val _s1159_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s1159  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option "  where 
     " s1159 s11600 = (
   (let s11610 = s11600 in
   if ((string_startswith s11610 (''c.lw''))) then  
  (case  ((string_drop s11610 ((string_length (''c.lw''))))) of
        s11620 =>
  (case  ((spc_matches_prefix0 s11620)) of
        Some ((_, s11630)) =>
  (case  ((string_drop s11620 s11630)) of
        s11640 =>
  (case  ((creg_name_matches_prefix s11640 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s11650)) =>
  (case  ((string_drop s11640 s11650)) of
        s11660 =>
  (case  ((sep_matches_prefix s11660)) of
        Some ((_, s11670)) =>
  (case  ((string_drop s11660 s11670)) of
        s11680 =>
  (case  ((creg_name_matches_prefix s11680 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s11690)) =>
  (case  ((string_drop s11680 s11690)) of
        s11700 =>
  (case  ((sep_matches_prefix s11700)) of
        Some ((_, s11710)) =>
  (case  ((string_drop s11700 s11710)) of
        s11720 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s11720 :: (( 7 Word.word * ii)) option)) of
        Some ((v__810, s11730)) =>
  if (((((subrange_vec_dec v__810 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = (vec_of_bits [B0,B0] :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__810 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__810 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s11720 s11730) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s11600  :: " string "


\<comment> \<open>\<open>val _s1147_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s1147  :: " string \<Rightarrow>((3)Word.word*(8)Word.word)option "  where 
     " s1147 s11480 = (
   (let s11490 = s11480 in
   if ((string_startswith s11490 (''c.addi4spn''))) then  
  (case  ((string_drop s11490 ((string_length (''c.addi4spn''))))) of
        s11500 =>
  (case  ((spc_matches_prefix0 s11500)) of
        Some ((_, s11510)) =>
  (case  ((string_drop s11500 s11510)) of
        s11520 =>
  (case  ((creg_name_matches_prefix s11520 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s11530)) =>
  (case  ((string_drop s11520 s11530)) of
        s11540 =>
  (case  ((sep_matches_prefix s11540)) of
        Some ((_, s11550)) =>
  (case  ((string_drop s11540 s11550)) of
        s11560 =>
  (case  ((hex_bits_10_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s11560 :: (( 10 Word.word * ii)) option)) of
        Some ((v__812, s11570)) =>
  if (((((subrange_vec_dec v__812 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = (vec_of_bits [B0,B0] :: 2 Word.word)))) then
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__812 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__812 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (let p00 = (string_drop s11560 s11570) in
    if (((p00 = ('''')))) then Some (rdc, nzimm) else None))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s11480  :: " string "


\<comment> \<open>\<open>val _s1123_ : string -> maybe ((amoop * word_width * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1123  :: " string \<Rightarrow>(amoop*word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1123 s11250 = (
      (case  ((amo_mnemonic_matches_prefix s11250)) of
        Some ((op1, s11260)) =>
         (let s11270 = (string_drop s11250 s11260) in
         if ((string_startswith s11270 (''.''))) then  
  (case  ((string_drop s11270 ((string_length (''.''))))) of
        s11280 =>
  (case  ((size_mnemonic_matches_prefix s11280)) of
        Some ((width, s11290)) =>
  (case  ((string_drop s11280 s11290)) of
        s11300 =>
  (case  ((maybe_aq_matches_prefix s11300)) of
        Some ((aq, s11310)) =>
  (case  ((string_drop s11300 s11310)) of
        s11320 =>
  (case  ((maybe_rl_matches_prefix s11320)) of
        Some ((rl, s11330)) =>
  (case  ((string_drop s11320 s11330)) of
        s11340 =>
  (case  ((spc_matches_prefix0 s11340)) of
        Some ((_, s11350)) =>
  (case  ((string_drop s11340 s11350)) of
        s11360 =>
  (case  ((reg_name_matches_prefix s11360 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s11370)) =>
  (case  ((string_drop s11360 s11370)) of
        s11380 =>
  (case  ((sep_matches_prefix s11380)) of
        Some ((_, s11390)) =>
  (case  ((string_drop s11380 s11390)) of
        s11400 =>
  (case  ((reg_name_matches_prefix s11400 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s11410)) =>
  (case  ((string_drop s11400 s11410)) of
        s11420 =>
  (case  ((sep_matches_prefix s11420)) of
        Some ((_, s11430)) =>
  (case  ((string_drop s11420 s11430)) of
        s11440 =>
  (case  ((reg_name_matches_prefix s11440 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s11450)) =>
  (let p00 = (string_drop s11440 s11450) in
  if (((p00 = ('''')))) then Some (op1, width, aq, rl, rd, rs1, rs2) else
    None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))" 
  for  s11250  :: " string "


\<comment> \<open>\<open>val _s1101_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1101  :: " string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1101 s11020 = (
   (let s11030 = s11020 in
   if ((string_startswith s11030 (''sc.''))) then  
  (case  ((string_drop s11030 ((string_length (''sc.''))))) of
        s11040 =>
  (case  ((size_mnemonic_matches_prefix s11040)) of
        Some ((size1, s11050)) =>
  (case  ((string_drop s11040 s11050)) of
        s11060 =>
  (case  ((maybe_aq_matches_prefix s11060)) of
        Some ((aq, s11070)) =>
  (case  ((string_drop s11060 s11070)) of
        s11080 =>
  (case  ((maybe_rl_matches_prefix s11080)) of
        Some ((rl, s11090)) =>
  (case  ((string_drop s11080 s11090)) of
        s11100 =>
  (case  ((spc_matches_prefix0 s11100)) of
        Some ((_, s11110)) =>
  (case  ((string_drop s11100 s11110)) of
        s11120 =>
  (case  ((reg_name_matches_prefix s11120 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s11130)) =>
  (case  ((string_drop s11120 s11130)) of
        s11140 =>
  (case  ((sep_matches_prefix s11140)) of
        Some ((_, s11150)) =>
  (case  ((string_drop s11140 s11150)) of
        s11160 =>
  (case  ((reg_name_matches_prefix s11160 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s11170)) =>
  (case  ((string_drop s11160 s11170)) of
        s11180 =>
  (case  ((sep_matches_prefix s11180)) of
        Some ((_, s11190)) =>
  (case  ((string_drop s11180 s11190)) of
        s11200 =>
  (case  ((reg_name_matches_prefix s11200 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s11210)) =>
  (let p00 = (string_drop s11200 s11210) in
  if (((p00 = ('''')))) then Some (size1, aq, rl, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s11020  :: " string "


\<comment> \<open>\<open>val _s1083_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5))\<close>\<close>

definition s1083  :: " string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word)option "  where 
     " s1083 s10840 = (
   (let s10850 = s10840 in
   if ((string_startswith s10850 (''lr.''))) then  
  (case  ((string_drop s10850 ((string_length (''lr.''))))) of
        s10860 =>
  (case  ((size_mnemonic_matches_prefix s10860)) of
        Some ((size1, s10870)) =>
  (case  ((string_drop s10860 s10870)) of
        s10880 =>
  (case  ((maybe_aq_matches_prefix s10880)) of
        Some ((aq, s10890)) =>
  (case  ((string_drop s10880 s10890)) of
        s10900 =>
  (case  ((maybe_rl_matches_prefix s10900)) of
        Some ((rl, s10910)) =>
  (case  ((string_drop s10900 s10910)) of
        s10920 =>
  (case  ((spc_matches_prefix0 s10920)) of
        Some ((_, s10930)) =>
  (case  ((string_drop s10920 s10930)) of
        s10940 =>
  (case  ((reg_name_matches_prefix s10940 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s10950)) =>
  (case  ((string_drop s10940 s10950)) of
        s10960 =>
  (case  ((sep_matches_prefix s10960)) of
        Some ((_, s10970)) =>
  (case  ((string_drop s10960 s10970)) of
        s10980 =>
  (case  ((reg_name_matches_prefix s10980 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s10990)) =>
  (let p00 = (string_drop s10980 s10990) in
  if (((p00 = ('''')))) then Some (size1, aq, rl, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s10840  :: " string "


\<comment> \<open>\<open>val _s1071_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s1071  :: " string \<Rightarrow>((5)Word.word*(5)Word.word)option "  where 
     " s1071 s10720 = (
   (let s10730 = s10720 in
   if ((string_startswith s10730 (''sfence.vma''))) then  
  (case  ((string_drop s10730 ((string_length (''sfence.vma''))))) of
        s10740 =>
  (case  ((spc_matches_prefix0 s10740)) of
        Some ((_, s10750)) =>
  (case  ((string_drop s10740 s10750)) of
        s10760 =>
  (case  ((reg_name_matches_prefix s10760 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s10770)) =>
  (case  ((string_drop s10760 s10770)) of
        s10780 =>
  (case  ((sep_matches_prefix s10780)) of
        Some ((_, s10790)) =>
  (case  ((string_drop s10780 s10790)) of
        s10800 =>
  (case  ((reg_name_matches_prefix s10800 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s10810)) =>
  (let p00 = (string_drop s10800 s10810) in
  if (((p00 = ('''')))) then Some (rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s10720  :: " string "


\<comment> \<open>\<open>val _s1059_ : string -> maybe ((mword ty4 * mword ty4))\<close>\<close>

definition s1059  :: " string \<Rightarrow>((4)Word.word*(4)Word.word)option "  where 
     " s1059 s10600 = (
   (let s10610 = s10600 in
   if ((string_startswith s10610 (''fence.tso''))) then  
  (case  ((string_drop s10610 ((string_length (''fence.tso''))))) of
        s10620 =>
  (case  ((spc_matches_prefix0 s10620)) of
        Some ((_, s10630)) =>
  (case  ((string_drop s10620 s10630)) of
        s10640 =>
  (case  ((fence_bits_matches_prefix s10640 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s10650)) =>
  (case  ((string_drop s10640 s10650)) of
        s10660 =>
  (case  ((sep_matches_prefix s10660)) of
        Some ((_, s10670)) =>
  (case  ((string_drop s10660 s10670)) of
        s10680 =>
  (case  ((fence_bits_matches_prefix s10680 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s10690)) =>
  (let p00 = (string_drop s10680 s10690) in
  if (((p00 = ('''')))) then Some (pred, succ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s10600  :: " string "


\<comment> \<open>\<open>val _s1047_ : string -> maybe ((mword ty4 * mword ty4))\<close>\<close>

definition s1047  :: " string \<Rightarrow>((4)Word.word*(4)Word.word)option "  where 
     " s1047 s10480 = (
   (let s10490 = s10480 in
   if ((string_startswith s10490 (''fence''))) then  
  (case  ((string_drop s10490 ((string_length (''fence''))))) of
        s10500 =>
  (case  ((spc_matches_prefix0 s10500)) of
        Some ((_, s10510)) =>
  (case  ((string_drop s10500 s10510)) of
        s10520 =>
  (case  ((fence_bits_matches_prefix s10520 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s10530)) =>
  (case  ((string_drop s10520 s10530)) of
        s10540 =>
  (case  ((sep_matches_prefix s10540)) of
        Some ((_, s10550)) =>
  (case  ((string_drop s10540 s10550)) of
        s10560 =>
  (case  ((fence_bits_matches_prefix s10560 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s10570)) =>
  (let p00 = (string_drop s10560 s10570) in
  if (((p00 = ('''')))) then Some (pred, succ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s10480  :: " string "


\<comment> \<open>\<open>val _s1030_ : string -> maybe ((sopw * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1030  :: " string \<Rightarrow>(sopw*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1030 s10320 = (
      (case  ((shiftiwop_mnemonic_matches_prefix s10320)) of
        Some ((op1, s10330)) => 
  (case  ((string_drop s10320 s10330)) of
        s10340 =>
  (case  ((spc_matches_prefix0 s10340)) of
        Some ((_, s10350)) =>
  (case  ((string_drop s10340 s10350)) of
        s10360 =>
  (case  ((reg_name_matches_prefix s10360 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s10370)) =>
  (case  ((string_drop s10360 s10370)) of
        s10380 =>
  (case  ((sep_matches_prefix s10380)) of
        Some ((_, s10390)) =>
  (case  ((string_drop s10380 s10390)) of
        s10400 =>
  (case  ((reg_name_matches_prefix s10400 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s10410)) =>
  (case  ((string_drop s10400 s10410)) of
        s10420 =>
  (case  ((sep_matches_prefix s10420)) of
        Some ((_, s10430)) =>
  (case  ((string_drop s10420 s10430)) of
        s10440 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s10440 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s10450)) =>
  (let p00 = (string_drop s10440 s10450) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s10320  :: " string "


\<comment> \<open>\<open>val _s1013_ : string -> maybe ((ropw * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1013  :: " string \<Rightarrow>(ropw*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1013 s10150 = (
      (case  ((rtypew_mnemonic_matches_prefix s10150)) of
        Some ((op1, s10160)) => 
  (case  ((string_drop s10150 s10160)) of
        s10170 =>
  (case  ((spc_matches_prefix0 s10170)) of
        Some ((_, s10180)) =>
  (case  ((string_drop s10170 s10180)) of
        s10190 =>
  (case  ((reg_name_matches_prefix s10190 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s10200)) =>
  (case  ((string_drop s10190 s10200)) of
        s10210 =>
  (case  ((sep_matches_prefix s10210)) of
        Some ((_, s10220)) =>
  (case  ((string_drop s10210 s10220)) of
        s10230 =>
  (case  ((reg_name_matches_prefix s10230 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s10240)) =>
  (case  ((string_drop s10230 s10240)) of
        s10250 =>
  (case  ((sep_matches_prefix s10250)) of
        Some ((_, s10260)) =>
  (case  ((string_drop s10250 s10260)) of
        s10270 =>
  (case  ((reg_name_matches_prefix s10270 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s10280)) =>
  (let p00 = (string_drop s10270 s10280) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s10150  :: " string "


\<comment> \<open>\<open>val _s996_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s996  :: " string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s996 s9980 = (
      (case  ((shiftw_mnemonic_matches_prefix s9980)) of
        Some ((op1, s9990)) => 
  (case  ((string_drop s9980 s9990)) of
        s10000 =>
  (case  ((spc_matches_prefix0 s10000)) of
        Some ((_, s10010)) =>
  (case  ((string_drop s10000 s10010)) of
        s10020 =>
  (case  ((reg_name_matches_prefix s10020 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s10030)) =>
  (case  ((string_drop s10020 s10030)) of
        s10040 =>
  (case  ((sep_matches_prefix s10040)) of
        Some ((_, s10050)) =>
  (case  ((string_drop s10040 s10050)) of
        s10060 =>
  (case  ((reg_name_matches_prefix s10060 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s10070)) =>
  (case  ((string_drop s10060 s10070)) of
        s10080 =>
  (case  ((sep_matches_prefix s10080)) of
        Some ((_, s10090)) =>
  (case  ((string_drop s10080 s10090)) of
        s10100 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s10100 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s10110)) =>
  (let p00 = (string_drop s10100 s10110) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s9980  :: " string "


\<comment> \<open>\<open>val _s980_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s980  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word)option "  where 
     " s980 s9810 = (
   (let s9820 = s9810 in
   if ((string_startswith s9820 (''addiw''))) then  
  (case  ((string_drop s9820 ((string_length (''addiw''))))) of
        s9830 =>
  (case  ((spc_matches_prefix0 s9830)) of
        Some ((_, s9840)) =>
  (case  ((string_drop s9830 s9840)) of
        s9850 =>
  (case  ((reg_name_matches_prefix s9850 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s9860)) =>
  (case  ((string_drop s9850 s9860)) of
        s9870 =>
  (case  ((sep_matches_prefix s9870)) of
        Some ((_, s9880)) =>
  (case  ((string_drop s9870 s9880)) of
        s9890 =>
  (case  ((reg_name_matches_prefix s9890 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s9900)) =>
  (case  ((string_drop s9890 s9900)) of
        s9910 =>
  (case  ((sep_matches_prefix s9910)) of
        Some ((_, s9920)) =>
  (case  ((string_drop s9910 s9920)) of
        s9930 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s9930 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s9940)) =>
  (let p00 = (string_drop s9930 s9940) in
  if (((p00 = ('''')))) then Some (rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s9810  :: " string "


\<comment> \<open>\<open>val _s952_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s952  :: " string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word)option "  where 
     " s952 s9530 = (
   (let s9540 = s9530 in
   if ((string_startswith s9540 (''s''))) then  
  (case  ((string_drop s9540 ((string_length (''s''))))) of
        s9550 =>
  (case  ((size_mnemonic_matches_prefix s9550)) of
        Some ((size1, s9560)) =>
  (case  ((string_drop s9550 s9560)) of
        s9570 =>
  (case  ((maybe_aq_matches_prefix s9570)) of
        Some ((aq, s9580)) =>
  (case  ((string_drop s9570 s9580)) of
        s9590 =>
  (case  ((maybe_rl_matches_prefix s9590)) of
        Some ((rl, s9600)) =>
  (case  ((string_drop s9590 s9600)) of
        s9610 =>
  (case  ((spc_matches_prefix0 s9610)) of
        Some ((_, s9620)) =>
  (case  ((string_drop s9610 s9620)) of
        s9630 =>
  (case  ((reg_name_matches_prefix s9630 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s9640)) =>
  (case  ((string_drop s9630 s9640)) of
        s9650 =>
  (case  ((sep_matches_prefix s9650)) of
        Some ((_, s9660)) =>
  (case  ((string_drop s9650 s9660)) of
        s9670 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s9670 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s9680)) =>
  (case  ((string_drop s9670 s9680)) of
        s9690 =>
  (case  ((opt_spc_matches_prefix0 s9690)) of
        Some ((_, s9700)) =>
  (let s9710 = (string_drop s9690 s9700) in
  if ((string_startswith s9710 (''(''))) then
    (case  ((string_drop s9710 ((string_length (''(''))))) of
          s9720 =>
    (case  ((opt_spc_matches_prefix0 s9720)) of
          Some ((_, s9730)) =>
    (case  ((string_drop s9720 s9730)) of
          s9740 =>
    (case  ((reg_name_matches_prefix s9740 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s9750)) =>
    (case  ((string_drop s9740 s9750)) of
          s9760 =>
    (case  ((opt_spc_matches_prefix0 s9760)) of
          Some ((_, s9770)) =>
    (let s9780 = (string_drop s9760 s9770) in
    if ((string_startswith s9780 ('')''))) then
      (let p00 = (string_drop s9780 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then Some (size1, aq, rl, rs2, imm, rs1) else
        None) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s9530  :: " string "


\<comment> \<open>\<open>val _s922_ : string -> maybe ((word_width * bool * bool * bool * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s922  :: " string \<Rightarrow>(word_width*bool*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word)option "  where 
     " s922 s9230 = (
   (let s9240 = s9230 in
   if ((string_startswith s9240 (''l''))) then  
  (case  ((string_drop s9240 ((string_length (''l''))))) of
        s9250 =>
  (case  ((size_mnemonic_matches_prefix s9250)) of
        Some ((size1, s9260)) =>
  (case  ((string_drop s9250 s9260)) of
        s9270 =>
  (case  ((maybe_u_matches_prefix s9270)) of
        Some ((is_unsigned, s9280)) =>
  (case  ((string_drop s9270 s9280)) of
        s9290 =>
  (case  ((maybe_aq_matches_prefix s9290)) of
        Some ((aq, s9300)) =>
  (case  ((string_drop s9290 s9300)) of
        s9310 =>
  (case  ((maybe_rl_matches_prefix s9310)) of
        Some ((rl, s9320)) =>
  (case  ((string_drop s9310 s9320)) of
        s9330 =>
  (case  ((spc_matches_prefix0 s9330)) of
        Some ((_, s9340)) =>
  (case  ((string_drop s9330 s9340)) of
        s9350 =>
  (case  ((reg_name_matches_prefix s9350 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s9360)) =>
  (case  ((string_drop s9350 s9360)) of
        s9370 =>
  (case  ((sep_matches_prefix s9370)) of
        Some ((_, s9380)) =>
  (case  ((string_drop s9370 s9380)) of
        s9390 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s9390 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s9400)) =>
  (case  ((string_drop s9390 s9400)) of
        s9410 =>
  (case  ((opt_spc_matches_prefix0 s9410)) of
        Some ((_, s9420)) =>
  (let s9430 = (string_drop s9410 s9420) in
  if ((string_startswith s9430 (''(''))) then
    (case  ((string_drop s9430 ((string_length (''(''))))) of
          s9440 =>
    (case  ((opt_spc_matches_prefix0 s9440)) of
          Some ((_, s9450)) =>
    (case  ((string_drop s9440 s9450)) of
          s9460 =>
    (case  ((reg_name_matches_prefix s9460 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s9470)) =>
    (case  ((string_drop s9460 s9470)) of
          s9480 =>
    (case  ((opt_spc_matches_prefix0 s9480)) of
          Some ((_, s9490)) =>
    (let s9500 = (string_drop s9480 s9490) in
    if ((string_startswith s9500 ('')''))) then
      (let p00 = (string_drop s9500 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then
        Some (size1, is_unsigned, aq, rl, rd, imm, rs1) else None) else 
    None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s9230  :: " string "


\<comment> \<open>\<open>val _s905_ : string -> maybe ((rop * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s905  :: " string \<Rightarrow>(rop*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s905 s9070 = (
      (case  ((rtype_mnemonic_matches_prefix s9070)) of
        Some ((op1, s9080)) => 
  (case  ((string_drop s9070 s9080)) of
        s9090 =>
  (case  ((spc_matches_prefix0 s9090)) of
        Some ((_, s9100)) =>
  (case  ((string_drop s9090 s9100)) of
        s9110 =>
  (case  ((reg_name_matches_prefix s9110 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s9120)) =>
  (case  ((string_drop s9110 s9120)) of
        s9130 =>
  (case  ((sep_matches_prefix s9130)) of
        Some ((_, s9140)) =>
  (case  ((string_drop s9130 s9140)) of
        s9150 =>
  (case  ((reg_name_matches_prefix s9150 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s9160)) =>
  (case  ((string_drop s9150 s9160)) of
        s9170 =>
  (case  ((sep_matches_prefix s9170)) of
        Some ((_, s9180)) =>
  (case  ((string_drop s9170 s9180)) of
        s9190 =>
  (case  ((reg_name_matches_prefix s9190 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s9200)) =>
  (let p00 = (string_drop s9190 s9200) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s9070  :: " string "


\<comment> \<open>\<open>val _s888_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty6))\<close>\<close>

definition s888  :: " string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(6)Word.word)option "  where 
     " s888 s8900 = (
      (case  ((shiftiop_mnemonic_matches_prefix s8900)) of
        Some ((op1, s8910)) => 
  (case  ((string_drop s8900 s8910)) of
        s8920 =>
  (case  ((spc_matches_prefix0 s8920)) of
        Some ((_, s8930)) =>
  (case  ((string_drop s8920 s8930)) of
        s8940 =>
  (case  ((reg_name_matches_prefix s8940 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s8950)) =>
  (case  ((string_drop s8940 s8950)) of
        s8960 =>
  (case  ((sep_matches_prefix s8960)) of
        Some ((_, s8970)) =>
  (case  ((string_drop s8960 s8970)) of
        s8980 =>
  (case  ((reg_name_matches_prefix s8980 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s8990)) =>
  (case  ((string_drop s8980 s8990)) of
        s9000 =>
  (case  ((sep_matches_prefix s9000)) of
        Some ((_, s9010)) =>
  (case  ((string_drop s9000 s9010)) of
        s9020 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s9020 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s9030)) =>
  (let p00 = (string_drop s9020 s9030) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s8900  :: " string "


\<comment> \<open>\<open>val _s871_ : string -> maybe ((iop * mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s871  :: " string \<Rightarrow>(iop*(5)Word.word*(5)Word.word*(12)Word.word)option "  where 
     " s871 s8730 = (
      (case  ((itype_mnemonic_matches_prefix s8730)) of
        Some ((op1, s8740)) => 
  (case  ((string_drop s8730 s8740)) of
        s8750 =>
  (case  ((spc_matches_prefix0 s8750)) of
        Some ((_, s8760)) =>
  (case  ((string_drop s8750 s8760)) of
        s8770 =>
  (case  ((reg_name_matches_prefix s8770 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s8780)) =>
  (case  ((string_drop s8770 s8780)) of
        s8790 =>
  (case  ((sep_matches_prefix s8790)) of
        Some ((_, s8800)) =>
  (case  ((string_drop s8790 s8800)) of
        s8810 =>
  (case  ((reg_name_matches_prefix s8810 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s8820)) =>
  (case  ((string_drop s8810 s8820)) of
        s8830 =>
  (case  ((sep_matches_prefix s8830)) of
        Some ((_, s8840)) =>
  (case  ((string_drop s8830 s8840)) of
        s8850 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s8850 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s8860)) =>
  (let p00 = (string_drop s8850 s8860) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s8730  :: " string "


\<comment> \<open>\<open>val _s854_ : string -> maybe ((bop * mword ty5 * mword ty5 * mword ty13))\<close>\<close>

definition s854  :: " string \<Rightarrow>(bop*(5)Word.word*(5)Word.word*(13)Word.word)option "  where 
     " s854 s8560 = (
      (case  ((btype_mnemonic_matches_prefix s8560)) of
        Some ((op1, s8570)) => 
  (case  ((string_drop s8560 s8570)) of
        s8580 =>
  (case  ((spc_matches_prefix0 s8580)) of
        Some ((_, s8590)) =>
  (case  ((string_drop s8580 s8590)) of
        s8600 =>
  (case  ((reg_name_matches_prefix s8600 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s8610)) =>
  (case  ((string_drop s8600 s8610)) of
        s8620 =>
  (case  ((sep_matches_prefix s8620)) of
        Some ((_, s8630)) =>
  (case  ((string_drop s8620 s8630)) of
        s8640 =>
  (case  ((reg_name_matches_prefix s8640 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s8650)) =>
  (case  ((string_drop s8640 s8650)) of
        s8660 =>
  (case  ((sep_matches_prefix s8660)) of
        Some ((_, s8670)) =>
  (case  ((string_drop s8660 s8670)) of
        s8680 =>
  (case  ((hex_bits_13_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s8680 :: (( 13 Word.word * ii)) option)) of
        Some ((imm, s8690)) =>
  (let p00 = (string_drop s8680 s8690) in
  if (((p00 = ('''')))) then Some (op1, rs1, rs2, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s8560  :: " string "


\<comment> \<open>\<open>val _s838_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s838  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word)option "  where 
     " s838 s8390 = (
   (let s8400 = s8390 in
   if ((string_startswith s8400 (''jalr''))) then  
  (case  ((string_drop s8400 ((string_length (''jalr''))))) of
        s8410 =>
  (case  ((spc_matches_prefix0 s8410)) of
        Some ((_, s8420)) =>
  (case  ((string_drop s8410 s8420)) of
        s8430 =>
  (case  ((reg_name_matches_prefix s8430 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s8440)) =>
  (case  ((string_drop s8430 s8440)) of
        s8450 =>
  (case  ((sep_matches_prefix s8450)) of
        Some ((_, s8460)) =>
  (case  ((string_drop s8450 s8460)) of
        s8470 =>
  (case  ((reg_name_matches_prefix s8470 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s8480)) =>
  (case  ((string_drop s8470 s8480)) of
        s8490 =>
  (case  ((sep_matches_prefix s8490)) of
        Some ((_, s8500)) =>
  (case  ((string_drop s8490 s8500)) of
        s8510 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s8510 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s8520)) =>
  (let p00 = (string_drop s8510 s8520) in
  if (((p00 = ('''')))) then Some (rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s8390  :: " string "


\<comment> \<open>\<open>val _s826_ : string -> maybe ((mword ty5 * mword ty21))\<close>\<close>

definition s826  :: " string \<Rightarrow>((5)Word.word*(21)Word.word)option "  where 
     " s826 s8270 = (
   (let s8280 = s8270 in
   if ((string_startswith s8280 (''jal''))) then  
  (case  ((string_drop s8280 ((string_length (''jal''))))) of
        s8290 =>
  (case  ((spc_matches_prefix0 s8290)) of
        Some ((_, s8300)) =>
  (case  ((string_drop s8290 s8300)) of
        s8310 =>
  (case  ((reg_name_matches_prefix s8310 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s8320)) =>
  (case  ((string_drop s8310 s8320)) of
        s8330 =>
  (case  ((sep_matches_prefix s8330)) of
        Some ((_, s8340)) =>
  (case  ((string_drop s8330 s8340)) of
        s8350 =>
  (case  ((hex_bits_21_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s8350 :: (( 21 Word.word * ii)) option)) of
        Some ((imm, s8360)) =>
  (let p00 = (string_drop s8350 s8360) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s8270  :: " string "


\<comment> \<open>\<open>val _s813_ : string -> maybe ((uop * mword ty5 * mword ty20))\<close>\<close>

definition s813  :: " string \<Rightarrow>(uop*(5)Word.word*(20)Word.word)option "  where 
     " s813 s8150 = (
      (case  ((utype_mnemonic_matches_prefix s8150)) of
        Some ((op1, s8160)) => 
  (case  ((string_drop s8150 s8160)) of
        s8170 =>
  (case  ((spc_matches_prefix0 s8170)) of
        Some ((_, s8180)) =>
  (case  ((string_drop s8170 s8180)) of
        s8190 =>
  (case  ((reg_name_matches_prefix s8190 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s8200)) =>
  (case  ((string_drop s8190 s8200)) of
        s8210 =>
  (case  ((sep_matches_prefix s8210)) of
        Some ((_, s8220)) =>
  (case  ((string_drop s8210 s8220)) of
        s8230 =>
  (case  ((hex_bits_20_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s8230 :: (( 20 Word.word * ii)) option)) of
        Some ((imm, s8240)) =>
  (let p00 = (string_drop s8230 s8240) in
  if (((p00 = ('''')))) then Some (op1, rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s8150  :: " string "


definition assembly_backwards  :: " string \<Rightarrow>((register_value),(ast),(exception))monad "  where 
     " assembly_backwards arg1 = (
   (let s8250 = arg1 in
   if ((case  ((s813 s8250  ::  ((uop *  5 Word.word *  20 Word.word))option)) of
       Some ((op1, rd, imm)) => True
     | _ => False
     )) then  (case  (s813 s8250 :: (( uop * 5 Word.word * 20 Word.word)) option) of
     (Some ((op1, rd, imm))) =>
 return (UTYPE (imm, rd, op1))
 )
   else if ((case  ((s826 s8250  ::  (( 5 Word.word *  21 Word.word))option)) of
       Some ((rd, imm)) => True
     | _ => False
     )) then  (case  (s826 s8250 :: (( 5 Word.word * 21 Word.word)) option) of
     (Some ((rd, imm))) =>
 return (RISCV_JAL (imm, rd))
 )
   else if ((case  ((s838 s8250  ::  (( 5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((rd, rs1, imm)) => True
     | _ => False
     )) then  (case  (s838 s8250 :: (( 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((rd, rs1, imm))) =>
 return (RISCV_JALR (imm, rs1, rd))
 )
   else if ((case  ((s854 s8250  ::  ((bop *  5 Word.word *  5 Word.word *  13 Word.word))option)) of
       Some ((op1, rs1, rs2, imm)) => True
     | _ => False
     )) then  (case 
 (s854 s8250 :: (( bop * 5 Word.word * 5 Word.word * 13 Word.word)) option) of
     (Some ((op1, rs1, rs2, imm))) =>
 return (BTYPE (imm, rs2, rs1, op1))
 )
   else if ((case  ((s871 s8250  ::  ((iop *  5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((op1, rd, rs1, imm)) => True
     | _ => False
     )) then  (case 
 (s871 s8250 :: (( iop * 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((op1, rd, rs1, imm))) =>
 return (ITYPE (imm, rs1, rd, op1))
 )
   else if ((case  ((s888 s8250  ::  ((sop *  5 Word.word *  5 Word.word *  6 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => True
     | _ => False
     )) then  (case 
 (s888 s8250 :: (( sop * 5 Word.word * 5 Word.word * 6 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 return (SHIFTIOP (shamt, rs1, rd, op1))
 )
   else if ((case  ((s905 s8250  ::  ((rop *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s905 s8250 :: (( rop * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, rs2))) =>
 return (RTYPE (rs2, rs1, rd, op1))
 )
   else if ((case  ((s922 s8250
                     ::  ((word_width * bool * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((size1, is_unsigned, aq, rl, rd, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s922 s8250
 :: (( word_width * bool * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((size1, is_unsigned, aq, rl, rd, imm, rs1))) =>
 return (LOAD (imm, rs1, rd, is_unsigned, size1, aq, rl))
 )
   else if ((case  ((s952 s8250
                     ::  ((word_width * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rs2, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s952 s8250 :: (( word_width * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rs2, imm, rs1))) =>
 return (STORE (imm, rs2, rs1, size1, aq, rl))
 )
   else if ((case  ((s980 s8250  ::  (( 5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((rd, rs1, imm)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s980 s8250 :: (( 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((rd, rs1, imm))) =>
 return (ADDIW (imm, rs1, rd))
 )
   else if ((case  ((s996 s8250  ::  ((sop *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s996 s8250 :: (( sop * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 return (SHIFTW (shamt, rs1, rd, op1))
 )
   else if ((case  ((s1013 s8250  ::  ((ropw *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1013 s8250 :: (( ropw * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, rs2))) =>
 return (RTYPEW (rs2, rs1, rd, op1))
 )
   else if ((case  ((s1030 s8250  ::  ((sopw *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1030 s8250 :: (( sopw * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 return (SHIFTIWOP (shamt, rs1, rd, op1))
 )
   else if ((case  ((s1047 s8250  ::  (( 4 Word.word *  4 Word.word))option)) of
       Some ((pred, succ)) => True
     | _ => False
     )) then  (case  (s1047 s8250 :: (( 4 Word.word * 4 Word.word)) option) of
     (Some ((pred, succ))) =>
 return (FENCE (pred, succ))
 )
   else if ((case  ((s1059 s8250  ::  (( 4 Word.word *  4 Word.word))option)) of
       Some ((pred, succ)) => True
     | _ => False
     )) then  (case  (s1059 s8250 :: (( 4 Word.word * 4 Word.word)) option) of
     (Some ((pred, succ))) =>
 return (FENCE_TSO (pred, succ))
 )
   else if (((s8250 = (''fence.i'')))) then return (FENCEI () )
   else if (((s8250 = (''ecall'')))) then return (ECALL () )
   else if (((s8250 = (''mret'')))) then return (MRET () )
   else if (((s8250 = (''sret'')))) then return (SRET () )
   else if (((s8250 = (''ebreak'')))) then return (EBREAK () )
   else if (((s8250 = (''wfi'')))) then return (WFI () )
   else if ((case  ((s1071 s8250  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rs1, rs2)) => True
     | _ => False
     )) then  (case  (s1071 s8250 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rs1, rs2))) =>
 return (SFENCE_VMA (rs1, rs2))
 )
   else if ((case  ((s1083 s8250  ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s1083 s8250 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rd, rs1))) =>
 return (LOADRES (aq, rl, rs1, size1, rd))
 )
   else if ((case  ((s1101 s8250
                     ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s1101 s8250 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rd, rs1, rs2))) =>
 return (STORECON (aq, rl, rs2, rs1, size1, rd))
 )
   else if ((case  ((s1123 s8250
                     ::  ((amoop * word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, width, aq, rl, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s1123 s8250
 :: (( amoop * word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, width, aq, rl, rd, rs1, rs2))) =>
 return (AMO (op1, aq, rl, rs2, rs1, width, rd))
 )
   else if (((s8250 = (''c.nop'')))) then return (C_NOP () )
   else if ((case  ((s1147 s8250  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rdc, nzimm)) => (nzimm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))
     | _ => False
     )) then  (case  (s1147 s8250 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rdc, nzimm))) =>
 return (C_ADDI4SPN (rdc, nzimm))
 )
   else if ((case  ((s1159 s8250  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => True
     | _ => False
     )) then  (case  (s1159 s8250 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 return (C_LW (uimm, rsc, rdc))
 )
   else if ((case  ((s1175 s8250  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1175 s8250 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 return (C_LD (uimm, rsc, rdc))
 )
   else if ((case  ((s1191 s8250  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => True
     | _ => False
     )) then  (case 
 (s1191 s8250 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 return (C_SW (uimm, rsc1, rsc2))
 )
   else if ((case  ((s1207 s8250  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1207 s8250 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 return (C_SD (uimm, rsc1, rsc2))
 )
   else if ((case  ((s1223 s8250  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, nzi)) =>
        ((((nzi \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s1223 s8250 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, nzi))) =>
 return (C_ADDI (nzi, rsd))
 )
   else if ((case  ((s1235 s8250  ::  ( 11 Word.word)option)) of
       Some (imm) => ((( 32 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s1235 s8250 :: ( 11 Word.word) option) of
     (Some (imm)) =>
 return (C_JAL imm)
 )
   else if ((case  ((s1243 s8250  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, imm)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1243 s8250 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, imm))) =>
 return (C_ADDIW (imm, rsd))
 )
   else if ((case  ((s1255 s8250  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, imm)) => (((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s1255 s8250 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, imm))) =>
 return (C_LI (imm, rd))
 )
   else if ((case  ((s1267 s8250  ::  ( 6 Word.word)option)) of
       Some (imm) => (imm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))
     | _ => False
     )) then  (case  (s1267 s8250 :: ( 6 Word.word) option) of
     (Some (imm)) =>
 return (C_ADDI16SP imm)
 )
   else if ((case  ((s1275 s8250  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, imm)) =>
        ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno sp))))) \<and> (((imm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))))
     | _ => False
     )) then  (case  (s1275 s8250 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, imm))) =>
 return (C_LUI (imm, rd))
 )
   else if ((case  ((s1287 s8250  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => (shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))
     | _ => False
     )) then  (case  (s1287 s8250 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 return (C_SRLI (shamt, rsd))
 )
   else if ((case  ((s1299 s8250  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => (shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))
     | _ => False
     )) then  (case  (s1299 s8250 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 return (C_SRAI (shamt, rsd))
 )
   else if ((case  ((s1311 s8250  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, imm)) => True
     | _ => False
     )) then  (case  (s1311 s8250 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, imm))) =>
 return (C_ANDI (imm, rsd))
 )
   else if ((case  ((s1323 s8250  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s1323 s8250 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_SUB (rsd, rs2))
 )
   else if ((case  ((s1335 s8250  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s1335 s8250 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_XOR (rsd, rs2))
 )
   else if ((case  ((s1347 s8250  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s1347 s8250 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_OR (rsd, rs2))
 )
   else if ((case  ((s1359 s8250  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s1359 s8250 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_AND (rsd, rs2))
 )
   else if ((case  ((s1371 s8250  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1371 s8250 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_SUBW (rsd, rs2))
 )
   else if ((case  ((s1383 s8250  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1383 s8250 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_ADDW (rsd, rs2))
 )
   else if ((case  ((s1395 s8250  ::  ( 11 Word.word)option)) of
       Some (imm) => True
     | _ => False
     )) then  (case  (s1395 s8250 :: ( 11 Word.word) option) of
     (Some (imm)) =>
 return (C_J imm)
 )
   else if ((case  ((s1403 s8250  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rs, imm)) => True
     | _ => False
     )) then  (case  (s1403 s8250 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rs, imm))) =>
 return (C_BEQZ (imm, rs))
 )
   else if ((case  ((s1415 s8250  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rs, imm)) => True
     | _ => False
     )) then  (case  (s1415 s8250 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rs, imm))) =>
 return (C_BNEZ (imm, rs))
 )
   else if ((case  ((s1427 s8250  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) =>
        ((((shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s1427 s8250 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 return (C_SLLI (shamt, rsd))
 )
   else if ((case  ((s1439 s8250  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => (((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s1439 s8250 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 return (C_LWSP (uimm, rd))
 )
   else if ((case  ((s1451 s8250  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) =>
        ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s1451 s8250 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 return (C_LDSP (uimm, rd))
 )
   else if ((case  ((s1463 s8250  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => True
     | _ => False
     )) then  (case  (s1463 s8250 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 return (C_SWSP (uimm, rd))
 )
   else if ((case  ((s1475 s8250  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rs2, uimm)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1475 s8250 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rs2, uimm))) =>
 return (C_SDSP (uimm, rs2))
 )
   else if ((case  ((s1487 s8250  ::  ( 5 Word.word)option)) of
       Some (rs1) => (((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s1487 s8250 :: ( 5 Word.word) option) of
     (Some (rs1)) =>
 return (C_JR rs1)
 )
   else if ((case  ((s1495 s8250  ::  ( 5 Word.word)option)) of
       Some (rs1) => (((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s1495 s8250 :: ( 5 Word.word) option) of
     (Some (rs1)) =>
 return (C_JALR rs1)
 )
   else if ((case  ((s1503 s8250  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rd, rs2)) =>
        ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s1503 s8250 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rd, rs2))) =>
 return (C_MV (rd, rs2))
 )
   else if (((s8250 = (''c.ebreak'')))) then return (C_EBREAK () )
   else if ((case  ((s1515 s8250  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rsd, rs2)) =>
        ((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s1515 s8250 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 return (C_ADD (rsd, rs2))
 )
   else if ((case  ((s1527 s8250
                     ::  ((bool * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((high, signed1, signed2, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s1527 s8250 :: (( bool * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((high, signed1, signed2, rd, rs1, rs2))) =>
 return (MUL (rs2, rs1, rd, high, signed1, signed2))
 )
   else if ((case  ((s1544 s8250  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s1544 s8250 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 return (DIV (rs2, rs1, rd, s))
 )
   else if ((case  ((s1562 s8250  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s1562 s8250 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 return (REM (rs2, rs1, rd, s))
 )
   else if ((case  ((s1580 s8250  ::  (( 5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((rd, rs1, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1580 s8250 :: (( 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((rd, rs1, rs2))) =>
 return (MULW (rs2, rs1, rd))
 )
   else if ((case  ((s1596 s8250  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1596 s8250 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 return (DIVW (rs2, rs1, rd, s))
 )
   else if ((case  ((s1615 s8250  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1615 s8250 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 return (REMW (rs2, rs1, rd, s))
 )
   else if ((case  ((s1634 s8250  ::  ((csrop *  5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((op1, rd, rs1, csr)) => True
     | _ => False
     )) then  (case 
 (s1634 s8250 :: (( csrop * 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((op1, rd, rs1, csr))) =>
 return (CSR (csr, rs1, rd, True, op1))
 )
   else if ((case  ((s1652 s8250  ::  ((csrop *  5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((op1, rd, rs1, csr)) => True
     | _ => False
     )) then  (case 
 (s1652 s8250 :: (( csrop * 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((op1, rd, rs1, csr))) =>
 return (CSR (csr, rs1, rd, False, op1))
 )
   else if (((s8250 = (''uret'')))) then return (URET () )
   else if ((case  ((s1669 s8250  ::  ( 32 Word.word)option)) of   Some (s) => True | _ => False ))
   then  (case  (s1669 s8250 :: ( 32 Word.word) option) of
     (Some (s)) =>
 return (ILLEGAL s)
 )
   else if ((case  ((s1677 s8250  ::  ( 16 Word.word)option)) of   Some (s) => True | _ => False ))
   then  (case  (s1677 s8250 :: ( 16 Word.word) option) of
     (Some (s)) =>
 return (C_ILLEGAL s)
 )
   else assert_exp False (''Pattern match failure at unknown location'') \<then> exit0 () ))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val assembly_forwards_matches : ast -> bool\<close>\<close>

fun assembly_forwards_matches  :: " ast \<Rightarrow> bool "  where 
     " assembly_forwards_matches (UTYPE ((imm, rd, op1))) = ( True )" 
  for  op1  :: " uop " 
  and  imm  :: "(20)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (RISCV_JAL ((imm, rd))) = ( True )" 
  for  imm  :: "(21)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (RISCV_JALR ((imm, rs1, rd))) = ( True )" 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (BTYPE ((imm, rs2, rs1, op1))) = ( True )" 
  for  op1  :: " bop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(13)Word.word "
|" assembly_forwards_matches (ITYPE ((imm, rs1, rd, op1))) = ( True )" 
  for  op1  :: " iop " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (SHIFTIOP ((shamt, rs1, rd, op1))) = ( True )" 
  for  op1  :: " sop " 
  and  shamt  :: "(6)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (RTYPE ((rs2, rs1, rd, op1))) = ( True )" 
  for  op1  :: " rop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (LOAD ((imm, rs1, rd, is_unsigned, size1, aq, rl))) = ( True )" 
  for  size1  :: " word_width " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  is_unsigned  :: " bool " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" assembly_forwards_matches (STORE ((imm, rs2, rs1, size1, aq, rl))) = ( True )" 
  for  size1  :: " word_width " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" assembly_forwards_matches (ADDIW ((imm, rs1, rd))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs1  :: "(5)Word.word " 
  and  imm  :: "(12)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (SHIFTW ((shamt, rs1, rd, op1))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  op1  :: " sop " 
  and  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (RTYPEW ((rs2, rs1, rd, op1))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  op1  :: " ropw " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (SHIFTIWOP ((shamt, rs1, rd, op1))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  op1  :: " sopw " 
  and  shamt  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (FENCE ((pred, succ))) = ( True )" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|" assembly_forwards_matches (FENCE_TSO ((pred, succ))) = ( True )" 
  for  pred  :: "(4)Word.word " 
  and  succ  :: "(4)Word.word "
|" assembly_forwards_matches (FENCEI (_)) = ( True )"
|" assembly_forwards_matches (ECALL (_)) = ( True )"
|" assembly_forwards_matches (MRET (_)) = ( True )"
|" assembly_forwards_matches (SRET (_)) = ( True )"
|" assembly_forwards_matches (EBREAK (_)) = ( True )"
|" assembly_forwards_matches (WFI (_)) = ( True )"
|" assembly_forwards_matches (SFENCE_VMA ((rs1, rs2))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word "
|" assembly_forwards_matches (LOADRES ((aq, rl, rs1, size1, rd))) = ( True )" 
  for  size1  :: " word_width " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" assembly_forwards_matches (STORECON ((aq, rl, rs2, rs1, size1, rd))) = ( True )" 
  for  size1  :: " word_width " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  rl  :: " bool "
|" assembly_forwards_matches (AMO ((op1, aq, rl, rs2, rs1, width, rd))) = ( True )" 
  for  op1  :: " amoop " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  aq  :: " bool " 
  and  width  :: " word_width " 
  and  rl  :: " bool "
|" assembly_forwards_matches (C_NOP (_)) = ( True )"
|" assembly_forwards_matches (C_ADDI4SPN ((rdc, nzimm))) = (
      if (((nzimm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word)))) then True else False )" 
  for  nzimm  :: "(8)Word.word " 
  and  rdc  :: "(3)Word.word "
|" assembly_forwards_matches (C_LW ((uimm, rsc, rdc))) = ( True )" 
  for  rsc  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word " 
  and  rdc  :: "(3)Word.word "
|" assembly_forwards_matches (C_LD ((uimm, rsc, rdc))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rsc  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word " 
  and  rdc  :: "(3)Word.word "
|" assembly_forwards_matches (C_SW ((uimm, rsc1, rsc2))) = ( True )" 
  for  rsc2  :: "(3)Word.word " 
  and  rsc1  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word "
|" assembly_forwards_matches (C_SD ((uimm, rsc1, rsc2))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rsc2  :: "(3)Word.word " 
  and  rsc1  :: "(3)Word.word " 
  and  uimm  :: "(5)Word.word "
|" assembly_forwards_matches (C_ADDI ((nzi, rsd))) = (
      if ((((((nzi \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg)))))))) then
        True
      else False )" 
  for  nzi  :: "(6)Word.word " 
  and  rsd  :: "(5)Word.word "
|" assembly_forwards_matches (C_JAL (imm)) = ( if ((((( 32 :: int)::ii) = (( 32 :: int)::ii)))) then True else False )" 
  for  imm  :: "(11)Word.word "
|" assembly_forwards_matches (C_ADDIW ((imm, rsd))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rsd  :: "(5)Word.word " 
  and  imm  :: "(6)Word.word "
|" assembly_forwards_matches (C_LI ((imm, rd))) = (
      if (((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) then True else False )" 
  for  imm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (C_ADDI16SP (imm)) = (
      if (((imm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) then True else False )" 
  for  imm  :: "(6)Word.word "
|" assembly_forwards_matches (C_LUI ((imm, rd))) = (
      if ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno sp))))) \<and> (((imm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))))))))) then
        True
      else False )" 
  for  imm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (C_SRLI ((shamt, rsd))) = (
      if (((shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) then True else False )" 
  for  rsd  :: "(3)Word.word " 
  and  shamt  :: "(6)Word.word "
|" assembly_forwards_matches (C_SRAI ((shamt, rsd))) = (
      if (((shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) then True else False )" 
  for  rsd  :: "(3)Word.word " 
  and  shamt  :: "(6)Word.word "
|" assembly_forwards_matches (C_ANDI ((imm, rsd))) = ( True )" 
  for  rsd  :: "(3)Word.word " 
  and  imm  :: "(6)Word.word "
|" assembly_forwards_matches (C_SUB ((rsd, rs2))) = ( True )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards_matches (C_XOR ((rsd, rs2))) = ( True )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards_matches (C_OR ((rsd, rs2))) = ( True )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards_matches (C_AND ((rsd, rs2))) = ( True )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards_matches (C_SUBW ((rsd, rs2))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards_matches (C_ADDW ((rsd, rs2))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rsd  :: "(3)Word.word " 
  and  rs2  :: "(3)Word.word "
|" assembly_forwards_matches (C_J (imm)) = ( True )" 
  for  imm  :: "(11)Word.word "
|" assembly_forwards_matches (C_BEQZ ((imm, rs))) = ( True )" 
  for  rs  :: "(3)Word.word " 
  and  imm  :: "(8)Word.word "
|" assembly_forwards_matches (C_BNEZ ((imm, rs))) = ( True )" 
  for  rs  :: "(3)Word.word " 
  and  imm  :: "(8)Word.word "
|" assembly_forwards_matches (C_SLLI ((shamt, rsd))) = (
      if ((((((shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg)))))))) then
        True
      else False )" 
  for  rsd  :: "(5)Word.word " 
  and  shamt  :: "(6)Word.word "
|" assembly_forwards_matches (C_LWSP ((uimm, rd))) = (
      if (((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) then True else False )" 
  for  uimm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (C_LDSP ((uimm, rd))) = (
      if ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))))
      then
        True
      else False )" 
  for  uimm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (C_SWSP ((uimm, rd))) = ( True )" 
  for  uimm  :: "(6)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (C_SDSP ((uimm, rs2))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  uimm  :: "(6)Word.word " 
  and  rs2  :: "(5)Word.word "
|" assembly_forwards_matches (C_JR (rs1)) = ( if (((((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) then True else False )" 
  for  rs1  :: "(5)Word.word "
|" assembly_forwards_matches (C_JALR (rs1)) = (
      if (((((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg))))) then True else False )" 
  for  rs1  :: "(5)Word.word "
|" assembly_forwards_matches (C_MV ((rd, rs2))) = (
      if ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg)))))))) then
        True
      else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (C_EBREAK (_)) = ( True )"
|" assembly_forwards_matches (C_ADD ((rsd, rs2))) = (
      if ((((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg)))))))) then
        True
      else False )" 
  for  rsd  :: "(5)Word.word " 
  and  rs2  :: "(5)Word.word "
|" assembly_forwards_matches (MUL ((rs2, rs1, rd, high, signed1, signed2))) = ( True )" 
  for  signed2  :: " bool " 
  and  signed1  :: " bool " 
  and  high  :: " bool " 
  and  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (DIV ((rs2, rs1, rd, s))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" assembly_forwards_matches (REM ((rs2, rs1, rd, s))) = ( True )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" assembly_forwards_matches (MULW ((rs2, rs1, rd))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word "
|" assembly_forwards_matches (DIVW ((rs2, rs1, rd, s))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" assembly_forwards_matches (REMW ((rs2, rs1, rd, s))) = ( if ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))) then True else False )" 
  for  rs2  :: "(5)Word.word " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  s  :: " bool "
|" assembly_forwards_matches (CSR ((csr, rs1, rd, True, op1))) = ( True )" 
  for  op1  :: " csrop " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  csr  :: "(12)Word.word "
|" assembly_forwards_matches (CSR ((csr, rs1, rd, False, op1))) = ( True )" 
  for  op1  :: " csrop " 
  and  rs1  :: "(5)Word.word " 
  and  rd  :: "(5)Word.word " 
  and  csr  :: "(12)Word.word "
|" assembly_forwards_matches (URET (_)) = ( True )"
|" assembly_forwards_matches (ILLEGAL (s)) = ( True )" 
  for  s  :: "(32)Word.word "
|" assembly_forwards_matches (C_ILLEGAL (s)) = ( True )" 
  for  s  :: "(16)Word.word "


\<comment> \<open>\<open>val assembly_backwards_matches : string -> bool\<close>\<close>

\<comment> \<open>\<open>val _s2549_ : string -> maybe (mword ty16)\<close>\<close>

definition s2549  :: " string \<Rightarrow>((16)Word.word)option "  where 
     " s2549 s25500 = (
   (let s25510 = s25500 in
   if ((string_startswith s25510 (''c.illegal''))) then  
  (case  ((string_drop s25510 ((string_length (''c.illegal''))))) of
        s25520 =>
  (case  ((spc_matches_prefix0 s25520)) of
        Some ((_, s25530)) =>
  (case  ((string_drop s25520 s25530)) of
        s25540 =>
  (case  ((hex_bits_16_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s25540 :: (( 16 Word.word * ii)) option)) of
        Some ((s, s25550)) =>
  (let p00 = (string_drop s25540 s25550) in
  if (((p00 = ('''')))) then Some s else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s25500  :: " string "


\<comment> \<open>\<open>val _s2541_ : string -> maybe (mword ty32)\<close>\<close>

definition s2541  :: " string \<Rightarrow>((32)Word.word)option "  where 
     " s2541 s25420 = (
   (let s25430 = s25420 in
   if ((string_startswith s25430 (''illegal''))) then  
  (case  ((string_drop s25430 ((string_length (''illegal''))))) of
        s25440 =>
  (case  ((spc_matches_prefix0 s25440)) of
        Some ((_, s25450)) =>
  (case  ((string_drop s25440 s25450)) of
        s25460 =>
  (case  ((hex_bits_32_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s25460 :: (( 32 Word.word * ii)) option)) of
        Some ((s, s25470)) =>
  (let p00 = (string_drop s25460 s25470) in
  if (((p00 = ('''')))) then Some s else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s25420  :: " string "


\<comment> \<open>\<open>val _s2524_ : string -> maybe ((csrop * mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s2524  :: " string \<Rightarrow>(csrop*(5)Word.word*(5)Word.word*(12)Word.word)option "  where 
     " s2524 s25260 = (
      (case  ((csr_mnemonic_matches_prefix s25260)) of
        Some ((op1, s25270)) => 
  (case  ((string_drop s25260 s25270)) of
        s25280 =>
  (case  ((spc_matches_prefix0 s25280)) of
        Some ((_, s25290)) =>
  (case  ((string_drop s25280 s25290)) of
        s25300 =>
  (case  ((reg_name_matches_prefix s25300 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s25310)) =>
  (case  ((string_drop s25300 s25310)) of
        s25320 =>
  (case  ((sep_matches_prefix s25320)) of
        Some ((_, s25330)) =>
  (case  ((string_drop s25320 s25330)) of
        s25340 =>
  (case  ((reg_name_matches_prefix s25340 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s25350)) =>
  (case  ((string_drop s25340 s25350)) of
        s25360 =>
  (case  ((sep_matches_prefix s25360)) of
        Some ((_, s25370)) =>
  (case  ((string_drop s25360 s25370)) of
        s25380 =>
  (case  ((csr_name_map_matches_prefix s25380
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s25390)) =>
  (let p00 = (string_drop s25380 s25390) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, csr) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s25260  :: " string "


\<comment> \<open>\<open>val _s2506_ : string -> maybe ((csrop * mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s2506  :: " string \<Rightarrow>(csrop*(5)Word.word*(5)Word.word*(12)Word.word)option "  where 
     " s2506 s25080 = (
      (case  ((csr_mnemonic_matches_prefix s25080)) of
        Some ((op1, s25090)) =>
         (let s25100 = (string_drop s25080 s25090) in
         if ((string_startswith s25100 (''i''))) then  
  (case  ((string_drop s25100 ((string_length (''i''))))) of
        s25110 =>
  (case  ((spc_matches_prefix0 s25110)) of
        Some ((_, s25120)) =>
  (case  ((string_drop s25110 s25120)) of
        s25130 =>
  (case  ((reg_name_matches_prefix s25130 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s25140)) =>
  (case  ((string_drop s25130 s25140)) of
        s25150 =>
  (case  ((sep_matches_prefix s25150)) of
        Some ((_, s25160)) =>
  (case  ((string_drop s25150 s25160)) of
        s25170 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s25170 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s25180)) =>
  (case  ((string_drop s25170 s25180)) of
        s25190 =>
  (case  ((sep_matches_prefix s25190)) of
        Some ((_, s25200)) =>
  (case  ((string_drop s25190 s25200)) of
        s25210 =>
  (case  ((csr_name_map_matches_prefix s25210
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s25220)) =>
  (let p00 = (string_drop s25210 s25220) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, csr) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))" 
  for  s25080  :: " string "


\<comment> \<open>\<open>val _s2487_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2487  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s2487 s24880 = (
   (let s24890 = s24880 in
   if ((string_startswith s24890 (''rem''))) then  
  (case  ((string_drop s24890 ((string_length (''rem''))))) of
        s24900 =>
  (case  ((maybe_not_u_matches_prefix s24900)) of
        Some ((s, s24910)) =>
  (let s24920 = (string_drop s24900 s24910) in
  if ((string_startswith s24920 (''w''))) then
    (case  ((string_drop s24920 ((string_length (''w''))))) of
          s24930 =>
    (case  ((spc_matches_prefix0 s24930)) of
          Some ((_, s24940)) =>
    (case  ((string_drop s24930 s24940)) of
          s24950 =>
    (case  ((reg_name_matches_prefix s24950 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s24960)) =>
    (case  ((string_drop s24950 s24960)) of
          s24970 =>
    (case  ((sep_matches_prefix s24970)) of
          Some ((_, s24980)) =>
    (case  ((string_drop s24970 s24980)) of
          s24990 =>
    (case  ((reg_name_matches_prefix s24990 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s25000)) =>
    (case  ((string_drop s24990 s25000)) of
          s25010 =>
    (case  ((sep_matches_prefix s25010)) of
          Some ((_, s25020)) =>
    (case  ((string_drop s25010 s25020)) of
          s25030 =>
    (case  ((reg_name_matches_prefix s25030 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s25040)) =>
    (let p00 = (string_drop s25030 s25040) in
    if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))" 
  for  s24880  :: " string "


\<comment> \<open>\<open>val _s2468_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2468  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s2468 s24690 = (
   (let s24700 = s24690 in
   if ((string_startswith s24700 (''div''))) then  
  (case  ((string_drop s24700 ((string_length (''div''))))) of
        s24710 =>
  (case  ((maybe_not_u_matches_prefix s24710)) of
        Some ((s, s24720)) =>
  (let s24730 = (string_drop s24710 s24720) in
  if ((string_startswith s24730 (''w''))) then
    (case  ((string_drop s24730 ((string_length (''w''))))) of
          s24740 =>
    (case  ((spc_matches_prefix0 s24740)) of
          Some ((_, s24750)) =>
    (case  ((string_drop s24740 s24750)) of
          s24760 =>
    (case  ((reg_name_matches_prefix s24760 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s24770)) =>
    (case  ((string_drop s24760 s24770)) of
          s24780 =>
    (case  ((sep_matches_prefix s24780)) of
          Some ((_, s24790)) =>
    (case  ((string_drop s24780 s24790)) of
          s24800 =>
    (case  ((reg_name_matches_prefix s24800 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s24810)) =>
    (case  ((string_drop s24800 s24810)) of
          s24820 =>
    (case  ((sep_matches_prefix s24820)) of
          Some ((_, s24830)) =>
    (case  ((string_drop s24820 s24830)) of
          s24840 =>
    (case  ((reg_name_matches_prefix s24840 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s24850)) =>
    (let p00 = (string_drop s24840 s24850) in
    if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))" 
  for  s24690  :: " string "


\<comment> \<open>\<open>val _s2452_ : string -> maybe ((mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2452  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s2452 s24530 = (
   (let s24540 = s24530 in
   if ((string_startswith s24540 (''mulw''))) then  
  (case  ((string_drop s24540 ((string_length (''mulw''))))) of
        s24550 =>
  (case  ((spc_matches_prefix0 s24550)) of
        Some ((_, s24560)) =>
  (case  ((string_drop s24550 s24560)) of
        s24570 =>
  (case  ((reg_name_matches_prefix s24570 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s24580)) =>
  (case  ((string_drop s24570 s24580)) of
        s24590 =>
  (case  ((sep_matches_prefix s24590)) of
        Some ((_, s24600)) =>
  (case  ((string_drop s24590 s24600)) of
        s24610 =>
  (case  ((reg_name_matches_prefix s24610 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s24620)) =>
  (case  ((string_drop s24610 s24620)) of
        s24630 =>
  (case  ((sep_matches_prefix s24630)) of
        Some ((_, s24640)) =>
  (case  ((string_drop s24630 s24640)) of
        s24650 =>
  (case  ((reg_name_matches_prefix s24650 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s24660)) =>
  (let p00 = (string_drop s24650 s24660) in
  if (((p00 = ('''')))) then Some (rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s24530  :: " string "


\<comment> \<open>\<open>val _s2434_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2434  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s2434 s24350 = (
   (let s24360 = s24350 in
   if ((string_startswith s24360 (''rem''))) then  
  (case  ((string_drop s24360 ((string_length (''rem''))))) of
        s24370 =>
  (case  ((maybe_not_u_matches_prefix s24370)) of
        Some ((s, s24380)) =>
  (case  ((string_drop s24370 s24380)) of
        s24390 =>
  (case  ((spc_matches_prefix0 s24390)) of
        Some ((_, s24400)) =>
  (case  ((string_drop s24390 s24400)) of
        s24410 =>
  (case  ((reg_name_matches_prefix s24410 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s24420)) =>
  (case  ((string_drop s24410 s24420)) of
        s24430 =>
  (case  ((sep_matches_prefix s24430)) of
        Some ((_, s24440)) =>
  (case  ((string_drop s24430 s24440)) of
        s24450 =>
  (case  ((reg_name_matches_prefix s24450 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s24460)) =>
  (case  ((string_drop s24450 s24460)) of
        s24470 =>
  (case  ((sep_matches_prefix s24470)) of
        Some ((_, s24480)) =>
  (case  ((string_drop s24470 s24480)) of
        s24490 =>
  (case  ((reg_name_matches_prefix s24490 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s24500)) =>
  (let p00 = (string_drop s24490 s24500) in
  if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s24350  :: " string "


\<comment> \<open>\<open>val _s2416_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2416  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s2416 s24170 = (
   (let s24180 = s24170 in
   if ((string_startswith s24180 (''div''))) then  
  (case  ((string_drop s24180 ((string_length (''div''))))) of
        s24190 =>
  (case  ((maybe_not_u_matches_prefix s24190)) of
        Some ((s, s24200)) =>
  (case  ((string_drop s24190 s24200)) of
        s24210 =>
  (case  ((spc_matches_prefix0 s24210)) of
        Some ((_, s24220)) =>
  (case  ((string_drop s24210 s24220)) of
        s24230 =>
  (case  ((reg_name_matches_prefix s24230 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s24240)) =>
  (case  ((string_drop s24230 s24240)) of
        s24250 =>
  (case  ((sep_matches_prefix s24250)) of
        Some ((_, s24260)) =>
  (case  ((string_drop s24250 s24260)) of
        s24270 =>
  (case  ((reg_name_matches_prefix s24270 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s24280)) =>
  (case  ((string_drop s24270 s24280)) of
        s24290 =>
  (case  ((sep_matches_prefix s24290)) of
        Some ((_, s24300)) =>
  (case  ((string_drop s24290 s24300)) of
        s24310 =>
  (case  ((reg_name_matches_prefix s24310 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s24320)) =>
  (let p00 = (string_drop s24310 s24320) in
  if (((p00 = ('''')))) then Some (s, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s24170  :: " string "


\<comment> \<open>\<open>val _s2399_ : string -> maybe ((bool * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s2399  :: " string \<Rightarrow>(bool*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s2399 s24010 = (
      (case  ((mul_mnemonic_matches_prefix s24010)) of
        Some (((high, signed1, signed2), s24020)) => 
  (case  ((string_drop s24010 s24020)) of
        s24030 =>
  (case  ((spc_matches_prefix0 s24030)) of
        Some ((_, s24040)) =>
  (case  ((string_drop s24030 s24040)) of
        s24050 =>
  (case  ((reg_name_matches_prefix s24050 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s24060)) =>
  (case  ((string_drop s24050 s24060)) of
        s24070 =>
  (case  ((sep_matches_prefix s24070)) of
        Some ((_, s24080)) =>
  (case  ((string_drop s24070 s24080)) of
        s24090 =>
  (case  ((reg_name_matches_prefix s24090 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s24100)) =>
  (case  ((string_drop s24090 s24100)) of
        s24110 =>
  (case  ((sep_matches_prefix s24110)) of
        Some ((_, s24120)) =>
  (case  ((string_drop s24110 s24120)) of
        s24130 =>
  (case  ((reg_name_matches_prefix s24130 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s24140)) =>
  (let p00 = (string_drop s24130 s24140) in
  if (((p00 = ('''')))) then Some (high, signed1, signed2, rd, rs1, rs2) else
    None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s24010  :: " string "


\<comment> \<open>\<open>val _s2387_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s2387  :: " string \<Rightarrow>((5)Word.word*(5)Word.word)option "  where 
     " s2387 s23880 = (
   (let s23890 = s23880 in
   if ((string_startswith s23890 (''c.add''))) then  
  (case  ((string_drop s23890 ((string_length (''c.add''))))) of
        s23900 =>
  (case  ((spc_matches_prefix0 s23900)) of
        Some ((_, s23910)) =>
  (case  ((string_drop s23900 s23910)) of
        s23920 =>
  (case  ((reg_name_matches_prefix s23920 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s23930)) =>
  (case  ((string_drop s23920 s23930)) of
        s23940 =>
  (case  ((sep_matches_prefix s23940)) of
        Some ((_, s23950)) =>
  (case  ((string_drop s23940 s23950)) of
        s23960 =>
  (case  ((reg_name_matches_prefix s23960 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s23970)) =>
  (let p00 = (string_drop s23960 s23970) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s23880  :: " string "


\<comment> \<open>\<open>val _s2375_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s2375  :: " string \<Rightarrow>((5)Word.word*(5)Word.word)option "  where 
     " s2375 s23760 = (
   (let s23770 = s23760 in
   if ((string_startswith s23770 (''c.mv''))) then  
  (case  ((string_drop s23770 ((string_length (''c.mv''))))) of
        s23780 =>
  (case  ((spc_matches_prefix0 s23780)) of
        Some ((_, s23790)) =>
  (case  ((string_drop s23780 s23790)) of
        s23800 =>
  (case  ((reg_name_matches_prefix s23800 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s23810)) =>
  (case  ((string_drop s23800 s23810)) of
        s23820 =>
  (case  ((sep_matches_prefix s23820)) of
        Some ((_, s23830)) =>
  (case  ((string_drop s23820 s23830)) of
        s23840 =>
  (case  ((reg_name_matches_prefix s23840 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s23850)) =>
  (let p00 = (string_drop s23840 s23850) in
  if (((p00 = ('''')))) then Some (rd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s23760  :: " string "


\<comment> \<open>\<open>val _s2367_ : string -> maybe (mword ty5)\<close>\<close>

definition s2367  :: " string \<Rightarrow>((5)Word.word)option "  where 
     " s2367 s23680 = (
   (let s23690 = s23680 in
   if ((string_startswith s23690 (''c.jalr''))) then  
  (case  ((string_drop s23690 ((string_length (''c.jalr''))))) of
        s23700 =>
  (case  ((spc_matches_prefix0 s23700)) of
        Some ((_, s23710)) =>
  (case  ((string_drop s23700 s23710)) of
        s23720 =>
  (case  ((reg_name_matches_prefix s23720 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s23730)) =>
  (let p00 = (string_drop s23720 s23730) in
  if (((p00 = ('''')))) then Some rs1 else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s23680  :: " string "


\<comment> \<open>\<open>val _s2359_ : string -> maybe (mword ty5)\<close>\<close>

definition s2359  :: " string \<Rightarrow>((5)Word.word)option "  where 
     " s2359 s23600 = (
   (let s23610 = s23600 in
   if ((string_startswith s23610 (''c.jr''))) then  
  (case  ((string_drop s23610 ((string_length (''c.jr''))))) of
        s23620 =>
  (case  ((spc_matches_prefix0 s23620)) of
        Some ((_, s23630)) =>
  (case  ((string_drop s23620 s23630)) of
        s23640 =>
  (case  ((reg_name_matches_prefix s23640 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s23650)) =>
  (let p00 = (string_drop s23640 s23650) in
  if (((p00 = ('''')))) then Some rs1 else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s23600  :: " string "


\<comment> \<open>\<open>val _s2347_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2347  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s2347 s23480 = (
   (let s23490 = s23480 in
   if ((string_startswith s23490 (''c.sdsp''))) then  
  (case  ((string_drop s23490 ((string_length (''c.sdsp''))))) of
        s23500 =>
  (case  ((spc_matches_prefix0 s23500)) of
        Some ((_, s23510)) =>
  (case  ((string_drop s23500 s23510)) of
        s23520 =>
  (case  ((reg_name_matches_prefix s23520 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s23530)) =>
  (case  ((string_drop s23520 s23530)) of
        s23540 =>
  (case  ((sep_matches_prefix s23540)) of
        Some ((_, s23550)) =>
  (case  ((string_drop s23540 s23550)) of
        s23560 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s23560 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s23570)) =>
  (let p00 = (string_drop s23560 s23570) in
  if (((p00 = ('''')))) then Some (rs2, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s23480  :: " string "


\<comment> \<open>\<open>val _s2335_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2335  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s2335 s23360 = (
   (let s23370 = s23360 in
   if ((string_startswith s23370 (''c.swsp''))) then  
  (case  ((string_drop s23370 ((string_length (''c.swsp''))))) of
        s23380 =>
  (case  ((spc_matches_prefix0 s23380)) of
        Some ((_, s23390)) =>
  (case  ((string_drop s23380 s23390)) of
        s23400 =>
  (case  ((reg_name_matches_prefix s23400 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s23410)) =>
  (case  ((string_drop s23400 s23410)) of
        s23420 =>
  (case  ((sep_matches_prefix s23420)) of
        Some ((_, s23430)) =>
  (case  ((string_drop s23420 s23430)) of
        s23440 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s23440 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s23450)) =>
  (let p00 = (string_drop s23440 s23450) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s23360  :: " string "


\<comment> \<open>\<open>val _s2323_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2323  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s2323 s23240 = (
   (let s23250 = s23240 in
   if ((string_startswith s23250 (''c.ldsp''))) then  
  (case  ((string_drop s23250 ((string_length (''c.ldsp''))))) of
        s23260 =>
  (case  ((spc_matches_prefix0 s23260)) of
        Some ((_, s23270)) =>
  (case  ((string_drop s23260 s23270)) of
        s23280 =>
  (case  ((reg_name_matches_prefix s23280 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s23290)) =>
  (case  ((string_drop s23280 s23290)) of
        s23300 =>
  (case  ((sep_matches_prefix s23300)) of
        Some ((_, s23310)) =>
  (case  ((string_drop s23300 s23310)) of
        s23320 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s23320 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s23330)) =>
  (let p00 = (string_drop s23320 s23330) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s23240  :: " string "


\<comment> \<open>\<open>val _s2311_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2311  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s2311 s23120 = (
   (let s23130 = s23120 in
   if ((string_startswith s23130 (''c.lwsp''))) then  
  (case  ((string_drop s23130 ((string_length (''c.lwsp''))))) of
        s23140 =>
  (case  ((spc_matches_prefix0 s23140)) of
        Some ((_, s23150)) =>
  (case  ((string_drop s23140 s23150)) of
        s23160 =>
  (case  ((reg_name_matches_prefix s23160 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s23170)) =>
  (case  ((string_drop s23160 s23170)) of
        s23180 =>
  (case  ((sep_matches_prefix s23180)) of
        Some ((_, s23190)) =>
  (case  ((string_drop s23180 s23190)) of
        s23200 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s23200 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s23210)) =>
  (let p00 = (string_drop s23200 s23210) in
  if (((p00 = ('''')))) then Some (rd, uimm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s23120  :: " string "


\<comment> \<open>\<open>val _s2299_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2299  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s2299 s23000 = (
   (let s23010 = s23000 in
   if ((string_startswith s23010 (''c.slli''))) then  
  (case  ((string_drop s23010 ((string_length (''c.slli''))))) of
        s23020 =>
  (case  ((spc_matches_prefix0 s23020)) of
        Some ((_, s23030)) =>
  (case  ((string_drop s23020 s23030)) of
        s23040 =>
  (case  ((reg_name_matches_prefix s23040 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s23050)) =>
  (case  ((string_drop s23040 s23050)) of
        s23060 =>
  (case  ((sep_matches_prefix s23060)) of
        Some ((_, s23070)) =>
  (case  ((string_drop s23060 s23070)) of
        s23080 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s23080 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s23090)) =>
  (let p00 = (string_drop s23080 s23090) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s23000  :: " string "


\<comment> \<open>\<open>val _s2287_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s2287  :: " string \<Rightarrow>((3)Word.word*(8)Word.word)option "  where 
     " s2287 s22880 = (
   (let s22890 = s22880 in
   if ((string_startswith s22890 (''c.bnez''))) then  
  (case  ((string_drop s22890 ((string_length (''c.bnez''))))) of
        s22900 =>
  (case  ((spc_matches_prefix0 s22900)) of
        Some ((_, s22910)) =>
  (case  ((string_drop s22900 s22910)) of
        s22920 =>
  (case  ((creg_name_matches_prefix s22920 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s22930)) =>
  (case  ((string_drop s22920 s22930)) of
        s22940 =>
  (case  ((sep_matches_prefix s22940)) of
        Some ((_, s22950)) =>
  (case  ((string_drop s22940 s22950)) of
        s22960 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s22960 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s22970)) =>
  (let p00 = (string_drop s22960 s22970) in
  if (((p00 = ('''')))) then Some (rs, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s22880  :: " string "


\<comment> \<open>\<open>val _s2275_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s2275  :: " string \<Rightarrow>((3)Word.word*(8)Word.word)option "  where 
     " s2275 s22760 = (
   (let s22770 = s22760 in
   if ((string_startswith s22770 (''c.beqz''))) then  
  (case  ((string_drop s22770 ((string_length (''c.beqz''))))) of
        s22780 =>
  (case  ((spc_matches_prefix0 s22780)) of
        Some ((_, s22790)) =>
  (case  ((string_drop s22780 s22790)) of
        s22800 =>
  (case  ((creg_name_matches_prefix s22800 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s22810)) =>
  (case  ((string_drop s22800 s22810)) of
        s22820 =>
  (case  ((sep_matches_prefix s22820)) of
        Some ((_, s22830)) =>
  (case  ((string_drop s22820 s22830)) of
        s22840 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s22840 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s22850)) =>
  (let p00 = (string_drop s22840 s22850) in
  if (((p00 = ('''')))) then Some (rs, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s22760  :: " string "


\<comment> \<open>\<open>val _s2267_ : string -> maybe (mword ty11)\<close>\<close>

definition s2267  :: " string \<Rightarrow>((11)Word.word)option "  where 
     " s2267 s22680 = (
   (let s22690 = s22680 in
   if ((string_startswith s22690 (''c.j''))) then  
  (case  ((string_drop s22690 ((string_length (''c.j''))))) of
        s22700 =>
  (case  ((spc_matches_prefix0 s22700)) of
        Some ((_, s22710)) =>
  (case  ((string_drop s22700 s22710)) of
        s22720 =>
  (case  ((hex_bits_11_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s22720 :: (( 11 Word.word * ii)) option)) of
        Some ((imm, s22730)) =>
  (let p00 = (string_drop s22720 s22730) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s22680  :: " string "


\<comment> \<open>\<open>val _s2255_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s2255  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s2255 s22560 = (
   (let s22570 = s22560 in
   if ((string_startswith s22570 (''c.addw''))) then  
  (case  ((string_drop s22570 ((string_length (''c.addw''))))) of
        s22580 =>
  (case  ((spc_matches_prefix0 s22580)) of
        Some ((_, s22590)) =>
  (case  ((string_drop s22580 s22590)) of
        s22600 =>
  (case  ((creg_name_matches_prefix s22600 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s22610)) =>
  (case  ((string_drop s22600 s22610)) of
        s22620 =>
  (case  ((sep_matches_prefix s22620)) of
        Some ((_, s22630)) =>
  (case  ((string_drop s22620 s22630)) of
        s22640 =>
  (case  ((creg_name_matches_prefix s22640 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s22650)) =>
  (let p00 = (string_drop s22640 s22650) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s22560  :: " string "


\<comment> \<open>\<open>val _s2243_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s2243  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s2243 s22440 = (
   (let s22450 = s22440 in
   if ((string_startswith s22450 (''c.subw''))) then  
  (case  ((string_drop s22450 ((string_length (''c.subw''))))) of
        s22460 =>
  (case  ((spc_matches_prefix0 s22460)) of
        Some ((_, s22470)) =>
  (case  ((string_drop s22460 s22470)) of
        s22480 =>
  (case  ((creg_name_matches_prefix s22480 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s22490)) =>
  (case  ((string_drop s22480 s22490)) of
        s22500 =>
  (case  ((sep_matches_prefix s22500)) of
        Some ((_, s22510)) =>
  (case  ((string_drop s22500 s22510)) of
        s22520 =>
  (case  ((creg_name_matches_prefix s22520 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s22530)) =>
  (let p00 = (string_drop s22520 s22530) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s22440  :: " string "


\<comment> \<open>\<open>val _s2231_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s2231  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s2231 s22320 = (
   (let s22330 = s22320 in
   if ((string_startswith s22330 (''c.and''))) then  
  (case  ((string_drop s22330 ((string_length (''c.and''))))) of
        s22340 =>
  (case  ((spc_matches_prefix0 s22340)) of
        Some ((_, s22350)) =>
  (case  ((string_drop s22340 s22350)) of
        s22360 =>
  (case  ((creg_name_matches_prefix s22360 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s22370)) =>
  (case  ((string_drop s22360 s22370)) of
        s22380 =>
  (case  ((sep_matches_prefix s22380)) of
        Some ((_, s22390)) =>
  (case  ((string_drop s22380 s22390)) of
        s22400 =>
  (case  ((creg_name_matches_prefix s22400 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s22410)) =>
  (let p00 = (string_drop s22400 s22410) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s22320  :: " string "


\<comment> \<open>\<open>val _s2219_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s2219  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s2219 s22200 = (
   (let s22210 = s22200 in
   if ((string_startswith s22210 (''c.or''))) then  
  (case  ((string_drop s22210 ((string_length (''c.or''))))) of
        s22220 =>
  (case  ((spc_matches_prefix0 s22220)) of
        Some ((_, s22230)) =>
  (case  ((string_drop s22220 s22230)) of
        s22240 =>
  (case  ((creg_name_matches_prefix s22240 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s22250)) =>
  (case  ((string_drop s22240 s22250)) of
        s22260 =>
  (case  ((sep_matches_prefix s22260)) of
        Some ((_, s22270)) =>
  (case  ((string_drop s22260 s22270)) of
        s22280 =>
  (case  ((creg_name_matches_prefix s22280 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s22290)) =>
  (let p00 = (string_drop s22280 s22290) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s22200  :: " string "


\<comment> \<open>\<open>val _s2207_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s2207  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s2207 s22080 = (
   (let s22090 = s22080 in
   if ((string_startswith s22090 (''c.xor''))) then  
  (case  ((string_drop s22090 ((string_length (''c.xor''))))) of
        s22100 =>
  (case  ((spc_matches_prefix0 s22100)) of
        Some ((_, s22110)) =>
  (case  ((string_drop s22100 s22110)) of
        s22120 =>
  (case  ((creg_name_matches_prefix s22120 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s22130)) =>
  (case  ((string_drop s22120 s22130)) of
        s22140 =>
  (case  ((sep_matches_prefix s22140)) of
        Some ((_, s22150)) =>
  (case  ((string_drop s22140 s22150)) of
        s22160 =>
  (case  ((creg_name_matches_prefix s22160 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s22170)) =>
  (let p00 = (string_drop s22160 s22170) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s22080  :: " string "


\<comment> \<open>\<open>val _s2195_ : string -> maybe ((mword ty3 * mword ty3))\<close>\<close>

definition s2195  :: " string \<Rightarrow>((3)Word.word*(3)Word.word)option "  where 
     " s2195 s21960 = (
   (let s21970 = s21960 in
   if ((string_startswith s21970 (''c.sub''))) then  
  (case  ((string_drop s21970 ((string_length (''c.sub''))))) of
        s21980 =>
  (case  ((spc_matches_prefix0 s21980)) of
        Some ((_, s21990)) =>
  (case  ((string_drop s21980 s21990)) of
        s22000 =>
  (case  ((creg_name_matches_prefix s22000 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s22010)) =>
  (case  ((string_drop s22000 s22010)) of
        s22020 =>
  (case  ((sep_matches_prefix s22020)) of
        Some ((_, s22030)) =>
  (case  ((string_drop s22020 s22030)) of
        s22040 =>
  (case  ((creg_name_matches_prefix s22040 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s22050)) =>
  (let p00 = (string_drop s22040 s22050) in
  if (((p00 = ('''')))) then Some (rsd, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s21960  :: " string "


\<comment> \<open>\<open>val _s2183_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s2183  :: " string \<Rightarrow>((3)Word.word*(6)Word.word)option "  where 
     " s2183 s21840 = (
   (let s21850 = s21840 in
   if ((string_startswith s21850 (''c.andi''))) then  
  (case  ((string_drop s21850 ((string_length (''c.andi''))))) of
        s21860 =>
  (case  ((spc_matches_prefix0 s21860)) of
        Some ((_, s21870)) =>
  (case  ((string_drop s21860 s21870)) of
        s21880 =>
  (case  ((creg_name_matches_prefix s21880 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s21890)) =>
  (case  ((string_drop s21880 s21890)) of
        s21900 =>
  (case  ((sep_matches_prefix s21900)) of
        Some ((_, s21910)) =>
  (case  ((string_drop s21900 s21910)) of
        s21920 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s21920 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s21930)) =>
  (let p00 = (string_drop s21920 s21930) in
  if (((p00 = ('''')))) then Some (rsd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s21840  :: " string "


\<comment> \<open>\<open>val _s2171_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s2171  :: " string \<Rightarrow>((3)Word.word*(6)Word.word)option "  where 
     " s2171 s21720 = (
   (let s21730 = s21720 in
   if ((string_startswith s21730 (''c.srai''))) then  
  (case  ((string_drop s21730 ((string_length (''c.srai''))))) of
        s21740 =>
  (case  ((spc_matches_prefix0 s21740)) of
        Some ((_, s21750)) =>
  (case  ((string_drop s21740 s21750)) of
        s21760 =>
  (case  ((creg_name_matches_prefix s21760 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s21770)) =>
  (case  ((string_drop s21760 s21770)) of
        s21780 =>
  (case  ((sep_matches_prefix s21780)) of
        Some ((_, s21790)) =>
  (case  ((string_drop s21780 s21790)) of
        s21800 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s21800 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s21810)) =>
  (let p00 = (string_drop s21800 s21810) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s21720  :: " string "


\<comment> \<open>\<open>val _s2159_ : string -> maybe ((mword ty3 * mword ty6))\<close>\<close>

definition s2159  :: " string \<Rightarrow>((3)Word.word*(6)Word.word)option "  where 
     " s2159 s21600 = (
   (let s21610 = s21600 in
   if ((string_startswith s21610 (''c.srli''))) then  
  (case  ((string_drop s21610 ((string_length (''c.srli''))))) of
        s21620 =>
  (case  ((spc_matches_prefix0 s21620)) of
        Some ((_, s21630)) =>
  (case  ((string_drop s21620 s21630)) of
        s21640 =>
  (case  ((creg_name_matches_prefix s21640 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s21650)) =>
  (case  ((string_drop s21640 s21650)) of
        s21660 =>
  (case  ((sep_matches_prefix s21660)) of
        Some ((_, s21670)) =>
  (case  ((string_drop s21660 s21670)) of
        s21680 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s21680 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s21690)) =>
  (let p00 = (string_drop s21680 s21690) in
  if (((p00 = ('''')))) then Some (rsd, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s21600  :: " string "


\<comment> \<open>\<open>val _s2147_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2147  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s2147 s21480 = (
   (let s21490 = s21480 in
   if ((string_startswith s21490 (''c.lui''))) then  
  (case  ((string_drop s21490 ((string_length (''c.lui''))))) of
        s21500 =>
  (case  ((spc_matches_prefix0 s21500)) of
        Some ((_, s21510)) =>
  (case  ((string_drop s21500 s21510)) of
        s21520 =>
  (case  ((reg_name_matches_prefix s21520 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s21530)) =>
  (case  ((string_drop s21520 s21530)) of
        s21540 =>
  (case  ((sep_matches_prefix s21540)) of
        Some ((_, s21550)) =>
  (case  ((string_drop s21540 s21550)) of
        s21560 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s21560 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s21570)) =>
  (let p00 = (string_drop s21560 s21570) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s21480  :: " string "


\<comment> \<open>\<open>val _s2139_ : string -> maybe (mword ty6)\<close>\<close>

definition s2139  :: " string \<Rightarrow>((6)Word.word)option "  where 
     " s2139 s21400 = (
   (let s21410 = s21400 in
   if ((string_startswith s21410 (''c.addi16sp''))) then  
  (case  ((string_drop s21410 ((string_length (''c.addi16sp''))))) of
        s21420 =>
  (case  ((spc_matches_prefix0 s21420)) of
        Some ((_, s21430)) =>
  (case  ((string_drop s21420 s21430)) of
        s21440 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s21440 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s21450)) =>
  (let p00 = (string_drop s21440 s21450) in
  if (((p00 = ('''')))) then Some imm else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s21400  :: " string "


\<comment> \<open>\<open>val _s2127_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2127  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s2127 s21280 = (
   (let s21290 = s21280 in
   if ((string_startswith s21290 (''c.li''))) then  
  (case  ((string_drop s21290 ((string_length (''c.li''))))) of
        s21300 =>
  (case  ((spc_matches_prefix0 s21300)) of
        Some ((_, s21310)) =>
  (case  ((string_drop s21300 s21310)) of
        s21320 =>
  (case  ((reg_name_matches_prefix s21320 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s21330)) =>
  (case  ((string_drop s21320 s21330)) of
        s21340 =>
  (case  ((sep_matches_prefix s21340)) of
        Some ((_, s21350)) =>
  (case  ((string_drop s21340 s21350)) of
        s21360 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s21360 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s21370)) =>
  (let p00 = (string_drop s21360 s21370) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s21280  :: " string "


\<comment> \<open>\<open>val _s2115_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2115  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s2115 s21160 = (
   (let s21170 = s21160 in
   if ((string_startswith s21170 (''c.addiw''))) then  
  (case  ((string_drop s21170 ((string_length (''c.addiw''))))) of
        s21180 =>
  (case  ((spc_matches_prefix0 s21180)) of
        Some ((_, s21190)) =>
  (case  ((string_drop s21180 s21190)) of
        s21200 =>
  (case  ((reg_name_matches_prefix s21200 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s21210)) =>
  (case  ((string_drop s21200 s21210)) of
        s21220 =>
  (case  ((sep_matches_prefix s21220)) of
        Some ((_, s21230)) =>
  (case  ((string_drop s21220 s21230)) of
        s21240 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s21240 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s21250)) =>
  (let p00 = (string_drop s21240 s21250) in
  if (((p00 = ('''')))) then Some (rsd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s21160  :: " string "


\<comment> \<open>\<open>val _s2107_ : string -> maybe (mword ty11)\<close>\<close>

definition s2107  :: " string \<Rightarrow>((11)Word.word)option "  where 
     " s2107 s21080 = (
   (let s21090 = s21080 in
   if ((string_startswith s21090 (''c.jal''))) then  
  (case  ((string_drop s21090 ((string_length (''c.jal''))))) of
        s21100 =>
  (case  ((spc_matches_prefix0 s21100)) of
        Some ((_, s21110)) =>
  (case  ((string_drop s21100 s21110)) of
        s21120 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s21120 :: (( 12 Word.word * ii)) option)) of
        Some ((v__814, s21130)) =>
  if (((((subrange_vec_dec v__814 (( 0 :: int):: ii) (( 0 :: int):: ii) :: 1 Word.word))
          = (vec_of_bits [B0] :: 1 Word.word)))) then
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__814
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__814
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (let p00 = (string_drop s21120 s21130) in
    if (((p00 = ('''')))) then Some imm else None))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s21080  :: " string "


\<comment> \<open>\<open>val _s2095_ : string -> maybe ((mword ty5 * mword ty6))\<close>\<close>

definition s2095  :: " string \<Rightarrow>((5)Word.word*(6)Word.word)option "  where 
     " s2095 s20960 = (
   (let s20970 = s20960 in
   if ((string_startswith s20970 (''c.addi''))) then  
  (case  ((string_drop s20970 ((string_length (''c.addi''))))) of
        s20980 =>
  (case  ((spc_matches_prefix0 s20980)) of
        Some ((_, s20990)) =>
  (case  ((string_drop s20980 s20990)) of
        s21000 =>
  (case  ((reg_name_matches_prefix s21000 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s21010)) =>
  (case  ((string_drop s21000 s21010)) of
        s21020 =>
  (case  ((sep_matches_prefix s21020)) of
        Some ((_, s21030)) =>
  (case  ((string_drop s21020 s21030)) of
        s21040 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s21040 :: (( 6 Word.word * ii)) option)) of
        Some ((nzi, s21050)) =>
  (let p00 = (string_drop s21040 s21050) in
  if (((p00 = ('''')))) then Some (rsd, nzi) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s20960  :: " string "


\<comment> \<open>\<open>val _s2079_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s2079  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option "  where 
     " s2079 s20800 = (
   (let s20810 = s20800 in
   if ((string_startswith s20810 (''c.sd''))) then  
  (case  ((string_drop s20810 ((string_length (''c.sd''))))) of
        s20820 =>
  (case  ((spc_matches_prefix0 s20820)) of
        Some ((_, s20830)) =>
  (case  ((string_drop s20820 s20830)) of
        s20840 =>
  (case  ((creg_name_matches_prefix s20840 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s20850)) =>
  (case  ((string_drop s20840 s20850)) of
        s20860 =>
  (case  ((sep_matches_prefix s20860)) of
        Some ((_, s20870)) =>
  (case  ((string_drop s20860 s20870)) of
        s20880 =>
  (case  ((creg_name_matches_prefix s20880 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s20890)) =>
  (case  ((string_drop s20880 s20890)) of
        s20900 =>
  (case  ((sep_matches_prefix s20900)) of
        Some ((_, s20910)) =>
  (case  ((string_drop s20900 s20910)) of
        s20920 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s20920 :: (( 8 Word.word * ii)) option)) of
        Some ((v__816, s20930)) =>
  if (((((subrange_vec_dec v__816 (( 2 :: int):: ii) (( 0 :: int):: ii) :: 3 Word.word))
          = (vec_of_bits [B0,B0,B0] :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__816 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__816 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s20920 s20930) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s20800  :: " string "


\<comment> \<open>\<open>val _s2063_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s2063  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option "  where 
     " s2063 s20640 = (
   (let s20650 = s20640 in
   if ((string_startswith s20650 (''c.sw''))) then  
  (case  ((string_drop s20650 ((string_length (''c.sw''))))) of
        s20660 =>
  (case  ((spc_matches_prefix0 s20660)) of
        Some ((_, s20670)) =>
  (case  ((string_drop s20660 s20670)) of
        s20680 =>
  (case  ((creg_name_matches_prefix s20680 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s20690)) =>
  (case  ((string_drop s20680 s20690)) of
        s20700 =>
  (case  ((sep_matches_prefix s20700)) of
        Some ((_, s20710)) =>
  (case  ((string_drop s20700 s20710)) of
        s20720 =>
  (case  ((creg_name_matches_prefix s20720 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s20730)) =>
  (case  ((string_drop s20720 s20730)) of
        s20740 =>
  (case  ((sep_matches_prefix s20740)) of
        Some ((_, s20750)) =>
  (case  ((string_drop s20740 s20750)) of
        s20760 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s20760 :: (( 7 Word.word * ii)) option)) of
        Some ((v__818, s20770)) =>
  if (((((subrange_vec_dec v__818 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = (vec_of_bits [B0,B0] :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__818 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__818 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s20760 s20770) in
    if (((p00 = ('''')))) then Some (rsc1, rsc2, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s20640  :: " string "


\<comment> \<open>\<open>val _s2047_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s2047  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option "  where 
     " s2047 s20480 = (
   (let s20490 = s20480 in
   if ((string_startswith s20490 (''c.ld''))) then  
  (case  ((string_drop s20490 ((string_length (''c.ld''))))) of
        s20500 =>
  (case  ((spc_matches_prefix0 s20500)) of
        Some ((_, s20510)) =>
  (case  ((string_drop s20500 s20510)) of
        s20520 =>
  (case  ((creg_name_matches_prefix s20520 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s20530)) =>
  (case  ((string_drop s20520 s20530)) of
        s20540 =>
  (case  ((sep_matches_prefix s20540)) of
        Some ((_, s20550)) =>
  (case  ((string_drop s20540 s20550)) of
        s20560 =>
  (case  ((creg_name_matches_prefix s20560 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s20570)) =>
  (case  ((string_drop s20560 s20570)) of
        s20580 =>
  (case  ((sep_matches_prefix s20580)) of
        Some ((_, s20590)) =>
  (case  ((string_drop s20580 s20590)) of
        s20600 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s20600 :: (( 8 Word.word * ii)) option)) of
        Some ((v__820, s20610)) =>
  if (((((subrange_vec_dec v__820 (( 2 :: int):: ii) (( 0 :: int):: ii) :: 3 Word.word))
          = (vec_of_bits [B0,B0,B0] :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__820 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__820 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s20600 s20610) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s20480  :: " string "


\<comment> \<open>\<open>val _s2031_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5))\<close>\<close>

definition s2031  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word)option "  where 
     " s2031 s20320 = (
   (let s20330 = s20320 in
   if ((string_startswith s20330 (''c.lw''))) then  
  (case  ((string_drop s20330 ((string_length (''c.lw''))))) of
        s20340 =>
  (case  ((spc_matches_prefix0 s20340)) of
        Some ((_, s20350)) =>
  (case  ((string_drop s20340 s20350)) of
        s20360 =>
  (case  ((creg_name_matches_prefix s20360 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s20370)) =>
  (case  ((string_drop s20360 s20370)) of
        s20380 =>
  (case  ((sep_matches_prefix s20380)) of
        Some ((_, s20390)) =>
  (case  ((string_drop s20380 s20390)) of
        s20400 =>
  (case  ((creg_name_matches_prefix s20400 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s20410)) =>
  (case  ((string_drop s20400 s20410)) of
        s20420 =>
  (case  ((sep_matches_prefix s20420)) of
        Some ((_, s20430)) =>
  (case  ((string_drop s20420 s20430)) of
        s20440 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s20440 :: (( 7 Word.word * ii)) option)) of
        Some ((v__822, s20450)) =>
  if (((((subrange_vec_dec v__822 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = (vec_of_bits [B0,B0] :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__822 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__822 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let p00 = (string_drop s20440 s20450) in
    if (((p00 = ('''')))) then Some (rdc, rsc, uimm) else None))) else 
  None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s20320  :: " string "


\<comment> \<open>\<open>val _s2019_ : string -> maybe ((mword ty3 * mword ty8))\<close>\<close>

definition s2019  :: " string \<Rightarrow>((3)Word.word*(8)Word.word)option "  where 
     " s2019 s20200 = (
   (let s20210 = s20200 in
   if ((string_startswith s20210 (''c.addi4spn''))) then  
  (case  ((string_drop s20210 ((string_length (''c.addi4spn''))))) of
        s20220 =>
  (case  ((spc_matches_prefix0 s20220)) of
        Some ((_, s20230)) =>
  (case  ((string_drop s20220 s20230)) of
        s20240 =>
  (case  ((creg_name_matches_prefix s20240 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s20250)) =>
  (case  ((string_drop s20240 s20250)) of
        s20260 =>
  (case  ((sep_matches_prefix s20260)) of
        Some ((_, s20270)) =>
  (case  ((string_drop s20260 s20270)) of
        s20280 =>
  (case  ((hex_bits_10_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s20280 :: (( 10 Word.word * ii)) option)) of
        Some ((v__824, s20290)) =>
  if (((((subrange_vec_dec v__824 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = (vec_of_bits [B0,B0] :: 2 Word.word)))) then
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__824 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__824 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (let p00 = (string_drop s20280 s20290) in
    if (((p00 = ('''')))) then Some (rdc, nzimm) else None))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s20200  :: " string "


\<comment> \<open>\<open>val _s1995_ : string -> maybe ((amoop * word_width * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1995  :: " string \<Rightarrow>(amoop*word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1995 s19970 = (
      (case  ((amo_mnemonic_matches_prefix s19970)) of
        Some ((op1, s19980)) =>
         (let s19990 = (string_drop s19970 s19980) in
         if ((string_startswith s19990 (''.''))) then  
  (case  ((string_drop s19990 ((string_length (''.''))))) of
        s20000 =>
  (case  ((size_mnemonic_matches_prefix s20000)) of
        Some ((width, s20010)) =>
  (case  ((string_drop s20000 s20010)) of
        s20020 =>
  (case  ((maybe_aq_matches_prefix s20020)) of
        Some ((aq, s20030)) =>
  (case  ((string_drop s20020 s20030)) of
        s20040 =>
  (case  ((maybe_rl_matches_prefix s20040)) of
        Some ((rl, s20050)) =>
  (case  ((string_drop s20040 s20050)) of
        s20060 =>
  (case  ((spc_matches_prefix0 s20060)) of
        Some ((_, s20070)) =>
  (case  ((string_drop s20060 s20070)) of
        s20080 =>
  (case  ((reg_name_matches_prefix s20080 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s20090)) =>
  (case  ((string_drop s20080 s20090)) of
        s20100 =>
  (case  ((sep_matches_prefix s20100)) of
        Some ((_, s20110)) =>
  (case  ((string_drop s20100 s20110)) of
        s20120 =>
  (case  ((reg_name_matches_prefix s20120 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s20130)) =>
  (case  ((string_drop s20120 s20130)) of
        s20140 =>
  (case  ((sep_matches_prefix s20140)) of
        Some ((_, s20150)) =>
  (case  ((string_drop s20140 s20150)) of
        s20160 =>
  (case  ((reg_name_matches_prefix s20160 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s20170)) =>
  (let p00 = (string_drop s20160 s20170) in
  if (((p00 = ('''')))) then Some (op1, width, aq, rl, rd, rs1, rs2) else
    None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))" 
  for  s19970  :: " string "


\<comment> \<open>\<open>val _s1973_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1973  :: " string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1973 s19740 = (
   (let s19750 = s19740 in
   if ((string_startswith s19750 (''sc.''))) then  
  (case  ((string_drop s19750 ((string_length (''sc.''))))) of
        s19760 =>
  (case  ((size_mnemonic_matches_prefix s19760)) of
        Some ((size1, s19770)) =>
  (case  ((string_drop s19760 s19770)) of
        s19780 =>
  (case  ((maybe_aq_matches_prefix s19780)) of
        Some ((aq, s19790)) =>
  (case  ((string_drop s19780 s19790)) of
        s19800 =>
  (case  ((maybe_rl_matches_prefix s19800)) of
        Some ((rl, s19810)) =>
  (case  ((string_drop s19800 s19810)) of
        s19820 =>
  (case  ((spc_matches_prefix0 s19820)) of
        Some ((_, s19830)) =>
  (case  ((string_drop s19820 s19830)) of
        s19840 =>
  (case  ((reg_name_matches_prefix s19840 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s19850)) =>
  (case  ((string_drop s19840 s19850)) of
        s19860 =>
  (case  ((sep_matches_prefix s19860)) of
        Some ((_, s19870)) =>
  (case  ((string_drop s19860 s19870)) of
        s19880 =>
  (case  ((reg_name_matches_prefix s19880 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s19890)) =>
  (case  ((string_drop s19880 s19890)) of
        s19900 =>
  (case  ((sep_matches_prefix s19900)) of
        Some ((_, s19910)) =>
  (case  ((string_drop s19900 s19910)) of
        s19920 =>
  (case  ((reg_name_matches_prefix s19920 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s19930)) =>
  (let p00 = (string_drop s19920 s19930) in
  if (((p00 = ('''')))) then Some (size1, aq, rl, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s19740  :: " string "


\<comment> \<open>\<open>val _s1955_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5))\<close>\<close>

definition s1955  :: " string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word)option "  where 
     " s1955 s19560 = (
   (let s19570 = s19560 in
   if ((string_startswith s19570 (''lr.''))) then  
  (case  ((string_drop s19570 ((string_length (''lr.''))))) of
        s19580 =>
  (case  ((size_mnemonic_matches_prefix s19580)) of
        Some ((size1, s19590)) =>
  (case  ((string_drop s19580 s19590)) of
        s19600 =>
  (case  ((maybe_aq_matches_prefix s19600)) of
        Some ((aq, s19610)) =>
  (case  ((string_drop s19600 s19610)) of
        s19620 =>
  (case  ((maybe_rl_matches_prefix s19620)) of
        Some ((rl, s19630)) =>
  (case  ((string_drop s19620 s19630)) of
        s19640 =>
  (case  ((spc_matches_prefix0 s19640)) of
        Some ((_, s19650)) =>
  (case  ((string_drop s19640 s19650)) of
        s19660 =>
  (case  ((reg_name_matches_prefix s19660 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s19670)) =>
  (case  ((string_drop s19660 s19670)) of
        s19680 =>
  (case  ((sep_matches_prefix s19680)) of
        Some ((_, s19690)) =>
  (case  ((string_drop s19680 s19690)) of
        s19700 =>
  (case  ((reg_name_matches_prefix s19700 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s19710)) =>
  (let p00 = (string_drop s19700 s19710) in
  if (((p00 = ('''')))) then Some (size1, aq, rl, rd, rs1) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s19560  :: " string "


\<comment> \<open>\<open>val _s1943_ : string -> maybe ((mword ty5 * mword ty5))\<close>\<close>

definition s1943  :: " string \<Rightarrow>((5)Word.word*(5)Word.word)option "  where 
     " s1943 s19440 = (
   (let s19450 = s19440 in
   if ((string_startswith s19450 (''sfence.vma''))) then  
  (case  ((string_drop s19450 ((string_length (''sfence.vma''))))) of
        s19460 =>
  (case  ((spc_matches_prefix0 s19460)) of
        Some ((_, s19470)) =>
  (case  ((string_drop s19460 s19470)) of
        s19480 =>
  (case  ((reg_name_matches_prefix s19480 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s19490)) =>
  (case  ((string_drop s19480 s19490)) of
        s19500 =>
  (case  ((sep_matches_prefix s19500)) of
        Some ((_, s19510)) =>
  (case  ((string_drop s19500 s19510)) of
        s19520 =>
  (case  ((reg_name_matches_prefix s19520 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s19530)) =>
  (let p00 = (string_drop s19520 s19530) in
  if (((p00 = ('''')))) then Some (rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s19440  :: " string "


\<comment> \<open>\<open>val _s1931_ : string -> maybe ((mword ty4 * mword ty4))\<close>\<close>

definition s1931  :: " string \<Rightarrow>((4)Word.word*(4)Word.word)option "  where 
     " s1931 s19320 = (
   (let s19330 = s19320 in
   if ((string_startswith s19330 (''fence.tso''))) then  
  (case  ((string_drop s19330 ((string_length (''fence.tso''))))) of
        s19340 =>
  (case  ((spc_matches_prefix0 s19340)) of
        Some ((_, s19350)) =>
  (case  ((string_drop s19340 s19350)) of
        s19360 =>
  (case  ((fence_bits_matches_prefix s19360 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s19370)) =>
  (case  ((string_drop s19360 s19370)) of
        s19380 =>
  (case  ((sep_matches_prefix s19380)) of
        Some ((_, s19390)) =>
  (case  ((string_drop s19380 s19390)) of
        s19400 =>
  (case  ((fence_bits_matches_prefix s19400 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s19410)) =>
  (let p00 = (string_drop s19400 s19410) in
  if (((p00 = ('''')))) then Some (pred, succ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s19320  :: " string "


\<comment> \<open>\<open>val _s1919_ : string -> maybe ((mword ty4 * mword ty4))\<close>\<close>

definition s1919  :: " string \<Rightarrow>((4)Word.word*(4)Word.word)option "  where 
     " s1919 s19200 = (
   (let s19210 = s19200 in
   if ((string_startswith s19210 (''fence''))) then  
  (case  ((string_drop s19210 ((string_length (''fence''))))) of
        s19220 =>
  (case  ((spc_matches_prefix0 s19220)) of
        Some ((_, s19230)) =>
  (case  ((string_drop s19220 s19230)) of
        s19240 =>
  (case  ((fence_bits_matches_prefix s19240 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s19250)) =>
  (case  ((string_drop s19240 s19250)) of
        s19260 =>
  (case  ((sep_matches_prefix s19260)) of
        Some ((_, s19270)) =>
  (case  ((string_drop s19260 s19270)) of
        s19280 =>
  (case  ((fence_bits_matches_prefix s19280 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s19290)) =>
  (let p00 = (string_drop s19280 s19290) in
  if (((p00 = ('''')))) then Some (pred, succ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s19200  :: " string "


\<comment> \<open>\<open>val _s1902_ : string -> maybe ((sopw * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1902  :: " string \<Rightarrow>(sopw*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1902 s19040 = (
      (case  ((shiftiwop_mnemonic_matches_prefix s19040)) of
        Some ((op1, s19050)) => 
  (case  ((string_drop s19040 s19050)) of
        s19060 =>
  (case  ((spc_matches_prefix0 s19060)) of
        Some ((_, s19070)) =>
  (case  ((string_drop s19060 s19070)) of
        s19080 =>
  (case  ((reg_name_matches_prefix s19080 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s19090)) =>
  (case  ((string_drop s19080 s19090)) of
        s19100 =>
  (case  ((sep_matches_prefix s19100)) of
        Some ((_, s19110)) =>
  (case  ((string_drop s19100 s19110)) of
        s19120 =>
  (case  ((reg_name_matches_prefix s19120 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s19130)) =>
  (case  ((string_drop s19120 s19130)) of
        s19140 =>
  (case  ((sep_matches_prefix s19140)) of
        Some ((_, s19150)) =>
  (case  ((string_drop s19140 s19150)) of
        s19160 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s19160 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s19170)) =>
  (let p00 = (string_drop s19160 s19170) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s19040  :: " string "


\<comment> \<open>\<open>val _s1885_ : string -> maybe ((ropw * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1885  :: " string \<Rightarrow>(ropw*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1885 s18870 = (
      (case  ((rtypew_mnemonic_matches_prefix s18870)) of
        Some ((op1, s18880)) => 
  (case  ((string_drop s18870 s18880)) of
        s18890 =>
  (case  ((spc_matches_prefix0 s18890)) of
        Some ((_, s18900)) =>
  (case  ((string_drop s18890 s18900)) of
        s18910 =>
  (case  ((reg_name_matches_prefix s18910 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s18920)) =>
  (case  ((string_drop s18910 s18920)) of
        s18930 =>
  (case  ((sep_matches_prefix s18930)) of
        Some ((_, s18940)) =>
  (case  ((string_drop s18930 s18940)) of
        s18950 =>
  (case  ((reg_name_matches_prefix s18950 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s18960)) =>
  (case  ((string_drop s18950 s18960)) of
        s18970 =>
  (case  ((sep_matches_prefix s18970)) of
        Some ((_, s18980)) =>
  (case  ((string_drop s18970 s18980)) of
        s18990 =>
  (case  ((reg_name_matches_prefix s18990 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s19000)) =>
  (let p00 = (string_drop s18990 s19000) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s18870  :: " string "


\<comment> \<open>\<open>val _s1868_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1868  :: " string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1868 s18700 = (
      (case  ((shiftw_mnemonic_matches_prefix s18700)) of
        Some ((op1, s18710)) => 
  (case  ((string_drop s18700 s18710)) of
        s18720 =>
  (case  ((spc_matches_prefix0 s18720)) of
        Some ((_, s18730)) =>
  (case  ((string_drop s18720 s18730)) of
        s18740 =>
  (case  ((reg_name_matches_prefix s18740 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s18750)) =>
  (case  ((string_drop s18740 s18750)) of
        s18760 =>
  (case  ((sep_matches_prefix s18760)) of
        Some ((_, s18770)) =>
  (case  ((string_drop s18760 s18770)) of
        s18780 =>
  (case  ((reg_name_matches_prefix s18780 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s18790)) =>
  (case  ((string_drop s18780 s18790)) of
        s18800 =>
  (case  ((sep_matches_prefix s18800)) of
        Some ((_, s18810)) =>
  (case  ((string_drop s18800 s18810)) of
        s18820 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s18820 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s18830)) =>
  (let p00 = (string_drop s18820 s18830) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s18700  :: " string "


\<comment> \<open>\<open>val _s1852_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s1852  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word)option "  where 
     " s1852 s18530 = (
   (let s18540 = s18530 in
   if ((string_startswith s18540 (''addiw''))) then  
  (case  ((string_drop s18540 ((string_length (''addiw''))))) of
        s18550 =>
  (case  ((spc_matches_prefix0 s18550)) of
        Some ((_, s18560)) =>
  (case  ((string_drop s18550 s18560)) of
        s18570 =>
  (case  ((reg_name_matches_prefix s18570 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s18580)) =>
  (case  ((string_drop s18570 s18580)) of
        s18590 =>
  (case  ((sep_matches_prefix s18590)) of
        Some ((_, s18600)) =>
  (case  ((string_drop s18590 s18600)) of
        s18610 =>
  (case  ((reg_name_matches_prefix s18610 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s18620)) =>
  (case  ((string_drop s18610 s18620)) of
        s18630 =>
  (case  ((sep_matches_prefix s18630)) of
        Some ((_, s18640)) =>
  (case  ((string_drop s18630 s18640)) of
        s18650 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s18650 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s18660)) =>
  (let p00 = (string_drop s18650 s18660) in
  if (((p00 = ('''')))) then Some (rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s18530  :: " string "


\<comment> \<open>\<open>val _s1824_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s1824  :: " string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word)option "  where 
     " s1824 s18250 = (
   (let s18260 = s18250 in
   if ((string_startswith s18260 (''s''))) then  
  (case  ((string_drop s18260 ((string_length (''s''))))) of
        s18270 =>
  (case  ((size_mnemonic_matches_prefix s18270)) of
        Some ((size1, s18280)) =>
  (case  ((string_drop s18270 s18280)) of
        s18290 =>
  (case  ((maybe_aq_matches_prefix s18290)) of
        Some ((aq, s18300)) =>
  (case  ((string_drop s18290 s18300)) of
        s18310 =>
  (case  ((maybe_rl_matches_prefix s18310)) of
        Some ((rl, s18320)) =>
  (case  ((string_drop s18310 s18320)) of
        s18330 =>
  (case  ((spc_matches_prefix0 s18330)) of
        Some ((_, s18340)) =>
  (case  ((string_drop s18330 s18340)) of
        s18350 =>
  (case  ((reg_name_matches_prefix s18350 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s18360)) =>
  (case  ((string_drop s18350 s18360)) of
        s18370 =>
  (case  ((sep_matches_prefix s18370)) of
        Some ((_, s18380)) =>
  (case  ((string_drop s18370 s18380)) of
        s18390 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s18390 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s18400)) =>
  (case  ((string_drop s18390 s18400)) of
        s18410 =>
  (case  ((opt_spc_matches_prefix0 s18410)) of
        Some ((_, s18420)) =>
  (let s18430 = (string_drop s18410 s18420) in
  if ((string_startswith s18430 (''(''))) then
    (case  ((string_drop s18430 ((string_length (''(''))))) of
          s18440 =>
    (case  ((opt_spc_matches_prefix0 s18440)) of
          Some ((_, s18450)) =>
    (case  ((string_drop s18440 s18450)) of
          s18460 =>
    (case  ((reg_name_matches_prefix s18460 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s18470)) =>
    (case  ((string_drop s18460 s18470)) of
          s18480 =>
    (case  ((opt_spc_matches_prefix0 s18480)) of
          Some ((_, s18490)) =>
    (let s18500 = (string_drop s18480 s18490) in
    if ((string_startswith s18500 ('')''))) then
      (let p00 = (string_drop s18500 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then Some (size1, aq, rl, rs2, imm, rs1) else
        None) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s18250  :: " string "


\<comment> \<open>\<open>val _s1794_ : string -> maybe ((word_width * bool * bool * bool * mword ty5 * mword ty12 * mword ty5))\<close>\<close>

definition s1794  :: " string \<Rightarrow>(word_width*bool*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word)option "  where 
     " s1794 s17950 = (
   (let s17960 = s17950 in
   if ((string_startswith s17960 (''l''))) then  
  (case  ((string_drop s17960 ((string_length (''l''))))) of
        s17970 =>
  (case  ((size_mnemonic_matches_prefix s17970)) of
        Some ((size1, s17980)) =>
  (case  ((string_drop s17970 s17980)) of
        s17990 =>
  (case  ((maybe_u_matches_prefix s17990)) of
        Some ((is_unsigned, s18000)) =>
  (case  ((string_drop s17990 s18000)) of
        s18010 =>
  (case  ((maybe_aq_matches_prefix s18010)) of
        Some ((aq, s18020)) =>
  (case  ((string_drop s18010 s18020)) of
        s18030 =>
  (case  ((maybe_rl_matches_prefix s18030)) of
        Some ((rl, s18040)) =>
  (case  ((string_drop s18030 s18040)) of
        s18050 =>
  (case  ((spc_matches_prefix0 s18050)) of
        Some ((_, s18060)) =>
  (case  ((string_drop s18050 s18060)) of
        s18070 =>
  (case  ((reg_name_matches_prefix s18070 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s18080)) =>
  (case  ((string_drop s18070 s18080)) of
        s18090 =>
  (case  ((sep_matches_prefix s18090)) of
        Some ((_, s18100)) =>
  (case  ((string_drop s18090 s18100)) of
        s18110 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s18110 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s18120)) =>
  (case  ((string_drop s18110 s18120)) of
        s18130 =>
  (case  ((opt_spc_matches_prefix0 s18130)) of
        Some ((_, s18140)) =>
  (let s18150 = (string_drop s18130 s18140) in
  if ((string_startswith s18150 (''(''))) then
    (case  ((string_drop s18150 ((string_length (''(''))))) of
          s18160 =>
    (case  ((opt_spc_matches_prefix0 s18160)) of
          Some ((_, s18170)) =>
    (case  ((string_drop s18160 s18170)) of
          s18180 =>
    (case  ((reg_name_matches_prefix s18180 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s18190)) =>
    (case  ((string_drop s18180 s18190)) of
          s18200 =>
    (case  ((opt_spc_matches_prefix0 s18200)) of
          Some ((_, s18210)) =>
    (let s18220 = (string_drop s18200 s18210) in
    if ((string_startswith s18220 ('')''))) then
      (let p00 = (string_drop s18220 ((string_length ('')'')))) in
      if (((p00 = ('''')))) then
        Some (size1, is_unsigned, aq, rl, rd, imm, rs1) else None) else 
    None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s17950  :: " string "


\<comment> \<open>\<open>val _s1777_ : string -> maybe ((rop * mword ty5 * mword ty5 * mword ty5))\<close>\<close>

definition s1777  :: " string \<Rightarrow>(rop*(5)Word.word*(5)Word.word*(5)Word.word)option "  where 
     " s1777 s17790 = (
      (case  ((rtype_mnemonic_matches_prefix s17790)) of
        Some ((op1, s17800)) => 
  (case  ((string_drop s17790 s17800)) of
        s17810 =>
  (case  ((spc_matches_prefix0 s17810)) of
        Some ((_, s17820)) =>
  (case  ((string_drop s17810 s17820)) of
        s17830 =>
  (case  ((reg_name_matches_prefix s17830 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s17840)) =>
  (case  ((string_drop s17830 s17840)) of
        s17850 =>
  (case  ((sep_matches_prefix s17850)) of
        Some ((_, s17860)) =>
  (case  ((string_drop s17850 s17860)) of
        s17870 =>
  (case  ((reg_name_matches_prefix s17870 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s17880)) =>
  (case  ((string_drop s17870 s17880)) of
        s17890 =>
  (case  ((sep_matches_prefix s17890)) of
        Some ((_, s17900)) =>
  (case  ((string_drop s17890 s17900)) of
        s17910 =>
  (case  ((reg_name_matches_prefix s17910 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s17920)) =>
  (let p00 = (string_drop s17910 s17920) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, rs2) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s17790  :: " string "


\<comment> \<open>\<open>val _s1760_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty6))\<close>\<close>

definition s1760  :: " string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(6)Word.word)option "  where 
     " s1760 s17620 = (
      (case  ((shiftiop_mnemonic_matches_prefix s17620)) of
        Some ((op1, s17630)) => 
  (case  ((string_drop s17620 s17630)) of
        s17640 =>
  (case  ((spc_matches_prefix0 s17640)) of
        Some ((_, s17650)) =>
  (case  ((string_drop s17640 s17650)) of
        s17660 =>
  (case  ((reg_name_matches_prefix s17660 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s17670)) =>
  (case  ((string_drop s17660 s17670)) of
        s17680 =>
  (case  ((sep_matches_prefix s17680)) of
        Some ((_, s17690)) =>
  (case  ((string_drop s17680 s17690)) of
        s17700 =>
  (case  ((reg_name_matches_prefix s17700 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s17710)) =>
  (case  ((string_drop s17700 s17710)) of
        s17720 =>
  (case  ((sep_matches_prefix s17720)) of
        Some ((_, s17730)) =>
  (case  ((string_drop s17720 s17730)) of
        s17740 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17740 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s17750)) =>
  (let p00 = (string_drop s17740 s17750) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, shamt) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s17620  :: " string "


\<comment> \<open>\<open>val _s1743_ : string -> maybe ((iop * mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s1743  :: " string \<Rightarrow>(iop*(5)Word.word*(5)Word.word*(12)Word.word)option "  where 
     " s1743 s17450 = (
      (case  ((itype_mnemonic_matches_prefix s17450)) of
        Some ((op1, s17460)) => 
  (case  ((string_drop s17450 s17460)) of
        s17470 =>
  (case  ((spc_matches_prefix0 s17470)) of
        Some ((_, s17480)) =>
  (case  ((string_drop s17470 s17480)) of
        s17490 =>
  (case  ((reg_name_matches_prefix s17490 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s17500)) =>
  (case  ((string_drop s17490 s17500)) of
        s17510 =>
  (case  ((sep_matches_prefix s17510)) of
        Some ((_, s17520)) =>
  (case  ((string_drop s17510 s17520)) of
        s17530 =>
  (case  ((reg_name_matches_prefix s17530 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s17540)) =>
  (case  ((string_drop s17530 s17540)) of
        s17550 =>
  (case  ((sep_matches_prefix s17550)) of
        Some ((_, s17560)) =>
  (case  ((string_drop s17550 s17560)) of
        s17570 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17570 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s17580)) =>
  (let p00 = (string_drop s17570 s17580) in
  if (((p00 = ('''')))) then Some (op1, rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s17450  :: " string "


\<comment> \<open>\<open>val _s1726_ : string -> maybe ((bop * mword ty5 * mword ty5 * mword ty13))\<close>\<close>

definition s1726  :: " string \<Rightarrow>(bop*(5)Word.word*(5)Word.word*(13)Word.word)option "  where 
     " s1726 s17280 = (
      (case  ((btype_mnemonic_matches_prefix s17280)) of
        Some ((op1, s17290)) => 
  (case  ((string_drop s17280 s17290)) of
        s17300 =>
  (case  ((spc_matches_prefix0 s17300)) of
        Some ((_, s17310)) =>
  (case  ((string_drop s17300 s17310)) of
        s17320 =>
  (case  ((reg_name_matches_prefix s17320 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s17330)) =>
  (case  ((string_drop s17320 s17330)) of
        s17340 =>
  (case  ((sep_matches_prefix s17340)) of
        Some ((_, s17350)) =>
  (case  ((string_drop s17340 s17350)) of
        s17360 =>
  (case  ((reg_name_matches_prefix s17360 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s17370)) =>
  (case  ((string_drop s17360 s17370)) of
        s17380 =>
  (case  ((sep_matches_prefix s17380)) of
        Some ((_, s17390)) =>
  (case  ((string_drop s17380 s17390)) of
        s17400 =>
  (case  ((hex_bits_13_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17400 :: (( 13 Word.word * ii)) option)) of
        Some ((imm, s17410)) =>
  (let p00 = (string_drop s17400 s17410) in
  if (((p00 = ('''')))) then Some (op1, rs1, rs2, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s17280  :: " string "


\<comment> \<open>\<open>val _s1710_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12))\<close>\<close>

definition s1710  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word)option "  where 
     " s1710 s17110 = (
   (let s17120 = s17110 in
   if ((string_startswith s17120 (''jalr''))) then  
  (case  ((string_drop s17120 ((string_length (''jalr''))))) of
        s17130 =>
  (case  ((spc_matches_prefix0 s17130)) of
        Some ((_, s17140)) =>
  (case  ((string_drop s17130 s17140)) of
        s17150 =>
  (case  ((reg_name_matches_prefix s17150 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s17160)) =>
  (case  ((string_drop s17150 s17160)) of
        s17170 =>
  (case  ((sep_matches_prefix s17170)) of
        Some ((_, s17180)) =>
  (case  ((string_drop s17170 s17180)) of
        s17190 =>
  (case  ((reg_name_matches_prefix s17190 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s17200)) =>
  (case  ((string_drop s17190 s17200)) of
        s17210 =>
  (case  ((sep_matches_prefix s17210)) of
        Some ((_, s17220)) =>
  (case  ((string_drop s17210 s17220)) of
        s17230 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17230 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s17240)) =>
  (let p00 = (string_drop s17230 s17240) in
  if (((p00 = ('''')))) then Some (rd, rs1, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s17110  :: " string "


\<comment> \<open>\<open>val _s1698_ : string -> maybe ((mword ty5 * mword ty21))\<close>\<close>

definition s1698  :: " string \<Rightarrow>((5)Word.word*(21)Word.word)option "  where 
     " s1698 s16990 = (
   (let s17000 = s16990 in
   if ((string_startswith s17000 (''jal''))) then  
  (case  ((string_drop s17000 ((string_length (''jal''))))) of
        s17010 =>
  (case  ((spc_matches_prefix0 s17010)) of
        Some ((_, s17020)) =>
  (case  ((string_drop s17010 s17020)) of
        s17030 =>
  (case  ((reg_name_matches_prefix s17030 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s17040)) =>
  (case  ((string_drop s17030 s17040)) of
        s17050 =>
  (case  ((sep_matches_prefix s17050)) of
        Some ((_, s17060)) =>
  (case  ((string_drop s17050 s17060)) of
        s17070 =>
  (case  ((hex_bits_21_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s17070 :: (( 21 Word.word * ii)) option)) of
        Some ((imm, s17080)) =>
  (let p00 = (string_drop s17070 s17080) in
  if (((p00 = ('''')))) then Some (rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s16990  :: " string "


\<comment> \<open>\<open>val _s1685_ : string -> maybe ((uop * mword ty5 * mword ty20))\<close>\<close>

definition s1685  :: " string \<Rightarrow>(uop*(5)Word.word*(20)Word.word)option "  where 
     " s1685 s16870 = (
      (case  ((utype_mnemonic_matches_prefix s16870)) of
        Some ((op1, s16880)) => 
  (case  ((string_drop s16870 s16880)) of
        s16890 =>
  (case  ((spc_matches_prefix0 s16890)) of
        Some ((_, s16900)) =>
  (case  ((string_drop s16890 s16900)) of
        s16910 =>
  (case  ((reg_name_matches_prefix s16910 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s16920)) =>
  (case  ((string_drop s16910 s16920)) of
        s16930 =>
  (case  ((sep_matches_prefix s16930)) of
        Some ((_, s16940)) =>
  (case  ((string_drop s16930 s16940)) of
        s16950 =>
  (case  ((hex_bits_20_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s16950 :: (( 20 Word.word * ii)) option)) of
        Some ((imm, s16960)) =>
  (let p00 = (string_drop s16950 s16960) in
  if (((p00 = ('''')))) then Some (op1, rd, imm) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s16870  :: " string "


definition assembly_backwards_matches  :: " string \<Rightarrow> bool "  where 
     " assembly_backwards_matches arg1 = (
   (let s16970 = arg1 in
   if ((case  ((s1685 s16970  ::  ((uop *  5 Word.word *  20 Word.word))option)) of
       Some ((op1, rd, imm)) => True
     | _ => False
     )) then  (case  (s1685 s16970 :: (( uop * 5 Word.word * 20 Word.word)) option) of
     (Some ((op1, rd, imm))) =>
 True
 )
   else if ((case  ((s1698 s16970  ::  (( 5 Word.word *  21 Word.word))option)) of
       Some ((rd, imm)) => True
     | _ => False
     )) then  (case  (s1698 s16970 :: (( 5 Word.word * 21 Word.word)) option) of
     (Some ((rd, imm))) =>
 True
 )
   else if ((case  ((s1710 s16970  ::  (( 5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((rd, rs1, imm)) => True
     | _ => False
     )) then  (case  (s1710 s16970 :: (( 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((rd, rs1, imm))) =>
 True
 )
   else if ((case  ((s1726 s16970  ::  ((bop *  5 Word.word *  5 Word.word *  13 Word.word))option)) of
       Some ((op1, rs1, rs2, imm)) => True
     | _ => False
     )) then  (case 
 (s1726 s16970 :: (( bop * 5 Word.word * 5 Word.word * 13 Word.word)) option) of
     (Some ((op1, rs1, rs2, imm))) =>
 True
 )
   else if ((case  ((s1743 s16970  ::  ((iop *  5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((op1, rd, rs1, imm)) => True
     | _ => False
     )) then  (case 
 (s1743 s16970 :: (( iop * 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((op1, rd, rs1, imm))) =>
 True
 )
   else if ((case  ((s1760 s16970  ::  ((sop *  5 Word.word *  5 Word.word *  6 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => True
     | _ => False
     )) then  (case 
 (s1760 s16970 :: (( sop * 5 Word.word * 5 Word.word * 6 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 True
 )
   else if ((case  ((s1777 s16970  ::  ((rop *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s1777 s16970 :: (( rop * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s1794 s16970
                     ::  ((word_width * bool * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((size1, is_unsigned, aq, rl, rd, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s1794 s16970
 :: (( word_width * bool * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((size1, is_unsigned, aq, rl, rd, imm, rs1))) =>
 True
 )
   else if ((case  ((s1824 s16970
                     ::  ((word_width * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rs2, imm, rs1)) => True
     | _ => False
     )) then  (case 
 (s1824 s16970 :: (( word_width * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rs2, imm, rs1))) =>
 True
 )
   else if ((case  ((s1852 s16970  ::  (( 5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((rd, rs1, imm)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s1852 s16970 :: (( 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((rd, rs1, imm))) =>
 True
 )
   else if ((case  ((s1868 s16970  ::  ((sop *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1868 s16970 :: (( sop * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 True
 )
   else if ((case  ((s1885 s16970  ::  ((ropw *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1885 s16970 :: (( ropw * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s1902 s16970  ::  ((sopw *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, rd, rs1, shamt)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s1902 s16970 :: (( sopw * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, rd, rs1, shamt))) =>
 True
 )
   else if ((case  ((s1919 s16970  ::  (( 4 Word.word *  4 Word.word))option)) of
       Some ((pred, succ)) => True
     | _ => False
     )) then  (case  (s1919 s16970 :: (( 4 Word.word * 4 Word.word)) option) of
     (Some ((pred, succ))) =>
 True
 )
   else if ((case  ((s1931 s16970  ::  (( 4 Word.word *  4 Word.word))option)) of
       Some ((pred, succ)) => True
     | _ => False
     )) then  (case  (s1931 s16970 :: (( 4 Word.word * 4 Word.word)) option) of
     (Some ((pred, succ))) =>
 True
 )
   else if (((s16970 = (''fence.i'')))) then True
   else if (((s16970 = (''ecall'')))) then True
   else if (((s16970 = (''mret'')))) then True
   else if (((s16970 = (''sret'')))) then True
   else if (((s16970 = (''ebreak'')))) then True
   else if (((s16970 = (''wfi'')))) then True
   else if ((case  ((s1943 s16970  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rs1, rs2)) => True
     | _ => False
     )) then  (case  (s1943 s16970 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rs1, rs2))) =>
 True
 )
   else if ((case  ((s1955 s16970  ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rd, rs1)) => True
     | _ => False
     )) then  (case 
 (s1955 s16970 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rd, rs1))) =>
 True
 )
   else if ((case  ((s1973 s16970
                     ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((size1, aq, rl, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s1973 s16970 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((size1, aq, rl, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s1995 s16970
                     ::  ((amoop * word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((op1, width, aq, rl, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s1995 s16970
 :: (( amoop * word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((op1, width, aq, rl, rd, rs1, rs2))) =>
 True
 )
   else if (((s16970 = (''c.nop'')))) then True
   else if ((case  ((s2019 s16970  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rdc, nzimm)) => (nzimm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))
     | _ => False
     )) then  (case  (s2019 s16970 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rdc, nzimm))) =>
 True
 )
   else if ((case  ((s2031 s16970  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => True
     | _ => False
     )) then  (case 
 (s2031 s16970 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 True
 )
   else if ((case  ((s2047 s16970  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rdc, rsc, uimm)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2047 s16970 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rdc, rsc, uimm))) =>
 True
 )
   else if ((case  ((s2063 s16970  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => True
     | _ => False
     )) then  (case 
 (s2063 s16970 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 True
 )
   else if ((case  ((s2079 s16970  ::  (( 3 Word.word *  3 Word.word *  5 Word.word))option)) of
       Some ((rsc1, rsc2, uimm)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2079 s16970 :: (( 3 Word.word * 3 Word.word * 5 Word.word)) option) of
     (Some ((rsc1, rsc2, uimm))) =>
 True
 )
   else if ((case  ((s2095 s16970  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, nzi)) =>
        ((((nzi \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s2095 s16970 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, nzi))) =>
 True
 )
   else if ((case  ((s2107 s16970  ::  ( 11 Word.word)option)) of
       Some (imm) => ((( 32 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s2107 s16970 :: ( 11 Word.word) option) of (Some (imm)) => True )
   else if ((case  ((s2115 s16970  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, imm)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s2115 s16970 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, imm))) =>
 True
 )
   else if ((case  ((s2127 s16970  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, imm)) => (((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s2127 s16970 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, imm))) =>
 True
 )
   else if ((case  ((s2139 s16970  ::  ( 6 Word.word)option)) of
       Some (imm) => (imm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))
     | _ => False
     )) then  (case  (s2139 s16970 :: ( 6 Word.word) option) of (Some (imm)) => True )
   else if ((case  ((s2147 s16970  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, imm)) =>
        ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno sp))))) \<and> (((imm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))))
     | _ => False
     )) then  (case  (s2147 s16970 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, imm))) =>
 True
 )
   else if ((case  ((s2159 s16970  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => (shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))
     | _ => False
     )) then  (case  (s2159 s16970 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 True
 )
   else if ((case  ((s2171 s16970  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) => (shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))
     | _ => False
     )) then  (case  (s2171 s16970 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 True
 )
   else if ((case  ((s2183 s16970  ::  (( 3 Word.word *  6 Word.word))option)) of
       Some ((rsd, imm)) => True
     | _ => False
     )) then  (case  (s2183 s16970 :: (( 3 Word.word * 6 Word.word)) option) of
     (Some ((rsd, imm))) =>
 True
 )
   else if ((case  ((s2195 s16970  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s2195 s16970 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s2207 s16970  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s2207 s16970 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s2219 s16970  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s2219 s16970 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s2231 s16970  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => True
     | _ => False
     )) then  (case  (s2231 s16970 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s2243 s16970  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s2243 s16970 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s2255 s16970  ::  (( 3 Word.word *  3 Word.word))option)) of
       Some ((rsd, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s2255 s16970 :: (( 3 Word.word * 3 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s2267 s16970  ::  ( 11 Word.word)option)) of
       Some (imm) => True
     | _ => False
     )) then  (case  (s2267 s16970 :: ( 11 Word.word) option) of (Some (imm)) => True )
   else if ((case  ((s2275 s16970  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rs, imm)) => True
     | _ => False
     )) then  (case  (s2275 s16970 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rs, imm))) =>
 True
 )
   else if ((case  ((s2287 s16970  ::  (( 3 Word.word *  8 Word.word))option)) of
       Some ((rs, imm)) => True
     | _ => False
     )) then  (case  (s2287 s16970 :: (( 3 Word.word * 8 Word.word)) option) of
     (Some ((rs, imm))) =>
 True
 )
   else if ((case  ((s2299 s16970  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rsd, shamt)) =>
        ((((shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s2299 s16970 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rsd, shamt))) =>
 True
 )
   else if ((case  ((s2311 s16970  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => (((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s2311 s16970 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 True
 )
   else if ((case  ((s2323 s16970  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) =>
        ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s2323 s16970 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 True
 )
   else if ((case  ((s2335 s16970  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rd, uimm)) => True
     | _ => False
     )) then  (case  (s2335 s16970 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rd, uimm))) =>
 True
 )
   else if ((case  ((s2347 s16970  ::  (( 5 Word.word *  6 Word.word))option)) of
       Some ((rs2, uimm)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s2347 s16970 :: (( 5 Word.word * 6 Word.word)) option) of
     (Some ((rs2, uimm))) =>
 True
 )
   else if ((case  ((s2359 s16970  ::  ( 5 Word.word)option)) of
       Some (rs1) => (((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s2359 s16970 :: ( 5 Word.word) option) of (Some (rs1)) => True )
   else if ((case  ((s2367 s16970  ::  ( 5 Word.word)option)) of
       Some (rs1) => (((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s2367 s16970 :: ( 5 Word.word) option) of (Some (rs1)) => True )
   else if ((case  ((s2375 s16970  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rd, rs2)) =>
        ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s2375 s16970 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rd, rs2))) =>
 True
 )
   else if (((s16970 = (''c.ebreak'')))) then True
   else if ((case  ((s2387 s16970  ::  (( 5 Word.word *  5 Word.word))option)) of
       Some ((rsd, rs2)) =>
        ((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s2387 s16970 :: (( 5 Word.word * 5 Word.word)) option) of
     (Some ((rsd, rs2))) =>
 True
 )
   else if ((case  ((s2399 s16970
                     ::  ((bool * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((high, signed1, signed2, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2399 s16970 :: (( bool * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((high, signed1, signed2, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s2416 s16970  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2416 s16970 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s2434 s16970  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => True
     | _ => False
     )) then  (case 
 (s2434 s16970 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s2452 s16970  ::  (( 5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((rd, rs1, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s2452 s16970 :: (( 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s2468 s16970  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2468 s16970 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s2487 s16970  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word))option)) of
       Some ((s, rd, rs1, rs2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2487 s16970 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word)) option) of
     (Some ((s, rd, rs1, rs2))) =>
 True
 )
   else if ((case  ((s2506 s16970  ::  ((csrop *  5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((op1, rd, rs1, csr)) => True
     | _ => False
     )) then  (case 
 (s2506 s16970 :: (( csrop * 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((op1, rd, rs1, csr))) =>
 True
 )
   else if ((case  ((s2524 s16970  ::  ((csrop *  5 Word.word *  5 Word.word *  12 Word.word))option)) of
       Some ((op1, rd, rs1, csr)) => True
     | _ => False
     )) then  (case 
 (s2524 s16970 :: (( csrop * 5 Word.word * 5 Word.word * 12 Word.word)) option) of
     (Some ((op1, rd, rs1, csr))) =>
 True
 )
   else if (((s16970 = (''uret'')))) then True
   else if ((case  ((s2541 s16970  ::  ( 32 Word.word)option)) of   Some (s) => True | _ => False ))
   then  (case  (s2541 s16970 :: ( 32 Word.word) option) of (Some (s)) => True )
   else if ((case  ((s2549 s16970  ::  ( 16 Word.word)option)) of   Some (s) => True | _ => False ))
   then  (case  (s2549 s16970 :: ( 16 Word.word) option) of (Some (s)) => True )
   else False))" 
  for  arg1  :: " string "


\<comment> \<open>\<open>val assembly_matches_prefix : string -> maybe ((ast * ii))\<close>\<close>

\<comment> \<open>\<open>val _s3457_ : string -> maybe ((mword ty16 * string))\<close>\<close>

definition s3457  :: " string \<Rightarrow>((16)Word.word*string)option "  where 
     " s3457 s34580 = (
   (let s34590 = s34580 in
   if ((string_startswith s34590 (''c.illegal''))) then  
  (case  ((string_drop s34590 ((string_length (''c.illegal''))))) of
        s34600 =>
  (case  ((spc_matches_prefix0 s34600)) of
        Some ((_, s34610)) =>
  (case  ((string_drop s34600 s34610)) of
        s34620 =>
  (case  ((hex_bits_16_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s34620 :: (( 16 Word.word * ii)) option)) of
        Some ((s, s34630)) =>
  (case  ((string_drop s34620 s34630)) of   s2 => Some (s, s2) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s34580  :: " string "


\<comment> \<open>\<open>val _s3449_ : string -> maybe ((mword ty32 * string))\<close>\<close>

definition s3449  :: " string \<Rightarrow>((32)Word.word*string)option "  where 
     " s3449 s34500 = (
   (let s34510 = s34500 in
   if ((string_startswith s34510 (''illegal''))) then  
  (case  ((string_drop s34510 ((string_length (''illegal''))))) of
        s34520 =>
  (case  ((spc_matches_prefix0 s34520)) of
        Some ((_, s34530)) =>
  (case  ((string_drop s34520 s34530)) of
        s34540 =>
  (case  ((hex_bits_32_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s34540 :: (( 32 Word.word * ii)) option)) of
        Some ((s, s34550)) =>
  (case  ((string_drop s34540 s34550)) of   s2 => Some (s, s2) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s34500  :: " string "


\<comment> \<open>\<open>val _s3445_ : string -> maybe string\<close>\<close>

definition s3445  :: " string \<Rightarrow>(string)option "  where 
     " s3445 s34460 = (
   (let s34470 = s34460 in
   if ((string_startswith s34470 (''uret''))) then  
  (case  ((string_drop s34470 ((string_length (''uret''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s34460  :: " string "


\<comment> \<open>\<open>val _s3428_ : string -> maybe ((csrop * mword ty5 * mword ty5 * mword ty12 * string))\<close>\<close>

definition s3428  :: " string \<Rightarrow>(csrop*(5)Word.word*(5)Word.word*(12)Word.word*string)option "  where 
     " s3428 s34300 = (
      (case  ((csr_mnemonic_matches_prefix s34300)) of
        Some ((op1, s34310)) => 
  (case  ((string_drop s34300 s34310)) of
        s34320 =>
  (case  ((spc_matches_prefix0 s34320)) of
        Some ((_, s34330)) =>
  (case  ((string_drop s34320 s34330)) of
        s34340 =>
  (case  ((reg_name_matches_prefix s34340 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s34350)) =>
  (case  ((string_drop s34340 s34350)) of
        s34360 =>
  (case  ((sep_matches_prefix s34360)) of
        Some ((_, s34370)) =>
  (case  ((string_drop s34360 s34370)) of
        s34380 =>
  (case  ((reg_name_matches_prefix s34380 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s34390)) =>
  (case  ((string_drop s34380 s34390)) of
        s34400 =>
  (case  ((sep_matches_prefix s34400)) of
        Some ((_, s34410)) =>
  (case  ((string_drop s34400 s34410)) of
        s34420 =>
  (case  ((csr_name_map_matches_prefix s34420
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s34430)) =>
  (case  ((string_drop s34420 s34430)) of
        s1 => Some (op1, rd, rs1, csr, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s34300  :: " string "


\<comment> \<open>\<open>val _s3410_ : string -> maybe ((csrop * mword ty5 * mword ty5 * mword ty12 * string))\<close>\<close>

definition s3410  :: " string \<Rightarrow>(csrop*(5)Word.word*(5)Word.word*(12)Word.word*string)option "  where 
     " s3410 s34120 = (
      (case  ((csr_mnemonic_matches_prefix s34120)) of
        Some ((op1, s34130)) =>
         (let s34140 = (string_drop s34120 s34130) in
         if ((string_startswith s34140 (''i''))) then  
  (case  ((string_drop s34140 ((string_length (''i''))))) of
        s34150 =>
  (case  ((spc_matches_prefix0 s34150)) of
        Some ((_, s34160)) =>
  (case  ((string_drop s34150 s34160)) of
        s34170 =>
  (case  ((reg_name_matches_prefix s34170 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s34180)) =>
  (case  ((string_drop s34170 s34180)) of
        s34190 =>
  (case  ((sep_matches_prefix s34190)) of
        Some ((_, s34200)) =>
  (case  ((string_drop s34190 s34200)) of
        s34210 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s34210 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s34220)) =>
  (case  ((string_drop s34210 s34220)) of
        s34230 =>
  (case  ((sep_matches_prefix s34230)) of
        Some ((_, s34240)) =>
  (case  ((string_drop s34230 s34240)) of
        s34250 =>
  (case  ((csr_name_map_matches_prefix s34250
          :: (( 12 Word.word * ii)) option)) of
        Some ((csr, s34260)) =>
  (case  ((string_drop s34250 s34260)) of
        s1 => Some (op1, rd, rs1, csr, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))" 
  for  s34120  :: " string "


\<comment> \<open>\<open>val _s3391_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s3391  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s3391 s33920 = (
   (let s33930 = s33920 in
   if ((string_startswith s33930 (''rem''))) then  
  (case  ((string_drop s33930 ((string_length (''rem''))))) of
        s33940 =>
  (case  ((maybe_not_u_matches_prefix s33940)) of
        Some ((s, s33950)) =>
  (let s33960 = (string_drop s33940 s33950) in
  if ((string_startswith s33960 (''w''))) then
    (case  ((string_drop s33960 ((string_length (''w''))))) of
          s33970 =>
    (case  ((spc_matches_prefix0 s33970)) of
          Some ((_, s33980)) =>
    (case  ((string_drop s33970 s33980)) of
          s33990 =>
    (case  ((reg_name_matches_prefix s33990 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s34000)) =>
    (case  ((string_drop s33990 s34000)) of
          s34010 =>
    (case  ((sep_matches_prefix s34010)) of
          Some ((_, s34020)) =>
    (case  ((string_drop s34010 s34020)) of
          s34030 =>
    (case  ((reg_name_matches_prefix s34030 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s34040)) =>
    (case  ((string_drop s34030 s34040)) of
          s34050 =>
    (case  ((sep_matches_prefix s34050)) of
          Some ((_, s34060)) =>
    (case  ((string_drop s34050 s34060)) of
          s34070 =>
    (case  ((reg_name_matches_prefix s34070 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s34080)) =>
    (case  ((string_drop s34070 s34080)) of
          s2 => Some (s, rd, rs1, rs2, s2)
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))" 
  for  s33920  :: " string "


\<comment> \<open>\<open>val _s3372_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s3372  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s3372 s33730 = (
   (let s33740 = s33730 in
   if ((string_startswith s33740 (''div''))) then  
  (case  ((string_drop s33740 ((string_length (''div''))))) of
        s33750 =>
  (case  ((maybe_not_u_matches_prefix s33750)) of
        Some ((s, s33760)) =>
  (let s33770 = (string_drop s33750 s33760) in
  if ((string_startswith s33770 (''w''))) then
    (case  ((string_drop s33770 ((string_length (''w''))))) of
          s33780 =>
    (case  ((spc_matches_prefix0 s33780)) of
          Some ((_, s33790)) =>
    (case  ((string_drop s33780 s33790)) of
          s33800 =>
    (case  ((reg_name_matches_prefix s33800 :: (( 5 Word.word * ii)) option)) of
          Some ((rd, s33810)) =>
    (case  ((string_drop s33800 s33810)) of
          s33820 =>
    (case  ((sep_matches_prefix s33820)) of
          Some ((_, s33830)) =>
    (case  ((string_drop s33820 s33830)) of
          s33840 =>
    (case  ((reg_name_matches_prefix s33840 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s33850)) =>
    (case  ((string_drop s33840 s33850)) of
          s33860 =>
    (case  ((sep_matches_prefix s33860)) of
          Some ((_, s33870)) =>
    (case  ((string_drop s33860 s33870)) of
          s33880 =>
    (case  ((reg_name_matches_prefix s33880 :: (( 5 Word.word * ii)) option)) of
          Some ((rs2, s33890)) =>
    (case  ((string_drop s33880 s33890)) of
          s2 => Some (s, rd, rs1, rs2, s2)
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
   else None))" 
  for  s33730  :: " string "


\<comment> \<open>\<open>val _s3356_ : string -> maybe ((mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s3356  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s3356 s33570 = (
   (let s33580 = s33570 in
   if ((string_startswith s33580 (''mulw''))) then  
  (case  ((string_drop s33580 ((string_length (''mulw''))))) of
        s33590 =>
  (case  ((spc_matches_prefix0 s33590)) of
        Some ((_, s33600)) =>
  (case  ((string_drop s33590 s33600)) of
        s33610 =>
  (case  ((reg_name_matches_prefix s33610 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s33620)) =>
  (case  ((string_drop s33610 s33620)) of
        s33630 =>
  (case  ((sep_matches_prefix s33630)) of
        Some ((_, s33640)) =>
  (case  ((string_drop s33630 s33640)) of
        s33650 =>
  (case  ((reg_name_matches_prefix s33650 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s33660)) =>
  (case  ((string_drop s33650 s33660)) of
        s33670 =>
  (case  ((sep_matches_prefix s33670)) of
        Some ((_, s33680)) =>
  (case  ((string_drop s33670 s33680)) of
        s33690 =>
  (case  ((reg_name_matches_prefix s33690 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s33700)) =>
  (case  ((string_drop s33690 s33700)) of   s1 => Some (rd, rs1, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s33570  :: " string "


\<comment> \<open>\<open>val _s3338_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s3338  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s3338 s33390 = (
   (let s33400 = s33390 in
   if ((string_startswith s33400 (''rem''))) then  
  (case  ((string_drop s33400 ((string_length (''rem''))))) of
        s33410 =>
  (case  ((maybe_not_u_matches_prefix s33410)) of
        Some ((s, s33420)) =>
  (case  ((string_drop s33410 s33420)) of
        s33430 =>
  (case  ((spc_matches_prefix0 s33430)) of
        Some ((_, s33440)) =>
  (case  ((string_drop s33430 s33440)) of
        s33450 =>
  (case  ((reg_name_matches_prefix s33450 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s33460)) =>
  (case  ((string_drop s33450 s33460)) of
        s33470 =>
  (case  ((sep_matches_prefix s33470)) of
        Some ((_, s33480)) =>
  (case  ((string_drop s33470 s33480)) of
        s33490 =>
  (case  ((reg_name_matches_prefix s33490 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s33500)) =>
  (case  ((string_drop s33490 s33500)) of
        s33510 =>
  (case  ((sep_matches_prefix s33510)) of
        Some ((_, s33520)) =>
  (case  ((string_drop s33510 s33520)) of
        s33530 =>
  (case  ((reg_name_matches_prefix s33530 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s33540)) =>
  (case  ((string_drop s33530 s33540)) of
        s2 => Some (s, rd, rs1, rs2, s2)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s33390  :: " string "


\<comment> \<open>\<open>val _s3320_ : string -> maybe ((bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s3320  :: " string \<Rightarrow>(bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s3320 s33210 = (
   (let s33220 = s33210 in
   if ((string_startswith s33220 (''div''))) then  
  (case  ((string_drop s33220 ((string_length (''div''))))) of
        s33230 =>
  (case  ((maybe_not_u_matches_prefix s33230)) of
        Some ((s, s33240)) =>
  (case  ((string_drop s33230 s33240)) of
        s33250 =>
  (case  ((spc_matches_prefix0 s33250)) of
        Some ((_, s33260)) =>
  (case  ((string_drop s33250 s33260)) of
        s33270 =>
  (case  ((reg_name_matches_prefix s33270 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s33280)) =>
  (case  ((string_drop s33270 s33280)) of
        s33290 =>
  (case  ((sep_matches_prefix s33290)) of
        Some ((_, s33300)) =>
  (case  ((string_drop s33290 s33300)) of
        s33310 =>
  (case  ((reg_name_matches_prefix s33310 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s33320)) =>
  (case  ((string_drop s33310 s33320)) of
        s33330 =>
  (case  ((sep_matches_prefix s33330)) of
        Some ((_, s33340)) =>
  (case  ((string_drop s33330 s33340)) of
        s33350 =>
  (case  ((reg_name_matches_prefix s33350 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s33360)) =>
  (case  ((string_drop s33350 s33360)) of
        s2 => Some (s, rd, rs1, rs2, s2)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s33210  :: " string "


\<comment> \<open>\<open>val _s3303_ : string -> maybe ((bool * bool * bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s3303  :: " string \<Rightarrow>(bool*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s3303 s33050 = (
      (case  ((mul_mnemonic_matches_prefix s33050)) of
        Some (((high, signed1, signed2), s33060)) => 
  (case  ((string_drop s33050 s33060)) of
        s33070 =>
  (case  ((spc_matches_prefix0 s33070)) of
        Some ((_, s33080)) =>
  (case  ((string_drop s33070 s33080)) of
        s33090 =>
  (case  ((reg_name_matches_prefix s33090 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s33100)) =>
  (case  ((string_drop s33090 s33100)) of
        s33110 =>
  (case  ((sep_matches_prefix s33110)) of
        Some ((_, s33120)) =>
  (case  ((string_drop s33110 s33120)) of
        s33130 =>
  (case  ((reg_name_matches_prefix s33130 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s33140)) =>
  (case  ((string_drop s33130 s33140)) of
        s33150 =>
  (case  ((sep_matches_prefix s33150)) of
        Some ((_, s33160)) =>
  (case  ((string_drop s33150 s33160)) of
        s33170 =>
  (case  ((reg_name_matches_prefix s33170 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s33180)) =>
  (case  ((string_drop s33170 s33180)) of
        s1 => Some (high, signed1, signed2, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s33050  :: " string "


\<comment> \<open>\<open>val _s3291_ : string -> maybe ((mword ty5 * mword ty5 * string))\<close>\<close>

definition s3291  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*string)option "  where 
     " s3291 s32920 = (
   (let s32930 = s32920 in
   if ((string_startswith s32930 (''c.add''))) then  
  (case  ((string_drop s32930 ((string_length (''c.add''))))) of
        s32940 =>
  (case  ((spc_matches_prefix0 s32940)) of
        Some ((_, s32950)) =>
  (case  ((string_drop s32940 s32950)) of
        s32960 =>
  (case  ((reg_name_matches_prefix s32960 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s32970)) =>
  (case  ((string_drop s32960 s32970)) of
        s32980 =>
  (case  ((sep_matches_prefix s32980)) of
        Some ((_, s32990)) =>
  (case  ((string_drop s32980 s32990)) of
        s33000 =>
  (case  ((reg_name_matches_prefix s33000 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s33010)) =>
  (case  ((string_drop s33000 s33010)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s32920  :: " string "


\<comment> \<open>\<open>val _s3287_ : string -> maybe string\<close>\<close>

definition s3287  :: " string \<Rightarrow>(string)option "  where 
     " s3287 s32880 = (
   (let s32890 = s32880 in
   if ((string_startswith s32890 (''c.ebreak''))) then  
  (case  ((string_drop s32890 ((string_length (''c.ebreak''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s32880  :: " string "


\<comment> \<open>\<open>val _s3275_ : string -> maybe ((mword ty5 * mword ty5 * string))\<close>\<close>

definition s3275  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*string)option "  where 
     " s3275 s32760 = (
   (let s32770 = s32760 in
   if ((string_startswith s32770 (''c.mv''))) then  
  (case  ((string_drop s32770 ((string_length (''c.mv''))))) of
        s32780 =>
  (case  ((spc_matches_prefix0 s32780)) of
        Some ((_, s32790)) =>
  (case  ((string_drop s32780 s32790)) of
        s32800 =>
  (case  ((reg_name_matches_prefix s32800 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s32810)) =>
  (case  ((string_drop s32800 s32810)) of
        s32820 =>
  (case  ((sep_matches_prefix s32820)) of
        Some ((_, s32830)) =>
  (case  ((string_drop s32820 s32830)) of
        s32840 =>
  (case  ((reg_name_matches_prefix s32840 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s32850)) =>
  (case  ((string_drop s32840 s32850)) of   s1 => Some (rd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s32760  :: " string "


\<comment> \<open>\<open>val _s3267_ : string -> maybe ((mword ty5 * string))\<close>\<close>

definition s3267  :: " string \<Rightarrow>((5)Word.word*string)option "  where 
     " s3267 s32680 = (
   (let s32690 = s32680 in
   if ((string_startswith s32690 (''c.jalr''))) then  
  (case  ((string_drop s32690 ((string_length (''c.jalr''))))) of
        s32700 =>
  (case  ((spc_matches_prefix0 s32700)) of
        Some ((_, s32710)) =>
  (case  ((string_drop s32700 s32710)) of
        s32720 =>
  (case  ((reg_name_matches_prefix s32720 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s32730)) =>
  (case  ((string_drop s32720 s32730)) of   s1 => Some (rs1, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s32680  :: " string "


\<comment> \<open>\<open>val _s3259_ : string -> maybe ((mword ty5 * string))\<close>\<close>

definition s3259  :: " string \<Rightarrow>((5)Word.word*string)option "  where 
     " s3259 s32600 = (
   (let s32610 = s32600 in
   if ((string_startswith s32610 (''c.jr''))) then  
  (case  ((string_drop s32610 ((string_length (''c.jr''))))) of
        s32620 =>
  (case  ((spc_matches_prefix0 s32620)) of
        Some ((_, s32630)) =>
  (case  ((string_drop s32620 s32630)) of
        s32640 =>
  (case  ((reg_name_matches_prefix s32640 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s32650)) =>
  (case  ((string_drop s32640 s32650)) of   s1 => Some (rs1, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s32600  :: " string "


\<comment> \<open>\<open>val _s3247_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s3247  :: " string \<Rightarrow>((5)Word.word*(6)Word.word*string)option "  where 
     " s3247 s32480 = (
   (let s32490 = s32480 in
   if ((string_startswith s32490 (''c.sdsp''))) then  
  (case  ((string_drop s32490 ((string_length (''c.sdsp''))))) of
        s32500 =>
  (case  ((spc_matches_prefix0 s32500)) of
        Some ((_, s32510)) =>
  (case  ((string_drop s32500 s32510)) of
        s32520 =>
  (case  ((reg_name_matches_prefix s32520 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s32530)) =>
  (case  ((string_drop s32520 s32530)) of
        s32540 =>
  (case  ((sep_matches_prefix s32540)) of
        Some ((_, s32550)) =>
  (case  ((string_drop s32540 s32550)) of
        s32560 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32560 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s32570)) =>
  (case  ((string_drop s32560 s32570)) of   s1 => Some (rs2, uimm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s32480  :: " string "


\<comment> \<open>\<open>val _s3235_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s3235  :: " string \<Rightarrow>((5)Word.word*(6)Word.word*string)option "  where 
     " s3235 s32360 = (
   (let s32370 = s32360 in
   if ((string_startswith s32370 (''c.swsp''))) then  
  (case  ((string_drop s32370 ((string_length (''c.swsp''))))) of
        s32380 =>
  (case  ((spc_matches_prefix0 s32380)) of
        Some ((_, s32390)) =>
  (case  ((string_drop s32380 s32390)) of
        s32400 =>
  (case  ((reg_name_matches_prefix s32400 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s32410)) =>
  (case  ((string_drop s32400 s32410)) of
        s32420 =>
  (case  ((sep_matches_prefix s32420)) of
        Some ((_, s32430)) =>
  (case  ((string_drop s32420 s32430)) of
        s32440 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32440 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s32450)) =>
  (case  ((string_drop s32440 s32450)) of   s1 => Some (rd, uimm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s32360  :: " string "


\<comment> \<open>\<open>val _s3223_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s3223  :: " string \<Rightarrow>((5)Word.word*(6)Word.word*string)option "  where 
     " s3223 s32240 = (
   (let s32250 = s32240 in
   if ((string_startswith s32250 (''c.ldsp''))) then  
  (case  ((string_drop s32250 ((string_length (''c.ldsp''))))) of
        s32260 =>
  (case  ((spc_matches_prefix0 s32260)) of
        Some ((_, s32270)) =>
  (case  ((string_drop s32260 s32270)) of
        s32280 =>
  (case  ((reg_name_matches_prefix s32280 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s32290)) =>
  (case  ((string_drop s32280 s32290)) of
        s32300 =>
  (case  ((sep_matches_prefix s32300)) of
        Some ((_, s32310)) =>
  (case  ((string_drop s32300 s32310)) of
        s32320 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32320 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s32330)) =>
  (case  ((string_drop s32320 s32330)) of   s1 => Some (rd, uimm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s32240  :: " string "


\<comment> \<open>\<open>val _s3211_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s3211  :: " string \<Rightarrow>((5)Word.word*(6)Word.word*string)option "  where 
     " s3211 s32120 = (
   (let s32130 = s32120 in
   if ((string_startswith s32130 (''c.lwsp''))) then  
  (case  ((string_drop s32130 ((string_length (''c.lwsp''))))) of
        s32140 =>
  (case  ((spc_matches_prefix0 s32140)) of
        Some ((_, s32150)) =>
  (case  ((string_drop s32140 s32150)) of
        s32160 =>
  (case  ((reg_name_matches_prefix s32160 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s32170)) =>
  (case  ((string_drop s32160 s32170)) of
        s32180 =>
  (case  ((sep_matches_prefix s32180)) of
        Some ((_, s32190)) =>
  (case  ((string_drop s32180 s32190)) of
        s32200 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32200 :: (( 6 Word.word * ii)) option)) of
        Some ((uimm, s32210)) =>
  (case  ((string_drop s32200 s32210)) of   s1 => Some (rd, uimm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s32120  :: " string "


\<comment> \<open>\<open>val _s3199_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s3199  :: " string \<Rightarrow>((5)Word.word*(6)Word.word*string)option "  where 
     " s3199 s32000 = (
   (let s32010 = s32000 in
   if ((string_startswith s32010 (''c.slli''))) then  
  (case  ((string_drop s32010 ((string_length (''c.slli''))))) of
        s32020 =>
  (case  ((spc_matches_prefix0 s32020)) of
        Some ((_, s32030)) =>
  (case  ((string_drop s32020 s32030)) of
        s32040 =>
  (case  ((reg_name_matches_prefix s32040 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s32050)) =>
  (case  ((string_drop s32040 s32050)) of
        s32060 =>
  (case  ((sep_matches_prefix s32060)) of
        Some ((_, s32070)) =>
  (case  ((string_drop s32060 s32070)) of
        s32080 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s32080 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s32090)) =>
  (case  ((string_drop s32080 s32090)) of   s1 => Some (rsd, shamt, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s32000  :: " string "


\<comment> \<open>\<open>val _s3187_ : string -> maybe ((mword ty3 * mword ty8 * string))\<close>\<close>

definition s3187  :: " string \<Rightarrow>((3)Word.word*(8)Word.word*string)option "  where 
     " s3187 s31880 = (
   (let s31890 = s31880 in
   if ((string_startswith s31890 (''c.bnez''))) then  
  (case  ((string_drop s31890 ((string_length (''c.bnez''))))) of
        s31900 =>
  (case  ((spc_matches_prefix0 s31900)) of
        Some ((_, s31910)) =>
  (case  ((string_drop s31900 s31910)) of
        s31920 =>
  (case  ((creg_name_matches_prefix s31920 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s31930)) =>
  (case  ((string_drop s31920 s31930)) of
        s31940 =>
  (case  ((sep_matches_prefix s31940)) of
        Some ((_, s31950)) =>
  (case  ((string_drop s31940 s31950)) of
        s31960 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s31960 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s31970)) =>
  (case  ((string_drop s31960 s31970)) of   s1 => Some (rs, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s31880  :: " string "


\<comment> \<open>\<open>val _s3175_ : string -> maybe ((mword ty3 * mword ty8 * string))\<close>\<close>

definition s3175  :: " string \<Rightarrow>((3)Word.word*(8)Word.word*string)option "  where 
     " s3175 s31760 = (
   (let s31770 = s31760 in
   if ((string_startswith s31770 (''c.beqz''))) then  
  (case  ((string_drop s31770 ((string_length (''c.beqz''))))) of
        s31780 =>
  (case  ((spc_matches_prefix0 s31780)) of
        Some ((_, s31790)) =>
  (case  ((string_drop s31780 s31790)) of
        s31800 =>
  (case  ((creg_name_matches_prefix s31800 :: (( 3 Word.word * ii)) option)) of
        Some ((rs, s31810)) =>
  (case  ((string_drop s31800 s31810)) of
        s31820 =>
  (case  ((sep_matches_prefix s31820)) of
        Some ((_, s31830)) =>
  (case  ((string_drop s31820 s31830)) of
        s31840 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s31840 :: (( 8 Word.word * ii)) option)) of
        Some ((imm, s31850)) =>
  (case  ((string_drop s31840 s31850)) of   s1 => Some (rs, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s31760  :: " string "


\<comment> \<open>\<open>val _s3167_ : string -> maybe ((mword ty11 * string))\<close>\<close>

definition s3167  :: " string \<Rightarrow>((11)Word.word*string)option "  where 
     " s3167 s31680 = (
   (let s31690 = s31680 in
   if ((string_startswith s31690 (''c.j''))) then  
  (case  ((string_drop s31690 ((string_length (''c.j''))))) of
        s31700 =>
  (case  ((spc_matches_prefix0 s31700)) of
        Some ((_, s31710)) =>
  (case  ((string_drop s31700 s31710)) of
        s31720 =>
  (case  ((hex_bits_11_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s31720 :: (( 11 Word.word * ii)) option)) of
        Some ((imm, s31730)) =>
  (case  ((string_drop s31720 s31730)) of   s1 => Some (imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s31680  :: " string "


\<comment> \<open>\<open>val _s3155_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s3155  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*string)option "  where 
     " s3155 s31560 = (
   (let s31570 = s31560 in
   if ((string_startswith s31570 (''c.addw''))) then  
  (case  ((string_drop s31570 ((string_length (''c.addw''))))) of
        s31580 =>
  (case  ((spc_matches_prefix0 s31580)) of
        Some ((_, s31590)) =>
  (case  ((string_drop s31580 s31590)) of
        s31600 =>
  (case  ((creg_name_matches_prefix s31600 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s31610)) =>
  (case  ((string_drop s31600 s31610)) of
        s31620 =>
  (case  ((sep_matches_prefix s31620)) of
        Some ((_, s31630)) =>
  (case  ((string_drop s31620 s31630)) of
        s31640 =>
  (case  ((creg_name_matches_prefix s31640 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s31650)) =>
  (case  ((string_drop s31640 s31650)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s31560  :: " string "


\<comment> \<open>\<open>val _s3143_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s3143  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*string)option "  where 
     " s3143 s31440 = (
   (let s31450 = s31440 in
   if ((string_startswith s31450 (''c.subw''))) then  
  (case  ((string_drop s31450 ((string_length (''c.subw''))))) of
        s31460 =>
  (case  ((spc_matches_prefix0 s31460)) of
        Some ((_, s31470)) =>
  (case  ((string_drop s31460 s31470)) of
        s31480 =>
  (case  ((creg_name_matches_prefix s31480 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s31490)) =>
  (case  ((string_drop s31480 s31490)) of
        s31500 =>
  (case  ((sep_matches_prefix s31500)) of
        Some ((_, s31510)) =>
  (case  ((string_drop s31500 s31510)) of
        s31520 =>
  (case  ((creg_name_matches_prefix s31520 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s31530)) =>
  (case  ((string_drop s31520 s31530)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s31440  :: " string "


\<comment> \<open>\<open>val _s3131_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s3131  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*string)option "  where 
     " s3131 s31320 = (
   (let s31330 = s31320 in
   if ((string_startswith s31330 (''c.and''))) then  
  (case  ((string_drop s31330 ((string_length (''c.and''))))) of
        s31340 =>
  (case  ((spc_matches_prefix0 s31340)) of
        Some ((_, s31350)) =>
  (case  ((string_drop s31340 s31350)) of
        s31360 =>
  (case  ((creg_name_matches_prefix s31360 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s31370)) =>
  (case  ((string_drop s31360 s31370)) of
        s31380 =>
  (case  ((sep_matches_prefix s31380)) of
        Some ((_, s31390)) =>
  (case  ((string_drop s31380 s31390)) of
        s31400 =>
  (case  ((creg_name_matches_prefix s31400 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s31410)) =>
  (case  ((string_drop s31400 s31410)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s31320  :: " string "


\<comment> \<open>\<open>val _s3119_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s3119  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*string)option "  where 
     " s3119 s31200 = (
   (let s31210 = s31200 in
   if ((string_startswith s31210 (''c.or''))) then  
  (case  ((string_drop s31210 ((string_length (''c.or''))))) of
        s31220 =>
  (case  ((spc_matches_prefix0 s31220)) of
        Some ((_, s31230)) =>
  (case  ((string_drop s31220 s31230)) of
        s31240 =>
  (case  ((creg_name_matches_prefix s31240 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s31250)) =>
  (case  ((string_drop s31240 s31250)) of
        s31260 =>
  (case  ((sep_matches_prefix s31260)) of
        Some ((_, s31270)) =>
  (case  ((string_drop s31260 s31270)) of
        s31280 =>
  (case  ((creg_name_matches_prefix s31280 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s31290)) =>
  (case  ((string_drop s31280 s31290)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s31200  :: " string "


\<comment> \<open>\<open>val _s3107_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s3107  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*string)option "  where 
     " s3107 s31080 = (
   (let s31090 = s31080 in
   if ((string_startswith s31090 (''c.xor''))) then  
  (case  ((string_drop s31090 ((string_length (''c.xor''))))) of
        s31100 =>
  (case  ((spc_matches_prefix0 s31100)) of
        Some ((_, s31110)) =>
  (case  ((string_drop s31100 s31110)) of
        s31120 =>
  (case  ((creg_name_matches_prefix s31120 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s31130)) =>
  (case  ((string_drop s31120 s31130)) of
        s31140 =>
  (case  ((sep_matches_prefix s31140)) of
        Some ((_, s31150)) =>
  (case  ((string_drop s31140 s31150)) of
        s31160 =>
  (case  ((creg_name_matches_prefix s31160 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s31170)) =>
  (case  ((string_drop s31160 s31170)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s31080  :: " string "


\<comment> \<open>\<open>val _s3095_ : string -> maybe ((mword ty3 * mword ty3 * string))\<close>\<close>

definition s3095  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*string)option "  where 
     " s3095 s30960 = (
   (let s30970 = s30960 in
   if ((string_startswith s30970 (''c.sub''))) then  
  (case  ((string_drop s30970 ((string_length (''c.sub''))))) of
        s30980 =>
  (case  ((spc_matches_prefix0 s30980)) of
        Some ((_, s30990)) =>
  (case  ((string_drop s30980 s30990)) of
        s31000 =>
  (case  ((creg_name_matches_prefix s31000 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s31010)) =>
  (case  ((string_drop s31000 s31010)) of
        s31020 =>
  (case  ((sep_matches_prefix s31020)) of
        Some ((_, s31030)) =>
  (case  ((string_drop s31020 s31030)) of
        s31040 =>
  (case  ((creg_name_matches_prefix s31040 :: (( 3 Word.word * ii)) option)) of
        Some ((rs2, s31050)) =>
  (case  ((string_drop s31040 s31050)) of   s1 => Some (rsd, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s30960  :: " string "


\<comment> \<open>\<open>val _s3083_ : string -> maybe ((mword ty3 * mword ty6 * string))\<close>\<close>

definition s3083  :: " string \<Rightarrow>((3)Word.word*(6)Word.word*string)option "  where 
     " s3083 s30840 = (
   (let s30850 = s30840 in
   if ((string_startswith s30850 (''c.andi''))) then  
  (case  ((string_drop s30850 ((string_length (''c.andi''))))) of
        s30860 =>
  (case  ((spc_matches_prefix0 s30860)) of
        Some ((_, s30870)) =>
  (case  ((string_drop s30860 s30870)) of
        s30880 =>
  (case  ((creg_name_matches_prefix s30880 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s30890)) =>
  (case  ((string_drop s30880 s30890)) of
        s30900 =>
  (case  ((sep_matches_prefix s30900)) of
        Some ((_, s30910)) =>
  (case  ((string_drop s30900 s30910)) of
        s30920 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s30920 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s30930)) =>
  (case  ((string_drop s30920 s30930)) of   s1 => Some (rsd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s30840  :: " string "


\<comment> \<open>\<open>val _s3071_ : string -> maybe ((mword ty3 * mword ty6 * string))\<close>\<close>

definition s3071  :: " string \<Rightarrow>((3)Word.word*(6)Word.word*string)option "  where 
     " s3071 s30720 = (
   (let s30730 = s30720 in
   if ((string_startswith s30730 (''c.srai''))) then  
  (case  ((string_drop s30730 ((string_length (''c.srai''))))) of
        s30740 =>
  (case  ((spc_matches_prefix0 s30740)) of
        Some ((_, s30750)) =>
  (case  ((string_drop s30740 s30750)) of
        s30760 =>
  (case  ((creg_name_matches_prefix s30760 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s30770)) =>
  (case  ((string_drop s30760 s30770)) of
        s30780 =>
  (case  ((sep_matches_prefix s30780)) of
        Some ((_, s30790)) =>
  (case  ((string_drop s30780 s30790)) of
        s30800 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s30800 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s30810)) =>
  (case  ((string_drop s30800 s30810)) of   s1 => Some (rsd, shamt, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s30720  :: " string "


\<comment> \<open>\<open>val _s3059_ : string -> maybe ((mword ty3 * mword ty6 * string))\<close>\<close>

definition s3059  :: " string \<Rightarrow>((3)Word.word*(6)Word.word*string)option "  where 
     " s3059 s30600 = (
   (let s30610 = s30600 in
   if ((string_startswith s30610 (''c.srli''))) then  
  (case  ((string_drop s30610 ((string_length (''c.srli''))))) of
        s30620 =>
  (case  ((spc_matches_prefix0 s30620)) of
        Some ((_, s30630)) =>
  (case  ((string_drop s30620 s30630)) of
        s30640 =>
  (case  ((creg_name_matches_prefix s30640 :: (( 3 Word.word * ii)) option)) of
        Some ((rsd, s30650)) =>
  (case  ((string_drop s30640 s30650)) of
        s30660 =>
  (case  ((sep_matches_prefix s30660)) of
        Some ((_, s30670)) =>
  (case  ((string_drop s30660 s30670)) of
        s30680 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s30680 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s30690)) =>
  (case  ((string_drop s30680 s30690)) of   s1 => Some (rsd, shamt, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s30600  :: " string "


\<comment> \<open>\<open>val _s3047_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s3047  :: " string \<Rightarrow>((5)Word.word*(6)Word.word*string)option "  where 
     " s3047 s30480 = (
   (let s30490 = s30480 in
   if ((string_startswith s30490 (''c.lui''))) then  
  (case  ((string_drop s30490 ((string_length (''c.lui''))))) of
        s30500 =>
  (case  ((spc_matches_prefix0 s30500)) of
        Some ((_, s30510)) =>
  (case  ((string_drop s30500 s30510)) of
        s30520 =>
  (case  ((reg_name_matches_prefix s30520 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s30530)) =>
  (case  ((string_drop s30520 s30530)) of
        s30540 =>
  (case  ((sep_matches_prefix s30540)) of
        Some ((_, s30550)) =>
  (case  ((string_drop s30540 s30550)) of
        s30560 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s30560 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s30570)) =>
  (case  ((string_drop s30560 s30570)) of   s1 => Some (rd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s30480  :: " string "


\<comment> \<open>\<open>val _s3039_ : string -> maybe ((mword ty6 * string))\<close>\<close>

definition s3039  :: " string \<Rightarrow>((6)Word.word*string)option "  where 
     " s3039 s30400 = (
   (let s30410 = s30400 in
   if ((string_startswith s30410 (''c.addi16sp''))) then  
  (case  ((string_drop s30410 ((string_length (''c.addi16sp''))))) of
        s30420 =>
  (case  ((spc_matches_prefix0 s30420)) of
        Some ((_, s30430)) =>
  (case  ((string_drop s30420 s30430)) of
        s30440 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s30440 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s30450)) =>
  (case  ((string_drop s30440 s30450)) of   s1 => Some (imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s30400  :: " string "


\<comment> \<open>\<open>val _s3027_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s3027  :: " string \<Rightarrow>((5)Word.word*(6)Word.word*string)option "  where 
     " s3027 s30280 = (
   (let s30290 = s30280 in
   if ((string_startswith s30290 (''c.li''))) then  
  (case  ((string_drop s30290 ((string_length (''c.li''))))) of
        s30300 =>
  (case  ((spc_matches_prefix0 s30300)) of
        Some ((_, s30310)) =>
  (case  ((string_drop s30300 s30310)) of
        s30320 =>
  (case  ((reg_name_matches_prefix s30320 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s30330)) =>
  (case  ((string_drop s30320 s30330)) of
        s30340 =>
  (case  ((sep_matches_prefix s30340)) of
        Some ((_, s30350)) =>
  (case  ((string_drop s30340 s30350)) of
        s30360 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s30360 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s30370)) =>
  (case  ((string_drop s30360 s30370)) of   s1 => Some (rd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s30280  :: " string "


\<comment> \<open>\<open>val _s3015_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s3015  :: " string \<Rightarrow>((5)Word.word*(6)Word.word*string)option "  where 
     " s3015 s30160 = (
   (let s30170 = s30160 in
   if ((string_startswith s30170 (''c.addiw''))) then  
  (case  ((string_drop s30170 ((string_length (''c.addiw''))))) of
        s30180 =>
  (case  ((spc_matches_prefix0 s30180)) of
        Some ((_, s30190)) =>
  (case  ((string_drop s30180 s30190)) of
        s30200 =>
  (case  ((reg_name_matches_prefix s30200 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s30210)) =>
  (case  ((string_drop s30200 s30210)) of
        s30220 =>
  (case  ((sep_matches_prefix s30220)) of
        Some ((_, s30230)) =>
  (case  ((string_drop s30220 s30230)) of
        s30240 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s30240 :: (( 6 Word.word * ii)) option)) of
        Some ((imm, s30250)) =>
  (case  ((string_drop s30240 s30250)) of   s1 => Some (rsd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s30160  :: " string "


\<comment> \<open>\<open>val _s3007_ : string -> maybe ((mword ty11 * string))\<close>\<close>

definition s3007  :: " string \<Rightarrow>((11)Word.word*string)option "  where 
     " s3007 s30080 = (
   (let s30090 = s30080 in
   if ((string_startswith s30090 (''c.jal''))) then  
  (case  ((string_drop s30090 ((string_length (''c.jal''))))) of
        s30100 =>
  (case  ((spc_matches_prefix0 s30100)) of
        Some ((_, s30110)) =>
  (case  ((string_drop s30100 s30110)) of
        s30120 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s30120 :: (( 12 Word.word * ii)) option)) of
        Some ((v__826, s30130)) =>
  if (((((subrange_vec_dec v__826 (( 0 :: int):: ii) (( 0 :: int):: ii) :: 1 Word.word))
          = (vec_of_bits [B0] :: 1 Word.word)))) then
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__826
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (let (imm :: 11 Word.word) = ((subrange_vec_dec v__826
                                     (( 11 :: int):: ii) (( 1 :: int):: ii) :: 11 Word.word)) in
    (case  ((string_drop s30120 s30130)) of   s1 => Some (imm, s1) ))) else
    None
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s30080  :: " string "


\<comment> \<open>\<open>val _s2995_ : string -> maybe ((mword ty5 * mword ty6 * string))\<close>\<close>

definition s2995  :: " string \<Rightarrow>((5)Word.word*(6)Word.word*string)option "  where 
     " s2995 s29960 = (
   (let s29970 = s29960 in
   if ((string_startswith s29970 (''c.addi''))) then  
  (case  ((string_drop s29970 ((string_length (''c.addi''))))) of
        s29980 =>
  (case  ((spc_matches_prefix0 s29980)) of
        Some ((_, s29990)) =>
  (case  ((string_drop s29980 s29990)) of
        s30000 =>
  (case  ((reg_name_matches_prefix s30000 :: (( 5 Word.word * ii)) option)) of
        Some ((rsd, s30010)) =>
  (case  ((string_drop s30000 s30010)) of
        s30020 =>
  (case  ((sep_matches_prefix s30020)) of
        Some ((_, s30030)) =>
  (case  ((string_drop s30020 s30030)) of
        s30040 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s30040 :: (( 6 Word.word * ii)) option)) of
        Some ((nzi, s30050)) =>
  (case  ((string_drop s30040 s30050)) of   s1 => Some (rsd, nzi, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s29960  :: " string "


\<comment> \<open>\<open>val _s2979_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s2979  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option "  where 
     " s2979 s29800 = (
   (let s29810 = s29800 in
   if ((string_startswith s29810 (''c.sd''))) then  
  (case  ((string_drop s29810 ((string_length (''c.sd''))))) of
        s29820 =>
  (case  ((spc_matches_prefix0 s29820)) of
        Some ((_, s29830)) =>
  (case  ((string_drop s29820 s29830)) of
        s29840 =>
  (case  ((creg_name_matches_prefix s29840 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s29850)) =>
  (case  ((string_drop s29840 s29850)) of
        s29860 =>
  (case  ((sep_matches_prefix s29860)) of
        Some ((_, s29870)) =>
  (case  ((string_drop s29860 s29870)) of
        s29880 =>
  (case  ((creg_name_matches_prefix s29880 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s29890)) =>
  (case  ((string_drop s29880 s29890)) of
        s29900 =>
  (case  ((sep_matches_prefix s29900)) of
        Some ((_, s29910)) =>
  (case  ((string_drop s29900 s29910)) of
        s29920 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s29920 :: (( 8 Word.word * ii)) option)) of
        Some ((v__828, s29930)) =>
  if (((((subrange_vec_dec v__828 (( 2 :: int):: ii) (( 0 :: int):: ii) :: 3 Word.word))
          = (vec_of_bits [B0,B0,B0] :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__828 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__828 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s29920 s29930)) of
          s1 => Some (rsc1, rsc2, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s29800  :: " string "


\<comment> \<open>\<open>val _s2963_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s2963  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option "  where 
     " s2963 s29640 = (
   (let s29650 = s29640 in
   if ((string_startswith s29650 (''c.sw''))) then  
  (case  ((string_drop s29650 ((string_length (''c.sw''))))) of
        s29660 =>
  (case  ((spc_matches_prefix0 s29660)) of
        Some ((_, s29670)) =>
  (case  ((string_drop s29660 s29670)) of
        s29680 =>
  (case  ((creg_name_matches_prefix s29680 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc1, s29690)) =>
  (case  ((string_drop s29680 s29690)) of
        s29700 =>
  (case  ((sep_matches_prefix s29700)) of
        Some ((_, s29710)) =>
  (case  ((string_drop s29700 s29710)) of
        s29720 =>
  (case  ((creg_name_matches_prefix s29720 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc2, s29730)) =>
  (case  ((string_drop s29720 s29730)) of
        s29740 =>
  (case  ((sep_matches_prefix s29740)) of
        Some ((_, s29750)) =>
  (case  ((string_drop s29740 s29750)) of
        s29760 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s29760 :: (( 7 Word.word * ii)) option)) of
        Some ((v__830, s29770)) =>
  if (((((subrange_vec_dec v__830 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = (vec_of_bits [B0,B0] :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__830 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__830 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s29760 s29770)) of
          s1 => Some (rsc1, rsc2, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s29640  :: " string "


\<comment> \<open>\<open>val _s2947_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s2947  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option "  where 
     " s2947 s29480 = (
   (let s29490 = s29480 in
   if ((string_startswith s29490 (''c.ld''))) then  
  (case  ((string_drop s29490 ((string_length (''c.ld''))))) of
        s29500 =>
  (case  ((spc_matches_prefix0 s29500)) of
        Some ((_, s29510)) =>
  (case  ((string_drop s29500 s29510)) of
        s29520 =>
  (case  ((creg_name_matches_prefix s29520 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s29530)) =>
  (case  ((string_drop s29520 s29530)) of
        s29540 =>
  (case  ((sep_matches_prefix s29540)) of
        Some ((_, s29550)) =>
  (case  ((string_drop s29540 s29550)) of
        s29560 =>
  (case  ((creg_name_matches_prefix s29560 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s29570)) =>
  (case  ((string_drop s29560 s29570)) of
        s29580 =>
  (case  ((sep_matches_prefix s29580)) of
        Some ((_, s29590)) =>
  (case  ((string_drop s29580 s29590)) of
        s29600 =>
  (case  ((hex_bits_8_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s29600 :: (( 8 Word.word * ii)) option)) of
        Some ((v__832, s29610)) =>
  if (((((subrange_vec_dec v__832 (( 2 :: int):: ii) (( 0 :: int):: ii) :: 3 Word.word))
          = (vec_of_bits [B0,B0,B0] :: 3 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__832 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__832 (( 7 :: int):: ii) (( 3 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s29600 s29610)) of
          s1 => Some (rdc, rsc, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s29480  :: " string "


\<comment> \<open>\<open>val _s2931_ : string -> maybe ((mword ty3 * mword ty3 * mword ty5 * string))\<close>\<close>

definition s2931  :: " string \<Rightarrow>((3)Word.word*(3)Word.word*(5)Word.word*string)option "  where 
     " s2931 s29320 = (
   (let s29330 = s29320 in
   if ((string_startswith s29330 (''c.lw''))) then  
  (case  ((string_drop s29330 ((string_length (''c.lw''))))) of
        s29340 =>
  (case  ((spc_matches_prefix0 s29340)) of
        Some ((_, s29350)) =>
  (case  ((string_drop s29340 s29350)) of
        s29360 =>
  (case  ((creg_name_matches_prefix s29360 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s29370)) =>
  (case  ((string_drop s29360 s29370)) of
        s29380 =>
  (case  ((sep_matches_prefix s29380)) of
        Some ((_, s29390)) =>
  (case  ((string_drop s29380 s29390)) of
        s29400 =>
  (case  ((creg_name_matches_prefix s29400 :: (( 3 Word.word * ii)) option)) of
        Some ((rsc, s29410)) =>
  (case  ((string_drop s29400 s29410)) of
        s29420 =>
  (case  ((sep_matches_prefix s29420)) of
        Some ((_, s29430)) =>
  (case  ((string_drop s29420 s29430)) of
        s29440 =>
  (case  ((hex_bits_7_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s29440 :: (( 7 Word.word * ii)) option)) of
        Some ((v__834, s29450)) =>
  if (((((subrange_vec_dec v__834 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = (vec_of_bits [B0,B0] :: 2 Word.word)))) then
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__834 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (let (uimm :: 5 Word.word) =
         ((subrange_vec_dec v__834 (( 6 :: int):: ii) (( 2 :: int):: ii) :: 5 Word.word)) in
    (case  ((string_drop s29440 s29450)) of
          s1 => Some (rdc, rsc, uimm, s1)
    ))) else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s29320  :: " string "


\<comment> \<open>\<open>val _s2919_ : string -> maybe ((mword ty3 * mword ty8 * string))\<close>\<close>

definition s2919  :: " string \<Rightarrow>((3)Word.word*(8)Word.word*string)option "  where 
     " s2919 s29200 = (
   (let s29210 = s29200 in
   if ((string_startswith s29210 (''c.addi4spn''))) then  
  (case  ((string_drop s29210 ((string_length (''c.addi4spn''))))) of
        s29220 =>
  (case  ((spc_matches_prefix0 s29220)) of
        Some ((_, s29230)) =>
  (case  ((string_drop s29220 s29230)) of
        s29240 =>
  (case  ((creg_name_matches_prefix s29240 :: (( 3 Word.word * ii)) option)) of
        Some ((rdc, s29250)) =>
  (case  ((string_drop s29240 s29250)) of
        s29260 =>
  (case  ((sep_matches_prefix s29260)) of
        Some ((_, s29270)) =>
  (case  ((string_drop s29260 s29270)) of
        s29280 =>
  (case  ((hex_bits_10_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s29280 :: (( 10 Word.word * ii)) option)) of
        Some ((v__836, s29290)) =>
  if (((((subrange_vec_dec v__836 (( 1 :: int):: ii) (( 0 :: int):: ii) :: 2 Word.word))
          = (vec_of_bits [B0,B0] :: 2 Word.word)))) then
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__836 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (let (nzimm :: 8 Word.word) =
         ((subrange_vec_dec v__836 (( 9 :: int):: ii) (( 2 :: int):: ii) :: 8 Word.word)) in
    (case  ((string_drop s29280 s29290)) of   s1 => Some (rdc, nzimm, s1) )))
  else None
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s29200  :: " string "


\<comment> \<open>\<open>val _s2915_ : string -> maybe string\<close>\<close>

definition s2915  :: " string \<Rightarrow>(string)option "  where 
     " s2915 s29160 = (
   (let s29170 = s29160 in
   if ((string_startswith s29170 (''c.nop''))) then  
  (case  ((string_drop s29170 ((string_length (''c.nop''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s29160  :: " string "


\<comment> \<open>\<open>val _s2891_ : string -> maybe ((amoop * word_width * bool * bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s2891  :: " string \<Rightarrow>(amoop*word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s2891 s28930 = (
      (case  ((amo_mnemonic_matches_prefix s28930)) of
        Some ((op1, s28940)) =>
         (let s28950 = (string_drop s28930 s28940) in
         if ((string_startswith s28950 (''.''))) then  
  (case  ((string_drop s28950 ((string_length (''.''))))) of
        s28960 =>
  (case  ((size_mnemonic_matches_prefix s28960)) of
        Some ((width, s28970)) =>
  (case  ((string_drop s28960 s28970)) of
        s28980 =>
  (case  ((maybe_aq_matches_prefix s28980)) of
        Some ((aq, s28990)) =>
  (case  ((string_drop s28980 s28990)) of
        s29000 =>
  (case  ((maybe_rl_matches_prefix s29000)) of
        Some ((rl, s29010)) =>
  (case  ((string_drop s29000 s29010)) of
        s29020 =>
  (case  ((spc_matches_prefix0 s29020)) of
        Some ((_, s29030)) =>
  (case  ((string_drop s29020 s29030)) of
        s29040 =>
  (case  ((reg_name_matches_prefix s29040 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s29050)) =>
  (case  ((string_drop s29040 s29050)) of
        s29060 =>
  (case  ((sep_matches_prefix s29060)) of
        Some ((_, s29070)) =>
  (case  ((string_drop s29060 s29070)) of
        s29080 =>
  (case  ((reg_name_matches_prefix s29080 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s29090)) =>
  (case  ((string_drop s29080 s29090)) of
        s29100 =>
  (case  ((sep_matches_prefix s29100)) of
        Some ((_, s29110)) =>
  (case  ((string_drop s29100 s29110)) of
        s29120 =>
  (case  ((reg_name_matches_prefix s29120 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s29130)) =>
  (case  ((string_drop s29120 s29130)) of
        s1 =>
  Some (op1, width, aq, rl, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
         else None)
      | _ => None
      ))" 
  for  s28930  :: " string "


\<comment> \<open>\<open>val _s2869_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s2869  :: " string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s2869 s28700 = (
   (let s28710 = s28700 in
   if ((string_startswith s28710 (''sc.''))) then  
  (case  ((string_drop s28710 ((string_length (''sc.''))))) of
        s28720 =>
  (case  ((size_mnemonic_matches_prefix s28720)) of
        Some ((size1, s28730)) =>
  (case  ((string_drop s28720 s28730)) of
        s28740 =>
  (case  ((maybe_aq_matches_prefix s28740)) of
        Some ((aq, s28750)) =>
  (case  ((string_drop s28740 s28750)) of
        s28760 =>
  (case  ((maybe_rl_matches_prefix s28760)) of
        Some ((rl, s28770)) =>
  (case  ((string_drop s28760 s28770)) of
        s28780 =>
  (case  ((spc_matches_prefix0 s28780)) of
        Some ((_, s28790)) =>
  (case  ((string_drop s28780 s28790)) of
        s28800 =>
  (case  ((reg_name_matches_prefix s28800 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s28810)) =>
  (case  ((string_drop s28800 s28810)) of
        s28820 =>
  (case  ((sep_matches_prefix s28820)) of
        Some ((_, s28830)) =>
  (case  ((string_drop s28820 s28830)) of
        s28840 =>
  (case  ((reg_name_matches_prefix s28840 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s28850)) =>
  (case  ((string_drop s28840 s28850)) of
        s28860 =>
  (case  ((sep_matches_prefix s28860)) of
        Some ((_, s28870)) =>
  (case  ((string_drop s28860 s28870)) of
        s28880 =>
  (case  ((reg_name_matches_prefix s28880 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s28890)) =>
  (case  ((string_drop s28880 s28890)) of
        s1 =>
  Some (size1, aq, rl, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s28700  :: " string "


\<comment> \<open>\<open>val _s2851_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty5 * string))\<close>\<close>

definition s2851  :: " string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(5)Word.word*string)option "  where 
     " s2851 s28520 = (
   (let s28530 = s28520 in
   if ((string_startswith s28530 (''lr.''))) then  
  (case  ((string_drop s28530 ((string_length (''lr.''))))) of
        s28540 =>
  (case  ((size_mnemonic_matches_prefix s28540)) of
        Some ((size1, s28550)) =>
  (case  ((string_drop s28540 s28550)) of
        s28560 =>
  (case  ((maybe_aq_matches_prefix s28560)) of
        Some ((aq, s28570)) =>
  (case  ((string_drop s28560 s28570)) of
        s28580 =>
  (case  ((maybe_rl_matches_prefix s28580)) of
        Some ((rl, s28590)) =>
  (case  ((string_drop s28580 s28590)) of
        s28600 =>
  (case  ((spc_matches_prefix0 s28600)) of
        Some ((_, s28610)) =>
  (case  ((string_drop s28600 s28610)) of
        s28620 =>
  (case  ((reg_name_matches_prefix s28620 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s28630)) =>
  (case  ((string_drop s28620 s28630)) of
        s28640 =>
  (case  ((sep_matches_prefix s28640)) of
        Some ((_, s28650)) =>
  (case  ((string_drop s28640 s28650)) of
        s28660 =>
  (case  ((reg_name_matches_prefix s28660 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s28670)) =>
  (case  ((string_drop s28660 s28670)) of
        s1 => Some (size1, aq, rl, rd, rs1, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s28520  :: " string "


\<comment> \<open>\<open>val _s2839_ : string -> maybe ((mword ty5 * mword ty5 * string))\<close>\<close>

definition s2839  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*string)option "  where 
     " s2839 s28400 = (
   (let s28410 = s28400 in
   if ((string_startswith s28410 (''sfence.vma''))) then  
  (case  ((string_drop s28410 ((string_length (''sfence.vma''))))) of
        s28420 =>
  (case  ((spc_matches_prefix0 s28420)) of
        Some ((_, s28430)) =>
  (case  ((string_drop s28420 s28430)) of
        s28440 =>
  (case  ((reg_name_matches_prefix s28440 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s28450)) =>
  (case  ((string_drop s28440 s28450)) of
        s28460 =>
  (case  ((sep_matches_prefix s28460)) of
        Some ((_, s28470)) =>
  (case  ((string_drop s28460 s28470)) of
        s28480 =>
  (case  ((reg_name_matches_prefix s28480 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s28490)) =>
  (case  ((string_drop s28480 s28490)) of   s1 => Some (rs1, rs2, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s28400  :: " string "


\<comment> \<open>\<open>val _s2835_ : string -> maybe string\<close>\<close>

definition s2835  :: " string \<Rightarrow>(string)option "  where 
     " s2835 s28360 = (
   (let s28370 = s28360 in
   if ((string_startswith s28370 (''wfi''))) then  
  (case  ((string_drop s28370 ((string_length (''wfi''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s28360  :: " string "


\<comment> \<open>\<open>val _s2831_ : string -> maybe string\<close>\<close>

definition s2831  :: " string \<Rightarrow>(string)option "  where 
     " s2831 s28320 = (
   (let s28330 = s28320 in
   if ((string_startswith s28330 (''ebreak''))) then  
  (case  ((string_drop s28330 ((string_length (''ebreak''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s28320  :: " string "


\<comment> \<open>\<open>val _s2827_ : string -> maybe string\<close>\<close>

definition s2827  :: " string \<Rightarrow>(string)option "  where 
     " s2827 s28280 = (
   (let s28290 = s28280 in
   if ((string_startswith s28290 (''sret''))) then  
  (case  ((string_drop s28290 ((string_length (''sret''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s28280  :: " string "


\<comment> \<open>\<open>val _s2823_ : string -> maybe string\<close>\<close>

definition s2823  :: " string \<Rightarrow>(string)option "  where 
     " s2823 s28240 = (
   (let s28250 = s28240 in
   if ((string_startswith s28250 (''mret''))) then  
  (case  ((string_drop s28250 ((string_length (''mret''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s28240  :: " string "


\<comment> \<open>\<open>val _s2819_ : string -> maybe string\<close>\<close>

definition s2819  :: " string \<Rightarrow>(string)option "  where 
     " s2819 s28200 = (
   (let s28210 = s28200 in
   if ((string_startswith s28210 (''ecall''))) then  
  (case  ((string_drop s28210 ((string_length (''ecall''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s28200  :: " string "


\<comment> \<open>\<open>val _s2815_ : string -> maybe string\<close>\<close>

definition s2815  :: " string \<Rightarrow>(string)option "  where 
     " s2815 s28160 = (
   (let s28170 = s28160 in
   if ((string_startswith s28170 (''fence.i''))) then  
  (case  ((string_drop s28170 ((string_length (''fence.i''))))) of
        s1 => Some s1
  )
   else None))" 
  for  s28160  :: " string "


\<comment> \<open>\<open>val _s2803_ : string -> maybe ((mword ty4 * mword ty4 * string))\<close>\<close>

definition s2803  :: " string \<Rightarrow>((4)Word.word*(4)Word.word*string)option "  where 
     " s2803 s28040 = (
   (let s28050 = s28040 in
   if ((string_startswith s28050 (''fence.tso''))) then  
  (case  ((string_drop s28050 ((string_length (''fence.tso''))))) of
        s28060 =>
  (case  ((spc_matches_prefix0 s28060)) of
        Some ((_, s28070)) =>
  (case  ((string_drop s28060 s28070)) of
        s28080 =>
  (case  ((fence_bits_matches_prefix s28080 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s28090)) =>
  (case  ((string_drop s28080 s28090)) of
        s28100 =>
  (case  ((sep_matches_prefix s28100)) of
        Some ((_, s28110)) =>
  (case  ((string_drop s28100 s28110)) of
        s28120 =>
  (case  ((fence_bits_matches_prefix s28120 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s28130)) =>
  (case  ((string_drop s28120 s28130)) of   s1 => Some (pred, succ, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s28040  :: " string "


\<comment> \<open>\<open>val _s2791_ : string -> maybe ((mword ty4 * mword ty4 * string))\<close>\<close>

definition s2791  :: " string \<Rightarrow>((4)Word.word*(4)Word.word*string)option "  where 
     " s2791 s27920 = (
   (let s27930 = s27920 in
   if ((string_startswith s27930 (''fence''))) then  
  (case  ((string_drop s27930 ((string_length (''fence''))))) of
        s27940 =>
  (case  ((spc_matches_prefix0 s27940)) of
        Some ((_, s27950)) =>
  (case  ((string_drop s27940 s27950)) of
        s27960 =>
  (case  ((fence_bits_matches_prefix s27960 :: (( 4 Word.word * ii)) option)) of
        Some ((pred, s27970)) =>
  (case  ((string_drop s27960 s27970)) of
        s27980 =>
  (case  ((sep_matches_prefix s27980)) of
        Some ((_, s27990)) =>
  (case  ((string_drop s27980 s27990)) of
        s28000 =>
  (case  ((fence_bits_matches_prefix s28000 :: (( 4 Word.word * ii)) option)) of
        Some ((succ, s28010)) =>
  (case  ((string_drop s28000 s28010)) of   s1 => Some (pred, succ, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s27920  :: " string "


\<comment> \<open>\<open>val _s2774_ : string -> maybe ((sopw * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s2774  :: " string \<Rightarrow>(sopw*(5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s2774 s27760 = (
      (case  ((shiftiwop_mnemonic_matches_prefix s27760)) of
        Some ((op1, s27770)) => 
  (case  ((string_drop s27760 s27770)) of
        s27780 =>
  (case  ((spc_matches_prefix0 s27780)) of
        Some ((_, s27790)) =>
  (case  ((string_drop s27780 s27790)) of
        s27800 =>
  (case  ((reg_name_matches_prefix s27800 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s27810)) =>
  (case  ((string_drop s27800 s27810)) of
        s27820 =>
  (case  ((sep_matches_prefix s27820)) of
        Some ((_, s27830)) =>
  (case  ((string_drop s27820 s27830)) of
        s27840 =>
  (case  ((reg_name_matches_prefix s27840 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s27850)) =>
  (case  ((string_drop s27840 s27850)) of
        s27860 =>
  (case  ((sep_matches_prefix s27860)) of
        Some ((_, s27870)) =>
  (case  ((string_drop s27860 s27870)) of
        s27880 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s27880 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s27890)) =>
  (case  ((string_drop s27880 s27890)) of
        s1 => Some (op1, rd, rs1, shamt, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s27760  :: " string "


\<comment> \<open>\<open>val _s2757_ : string -> maybe ((ropw * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s2757  :: " string \<Rightarrow>(ropw*(5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s2757 s27590 = (
      (case  ((rtypew_mnemonic_matches_prefix s27590)) of
        Some ((op1, s27600)) => 
  (case  ((string_drop s27590 s27600)) of
        s27610 =>
  (case  ((spc_matches_prefix0 s27610)) of
        Some ((_, s27620)) =>
  (case  ((string_drop s27610 s27620)) of
        s27630 =>
  (case  ((reg_name_matches_prefix s27630 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s27640)) =>
  (case  ((string_drop s27630 s27640)) of
        s27650 =>
  (case  ((sep_matches_prefix s27650)) of
        Some ((_, s27660)) =>
  (case  ((string_drop s27650 s27660)) of
        s27670 =>
  (case  ((reg_name_matches_prefix s27670 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s27680)) =>
  (case  ((string_drop s27670 s27680)) of
        s27690 =>
  (case  ((sep_matches_prefix s27690)) of
        Some ((_, s27700)) =>
  (case  ((string_drop s27690 s27700)) of
        s27710 =>
  (case  ((reg_name_matches_prefix s27710 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s27720)) =>
  (case  ((string_drop s27710 s27720)) of
        s1 => Some (op1, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s27590  :: " string "


\<comment> \<open>\<open>val _s2740_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s2740  :: " string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s2740 s27420 = (
      (case  ((shiftw_mnemonic_matches_prefix s27420)) of
        Some ((op1, s27430)) => 
  (case  ((string_drop s27420 s27430)) of
        s27440 =>
  (case  ((spc_matches_prefix0 s27440)) of
        Some ((_, s27450)) =>
  (case  ((string_drop s27440 s27450)) of
        s27460 =>
  (case  ((reg_name_matches_prefix s27460 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s27470)) =>
  (case  ((string_drop s27460 s27470)) of
        s27480 =>
  (case  ((sep_matches_prefix s27480)) of
        Some ((_, s27490)) =>
  (case  ((string_drop s27480 s27490)) of
        s27500 =>
  (case  ((reg_name_matches_prefix s27500 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s27510)) =>
  (case  ((string_drop s27500 s27510)) of
        s27520 =>
  (case  ((sep_matches_prefix s27520)) of
        Some ((_, s27530)) =>
  (case  ((string_drop s27520 s27530)) of
        s27540 =>
  (case  ((hex_bits_5_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s27540 :: (( 5 Word.word * ii)) option)) of
        Some ((shamt, s27550)) =>
  (case  ((string_drop s27540 s27550)) of
        s1 => Some (op1, rd, rs1, shamt, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s27420  :: " string "


\<comment> \<open>\<open>val _s2724_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12 * string))\<close>\<close>

definition s2724  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word*string)option "  where 
     " s2724 s27250 = (
   (let s27260 = s27250 in
   if ((string_startswith s27260 (''addiw''))) then  
  (case  ((string_drop s27260 ((string_length (''addiw''))))) of
        s27270 =>
  (case  ((spc_matches_prefix0 s27270)) of
        Some ((_, s27280)) =>
  (case  ((string_drop s27270 s27280)) of
        s27290 =>
  (case  ((reg_name_matches_prefix s27290 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s27300)) =>
  (case  ((string_drop s27290 s27300)) of
        s27310 =>
  (case  ((sep_matches_prefix s27310)) of
        Some ((_, s27320)) =>
  (case  ((string_drop s27310 s27320)) of
        s27330 =>
  (case  ((reg_name_matches_prefix s27330 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s27340)) =>
  (case  ((string_drop s27330 s27340)) of
        s27350 =>
  (case  ((sep_matches_prefix s27350)) of
        Some ((_, s27360)) =>
  (case  ((string_drop s27350 s27360)) of
        s27370 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s27370 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s27380)) =>
  (case  ((string_drop s27370 s27380)) of   s1 => Some (rd, rs1, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s27250  :: " string "


\<comment> \<open>\<open>val _s2696_ : string -> maybe ((word_width * bool * bool * mword ty5 * mword ty12 * mword ty5 * string))\<close>\<close>

definition s2696  :: " string \<Rightarrow>(word_width*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word*string)option "  where 
     " s2696 s26970 = (
   (let s26980 = s26970 in
   if ((string_startswith s26980 (''s''))) then  
  (case  ((string_drop s26980 ((string_length (''s''))))) of
        s26990 =>
  (case  ((size_mnemonic_matches_prefix s26990)) of
        Some ((size1, s27000)) =>
  (case  ((string_drop s26990 s27000)) of
        s27010 =>
  (case  ((maybe_aq_matches_prefix s27010)) of
        Some ((aq, s27020)) =>
  (case  ((string_drop s27010 s27020)) of
        s27030 =>
  (case  ((maybe_rl_matches_prefix s27030)) of
        Some ((rl, s27040)) =>
  (case  ((string_drop s27030 s27040)) of
        s27050 =>
  (case  ((spc_matches_prefix0 s27050)) of
        Some ((_, s27060)) =>
  (case  ((string_drop s27050 s27060)) of
        s27070 =>
  (case  ((reg_name_matches_prefix s27070 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s27080)) =>
  (case  ((string_drop s27070 s27080)) of
        s27090 =>
  (case  ((sep_matches_prefix s27090)) of
        Some ((_, s27100)) =>
  (case  ((string_drop s27090 s27100)) of
        s27110 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s27110 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s27120)) =>
  (case  ((string_drop s27110 s27120)) of
        s27130 =>
  (case  ((opt_spc_matches_prefix0 s27130)) of
        Some ((_, s27140)) =>
  (let s27150 = (string_drop s27130 s27140) in
  if ((string_startswith s27150 (''(''))) then
    (case  ((string_drop s27150 ((string_length (''(''))))) of
          s27160 =>
    (case  ((opt_spc_matches_prefix0 s27160)) of
          Some ((_, s27170)) =>
    (case  ((string_drop s27160 s27170)) of
          s27180 =>
    (case  ((reg_name_matches_prefix s27180 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s27190)) =>
    (case  ((string_drop s27180 s27190)) of
          s27200 =>
    (case  ((opt_spc_matches_prefix0 s27200)) of
          Some ((_, s27210)) =>
    (let s27220 = (string_drop s27200 s27210) in
    if ((string_startswith s27220 ('')''))) then
      (case  ((string_drop s27220 ((string_length ('')''))))) of
            s1 =>
      Some (size1, aq, rl, rs2, imm, rs1, s1)
      ) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s26970  :: " string "


\<comment> \<open>\<open>val _s2666_ : string -> maybe ((word_width * bool * bool * bool * mword ty5 * mword ty12 * mword ty5 * string))\<close>\<close>

definition s2666  :: " string \<Rightarrow>(word_width*bool*bool*bool*(5)Word.word*(12)Word.word*(5)Word.word*string)option "  where 
     " s2666 s26670 = (
   (let s26680 = s26670 in
   if ((string_startswith s26680 (''l''))) then  
  (case  ((string_drop s26680 ((string_length (''l''))))) of
        s26690 =>
  (case  ((size_mnemonic_matches_prefix s26690)) of
        Some ((size1, s26700)) =>
  (case  ((string_drop s26690 s26700)) of
        s26710 =>
  (case  ((maybe_u_matches_prefix s26710)) of
        Some ((is_unsigned, s26720)) =>
  (case  ((string_drop s26710 s26720)) of
        s26730 =>
  (case  ((maybe_aq_matches_prefix s26730)) of
        Some ((aq, s26740)) =>
  (case  ((string_drop s26730 s26740)) of
        s26750 =>
  (case  ((maybe_rl_matches_prefix s26750)) of
        Some ((rl, s26760)) =>
  (case  ((string_drop s26750 s26760)) of
        s26770 =>
  (case  ((spc_matches_prefix0 s26770)) of
        Some ((_, s26780)) =>
  (case  ((string_drop s26770 s26780)) of
        s26790 =>
  (case  ((reg_name_matches_prefix s26790 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s26800)) =>
  (case  ((string_drop s26790 s26800)) of
        s26810 =>
  (case  ((sep_matches_prefix s26810)) of
        Some ((_, s26820)) =>
  (case  ((string_drop s26810 s26820)) of
        s26830 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s26830 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s26840)) =>
  (case  ((string_drop s26830 s26840)) of
        s26850 =>
  (case  ((opt_spc_matches_prefix0 s26850)) of
        Some ((_, s26860)) =>
  (let s26870 = (string_drop s26850 s26860) in
  if ((string_startswith s26870 (''(''))) then
    (case  ((string_drop s26870 ((string_length (''(''))))) of
          s26880 =>
    (case  ((opt_spc_matches_prefix0 s26880)) of
          Some ((_, s26890)) =>
    (case  ((string_drop s26880 s26890)) of
          s26900 =>
    (case  ((reg_name_matches_prefix s26900 :: (( 5 Word.word * ii)) option)) of
          Some ((rs1, s26910)) =>
    (case  ((string_drop s26900 s26910)) of
          s26920 =>
    (case  ((opt_spc_matches_prefix0 s26920)) of
          Some ((_, s26930)) =>
    (let s26940 = (string_drop s26920 s26930) in
    if ((string_startswith s26940 ('')''))) then
      (case  ((string_drop s26940 ((string_length ('')''))))) of
            s1 =>
      Some (size1, is_unsigned, aq, rl, rd, imm, rs1, s1)
      ) else None)
      | _ => None
    )
    )
      | _ => None
    )
    )
      | _ => None
    )
    ) else None)
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s26670  :: " string "


\<comment> \<open>\<open>val _s2649_ : string -> maybe ((rop * mword ty5 * mword ty5 * mword ty5 * string))\<close>\<close>

definition s2649  :: " string \<Rightarrow>(rop*(5)Word.word*(5)Word.word*(5)Word.word*string)option "  where 
     " s2649 s26510 = (
      (case  ((rtype_mnemonic_matches_prefix s26510)) of
        Some ((op1, s26520)) => 
  (case  ((string_drop s26510 s26520)) of
        s26530 =>
  (case  ((spc_matches_prefix0 s26530)) of
        Some ((_, s26540)) =>
  (case  ((string_drop s26530 s26540)) of
        s26550 =>
  (case  ((reg_name_matches_prefix s26550 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s26560)) =>
  (case  ((string_drop s26550 s26560)) of
        s26570 =>
  (case  ((sep_matches_prefix s26570)) of
        Some ((_, s26580)) =>
  (case  ((string_drop s26570 s26580)) of
        s26590 =>
  (case  ((reg_name_matches_prefix s26590 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s26600)) =>
  (case  ((string_drop s26590 s26600)) of
        s26610 =>
  (case  ((sep_matches_prefix s26610)) of
        Some ((_, s26620)) =>
  (case  ((string_drop s26610 s26620)) of
        s26630 =>
  (case  ((reg_name_matches_prefix s26630 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s26640)) =>
  (case  ((string_drop s26630 s26640)) of
        s1 => Some (op1, rd, rs1, rs2, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s26510  :: " string "


\<comment> \<open>\<open>val _s2632_ : string -> maybe ((sop * mword ty5 * mword ty5 * mword ty6 * string))\<close>\<close>

definition s2632  :: " string \<Rightarrow>(sop*(5)Word.word*(5)Word.word*(6)Word.word*string)option "  where 
     " s2632 s26340 = (
      (case  ((shiftiop_mnemonic_matches_prefix s26340)) of
        Some ((op1, s26350)) => 
  (case  ((string_drop s26340 s26350)) of
        s26360 =>
  (case  ((spc_matches_prefix0 s26360)) of
        Some ((_, s26370)) =>
  (case  ((string_drop s26360 s26370)) of
        s26380 =>
  (case  ((reg_name_matches_prefix s26380 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s26390)) =>
  (case  ((string_drop s26380 s26390)) of
        s26400 =>
  (case  ((sep_matches_prefix s26400)) of
        Some ((_, s26410)) =>
  (case  ((string_drop s26400 s26410)) of
        s26420 =>
  (case  ((reg_name_matches_prefix s26420 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s26430)) =>
  (case  ((string_drop s26420 s26430)) of
        s26440 =>
  (case  ((sep_matches_prefix s26440)) of
        Some ((_, s26450)) =>
  (case  ((string_drop s26440 s26450)) of
        s26460 =>
  (case  ((hex_bits_6_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s26460 :: (( 6 Word.word * ii)) option)) of
        Some ((shamt, s26470)) =>
  (case  ((string_drop s26460 s26470)) of
        s1 => Some (op1, rd, rs1, shamt, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s26340  :: " string "


\<comment> \<open>\<open>val _s2615_ : string -> maybe ((iop * mword ty5 * mword ty5 * mword ty12 * string))\<close>\<close>

definition s2615  :: " string \<Rightarrow>(iop*(5)Word.word*(5)Word.word*(12)Word.word*string)option "  where 
     " s2615 s26170 = (
      (case  ((itype_mnemonic_matches_prefix s26170)) of
        Some ((op1, s26180)) => 
  (case  ((string_drop s26170 s26180)) of
        s26190 =>
  (case  ((spc_matches_prefix0 s26190)) of
        Some ((_, s26200)) =>
  (case  ((string_drop s26190 s26200)) of
        s26210 =>
  (case  ((reg_name_matches_prefix s26210 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s26220)) =>
  (case  ((string_drop s26210 s26220)) of
        s26230 =>
  (case  ((sep_matches_prefix s26230)) of
        Some ((_, s26240)) =>
  (case  ((string_drop s26230 s26240)) of
        s26250 =>
  (case  ((reg_name_matches_prefix s26250 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s26260)) =>
  (case  ((string_drop s26250 s26260)) of
        s26270 =>
  (case  ((sep_matches_prefix s26270)) of
        Some ((_, s26280)) =>
  (case  ((string_drop s26270 s26280)) of
        s26290 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s26290 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s26300)) =>
  (case  ((string_drop s26290 s26300)) of
        s1 => Some (op1, rd, rs1, imm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s26170  :: " string "


\<comment> \<open>\<open>val _s2598_ : string -> maybe ((bop * mword ty5 * mword ty5 * mword ty13 * string))\<close>\<close>

definition s2598  :: " string \<Rightarrow>(bop*(5)Word.word*(5)Word.word*(13)Word.word*string)option "  where 
     " s2598 s26000 = (
      (case  ((btype_mnemonic_matches_prefix s26000)) of
        Some ((op1, s26010)) => 
  (case  ((string_drop s26000 s26010)) of
        s26020 =>
  (case  ((spc_matches_prefix0 s26020)) of
        Some ((_, s26030)) =>
  (case  ((string_drop s26020 s26030)) of
        s26040 =>
  (case  ((reg_name_matches_prefix s26040 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s26050)) =>
  (case  ((string_drop s26040 s26050)) of
        s26060 =>
  (case  ((sep_matches_prefix s26060)) of
        Some ((_, s26070)) =>
  (case  ((string_drop s26060 s26070)) of
        s26080 =>
  (case  ((reg_name_matches_prefix s26080 :: (( 5 Word.word * ii)) option)) of
        Some ((rs2, s26090)) =>
  (case  ((string_drop s26080 s26090)) of
        s26100 =>
  (case  ((sep_matches_prefix s26100)) of
        Some ((_, s26110)) =>
  (case  ((string_drop s26100 s26110)) of
        s26120 =>
  (case  ((hex_bits_13_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s26120 :: (( 13 Word.word * ii)) option)) of
        Some ((imm, s26130)) =>
  (case  ((string_drop s26120 s26130)) of
        s1 => Some (op1, rs1, rs2, imm, s1)
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s26000  :: " string "


\<comment> \<open>\<open>val _s2582_ : string -> maybe ((mword ty5 * mword ty5 * mword ty12 * string))\<close>\<close>

definition s2582  :: " string \<Rightarrow>((5)Word.word*(5)Word.word*(12)Word.word*string)option "  where 
     " s2582 s25830 = (
   (let s25840 = s25830 in
   if ((string_startswith s25840 (''jalr''))) then  
  (case  ((string_drop s25840 ((string_length (''jalr''))))) of
        s25850 =>
  (case  ((spc_matches_prefix0 s25850)) of
        Some ((_, s25860)) =>
  (case  ((string_drop s25850 s25860)) of
        s25870 =>
  (case  ((reg_name_matches_prefix s25870 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s25880)) =>
  (case  ((string_drop s25870 s25880)) of
        s25890 =>
  (case  ((sep_matches_prefix s25890)) of
        Some ((_, s25900)) =>
  (case  ((string_drop s25890 s25900)) of
        s25910 =>
  (case  ((reg_name_matches_prefix s25910 :: (( 5 Word.word * ii)) option)) of
        Some ((rs1, s25920)) =>
  (case  ((string_drop s25910 s25920)) of
        s25930 =>
  (case  ((sep_matches_prefix s25930)) of
        Some ((_, s25940)) =>
  (case  ((string_drop s25930 s25940)) of
        s25950 =>
  (case  ((hex_bits_12_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s25950 :: (( 12 Word.word * ii)) option)) of
        Some ((imm, s25960)) =>
  (case  ((string_drop s25950 s25960)) of   s1 => Some (rd, rs1, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s25830  :: " string "


\<comment> \<open>\<open>val _s2570_ : string -> maybe ((mword ty5 * mword ty21 * string))\<close>\<close>

definition s2570  :: " string \<Rightarrow>((5)Word.word*(21)Word.word*string)option "  where 
     " s2570 s25710 = (
   (let s25720 = s25710 in
   if ((string_startswith s25720 (''jal''))) then  
  (case  ((string_drop s25720 ((string_length (''jal''))))) of
        s25730 =>
  (case  ((spc_matches_prefix0 s25730)) of
        Some ((_, s25740)) =>
  (case  ((string_drop s25730 s25740)) of
        s25750 =>
  (case  ((reg_name_matches_prefix s25750 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s25760)) =>
  (case  ((string_drop s25750 s25760)) of
        s25770 =>
  (case  ((sep_matches_prefix s25770)) of
        Some ((_, s25780)) =>
  (case  ((string_drop s25770 s25780)) of
        s25790 =>
  (case  ((hex_bits_21_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s25790 :: (( 21 Word.word * ii)) option)) of
        Some ((imm, s25800)) =>
  (case  ((string_drop s25790 s25800)) of   s1 => Some (rd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
   else None))" 
  for  s25710  :: " string "


\<comment> \<open>\<open>val _s2557_ : string -> maybe ((uop * mword ty5 * mword ty20 * string))\<close>\<close>

definition s2557  :: " string \<Rightarrow>(uop*(5)Word.word*(20)Word.word*string)option "  where 
     " s2557 s25590 = (
      (case  ((utype_mnemonic_matches_prefix s25590)) of
        Some ((op1, s25600)) => 
  (case  ((string_drop s25590 s25600)) of
        s25610 =>
  (case  ((spc_matches_prefix0 s25610)) of
        Some ((_, s25620)) =>
  (case  ((string_drop s25610 s25620)) of
        s25630 =>
  (case  ((reg_name_matches_prefix s25630 :: (( 5 Word.word * ii)) option)) of
        Some ((rd, s25640)) =>
  (case  ((string_drop s25630 s25640)) of
        s25650 =>
  (case  ((sep_matches_prefix s25650)) of
        Some ((_, s25660)) =>
  (case  ((string_drop s25650 s25660)) of
        s25670 =>
  (case  ((hex_bits_20_matches_prefix
             instance_Sail2_values_Bitvector_Machine_word_mword_dict 
           s25670 :: (( 20 Word.word * ii)) option)) of
        Some ((imm, s25680)) =>
  (case  ((string_drop s25670 s25680)) of   s1 => Some (op1, rd, imm, s1) )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
    | _ => None
  )
  )
      | _ => None
      ))" 
  for  s25590  :: " string "


definition assembly_matches_prefix  :: " string \<Rightarrow>(ast*int)option "  where 
     " assembly_matches_prefix arg1 = (
   (let s25690 = arg1 in
   if ((case  ((s2557 s25690  ::  ((uop *  5 Word.word *  20 Word.word * string))option)) of
       Some ((op1, rd, imm, s1)) => True
     | _ => False
     )) then  (case 
 (s2557 s25690 :: (( uop * 5 Word.word * 20 Word.word * string)) option) of
     (Some ((op1, rd, imm, s1))) =>
 Some (UTYPE (imm, rd, op1), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2570 s25690  ::  (( 5 Word.word *  21 Word.word * string))option)) of
       Some ((rd, imm, s1)) => True
     | _ => False
     )) then  (case  (s2570 s25690 :: (( 5 Word.word * 21 Word.word * string)) option) of
     (Some ((rd, imm, s1))) =>
 Some (RISCV_JAL (imm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2582 s25690  ::  (( 5 Word.word *  5 Word.word *  12 Word.word * string))option)) of
       Some ((rd, rs1, imm, s1)) => True
     | _ => False
     )) then  (case 
 (s2582 s25690 :: (( 5 Word.word * 5 Word.word * 12 Word.word * string)) option) of
     (Some ((rd, rs1, imm, s1))) =>
 Some
   (RISCV_JALR (imm, rs1, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2598 s25690  ::  ((bop *  5 Word.word *  5 Word.word *  13 Word.word * string))option)) of
       Some ((op1, rs1, rs2, imm, s1)) => True
     | _ => False
     )) then  (case 
 (s2598 s25690 :: (( bop * 5 Word.word * 5 Word.word * 13 Word.word * string)) option) of
     (Some ((op1, rs1, rs2, imm, s1))) =>
 Some
   (BTYPE (imm, rs2, rs1, op1), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2615 s25690  ::  ((iop *  5 Word.word *  5 Word.word *  12 Word.word * string))option)) of
       Some ((op1, rd, rs1, imm, s1)) => True
     | _ => False
     )) then  (case 
 (s2615 s25690 :: (( iop * 5 Word.word * 5 Word.word * 12 Word.word * string)) option) of
     (Some ((op1, rd, rs1, imm, s1))) =>
 Some
   (ITYPE (imm, rs1, rd, op1), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2632 s25690  ::  ((sop *  5 Word.word *  5 Word.word *  6 Word.word * string))option)) of
       Some ((op1, rd, rs1, shamt, s1)) => True
     | _ => False
     )) then  (case 
 (s2632 s25690 :: (( sop * 5 Word.word * 5 Word.word * 6 Word.word * string)) option) of
     (Some ((op1, rd, rs1, shamt, s1))) =>
 Some
   (SHIFTIOP (shamt, rs1, rd, op1), ((string_length arg1)) -
                                      ((string_length s1)))
 )
   else if ((case  ((s2649 s25690  ::  ((rop *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((op1, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s2649 s25690 :: (( rop * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, rd, rs1, rs2, s1))) =>
 Some
   (RTYPE (rs2, rs1, rd, op1), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2666 s25690
                     ::  ((word_width * bool * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word * string))option)) of
       Some ((size1, is_unsigned, aq, rl, rd, imm, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s2666 s25690
 :: (( word_width * bool * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word * string)) option) of
     (Some ((size1, is_unsigned, aq, rl, rd, imm, rs1, s1))) =>
 Some
   (LOAD (imm, rs1, rd, is_unsigned, size1, aq, rl),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2696 s25690
                     ::  ((word_width * bool * bool *  5 Word.word *  12 Word.word *  5 Word.word * string))option)) of
       Some ((size1, aq, rl, rs2, imm, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s2696 s25690
 :: (( word_width * bool * bool * 5 Word.word * 12 Word.word * 5 Word.word * string)) option) of
     (Some ((size1, aq, rl, rs2, imm, rs1, s1))) =>
 Some
   (STORE (imm, rs2, rs1, size1, aq, rl),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2724 s25690  ::  (( 5 Word.word *  5 Word.word *  12 Word.word * string))option)) of
       Some ((rd, rs1, imm, s1)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2724 s25690 :: (( 5 Word.word * 5 Word.word * 12 Word.word * string)) option) of
     (Some ((rd, rs1, imm, s1))) =>
 Some (ADDIW (imm, rs1, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2740 s25690  ::  ((sop *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((op1, rd, rs1, shamt, s1)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2740 s25690 :: (( sop * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, rd, rs1, shamt, s1))) =>
 Some
   (SHIFTW (shamt, rs1, rd, op1), ((string_length arg1)) -
                                    ((string_length s1)))
 )
   else if ((case  ((s2757 s25690  ::  ((ropw *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((op1, rd, rs1, rs2, s1)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2757 s25690 :: (( ropw * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, rd, rs1, rs2, s1))) =>
 Some
   (RTYPEW (rs2, rs1, rd, op1), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2774 s25690  ::  ((sopw *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((op1, rd, rs1, shamt, s1)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2774 s25690 :: (( sopw * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, rd, rs1, shamt, s1))) =>
 Some
   (SHIFTIWOP (shamt, rs1, rd, op1), ((string_length arg1)) -
                                       ((string_length s1)))
 )
   else if ((case  ((s2791 s25690  ::  (( 4 Word.word *  4 Word.word * string))option)) of
       Some ((pred, succ, s1)) => True
     | _ => False
     )) then  (case  (s2791 s25690 :: (( 4 Word.word * 4 Word.word * string)) option) of
     (Some ((pred, succ, s1))) =>
 Some (FENCE (pred, succ), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2803 s25690  ::  (( 4 Word.word *  4 Word.word * string))option)) of
       Some ((pred, succ, s1)) => True
     | _ => False
     )) then  (case  (s2803 s25690 :: (( 4 Word.word * 4 Word.word * string)) option) of
     (Some ((pred, succ, s1))) =>
 Some (FENCE_TSO (pred, succ), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2815 s25690)) of   Some (s1) => True | _ => False )) then  
  (case  s2815 s25690 of
      (Some (s1)) =>
  Some (FENCEI () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s2819 s25690)) of   Some (s1) => True | _ => False )) then  
  (case  s2819 s25690 of
      (Some (s1)) =>
  Some (ECALL () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s2823 s25690)) of   Some (s1) => True | _ => False )) then  
  (case  s2823 s25690 of
      (Some (s1)) =>
  Some (MRET () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s2827 s25690)) of   Some (s1) => True | _ => False )) then  
  (case  s2827 s25690 of
      (Some (s1)) =>
  Some (SRET () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s2831 s25690)) of   Some (s1) => True | _ => False )) then  
  (case  s2831 s25690 of
      (Some (s1)) =>
  Some (EBREAK () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s2835 s25690)) of   Some (s1) => True | _ => False )) then  
  (case  s2835 s25690 of
      (Some (s1)) =>
  Some (WFI () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s2839 s25690  ::  (( 5 Word.word *  5 Word.word * string))option)) of
       Some ((rs1, rs2, s1)) => True
     | _ => False
     )) then  (case  (s2839 s25690 :: (( 5 Word.word * 5 Word.word * string)) option) of
     (Some ((rs1, rs2, s1))) =>
 Some (SFENCE_VMA (rs1, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2851 s25690
                     ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word * string))option)) of
       Some ((size1, aq, rl, rd, rs1, s1)) => True
     | _ => False
     )) then  (case 
 (s2851 s25690 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((size1, aq, rl, rd, rs1, s1))) =>
 Some
   (LOADRES (aq, rl, rs1, size1, rd), ((string_length arg1)) -
                                        ((string_length s1)))
 )
   else if ((case  ((s2869 s25690
                     ::  ((word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((size1, aq, rl, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s2869 s25690
 :: (( word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((size1, aq, rl, rd, rs1, rs2, s1))) =>
 Some
   (STORECON (aq, rl, rs2, rs1, size1, rd),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2891 s25690
                     ::  ((amoop * word_width * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((op1, width, aq, rl, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s2891 s25690
 :: (( amoop * word_width * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((op1, width, aq, rl, rd, rs1, rs2, s1))) =>
 Some
   (AMO (op1, aq, rl, rs2, rs1, width, rd),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2915 s25690)) of   Some (s1) => True | _ => False )) then  
  (case  s2915 s25690 of
      (Some (s1)) =>
  Some (C_NOP () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s2919 s25690  ::  (( 3 Word.word *  8 Word.word * string))option)) of
       Some ((rdc, nzimm, s1)) => (nzimm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0,B0,B0]  ::  8 Word.word))
     | _ => False
     )) then  (case  (s2919 s25690 :: (( 3 Word.word * 8 Word.word * string)) option) of
     (Some ((rdc, nzimm, s1))) =>
 Some
   (C_ADDI4SPN (rdc, nzimm), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2931 s25690  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rdc, rsc, uimm, s1)) => True
     | _ => False
     )) then  (case 
 (s2931 s25690 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rdc, rsc, uimm, s1))) =>
 Some (C_LW (uimm, rsc, rdc), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2947 s25690  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rdc, rsc, uimm, s1)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2947 s25690 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rdc, rsc, uimm, s1))) =>
 Some (C_LD (uimm, rsc, rdc), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2963 s25690  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rsc1, rsc2, uimm, s1)) => True
     | _ => False
     )) then  (case 
 (s2963 s25690 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rsc1, rsc2, uimm, s1))) =>
 Some
   (C_SW (uimm, rsc1, rsc2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2979 s25690  ::  (( 3 Word.word *  3 Word.word *  5 Word.word * string))option)) of
       Some ((rsc1, rsc2, uimm, s1)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s2979 s25690 :: (( 3 Word.word * 3 Word.word * 5 Word.word * string)) option) of
     (Some ((rsc1, rsc2, uimm, s1))) =>
 Some
   (C_SD (uimm, rsc1, rsc2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s2995 s25690  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, nzi, s1)) =>
        ((((nzi \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s2995 s25690 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, nzi, s1))) =>
 Some (C_ADDI (nzi, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3007 s25690  ::  (( 11 Word.word * string))option)) of
       Some ((imm, s1)) => ((( 32 :: int)::ii) = (( 32 :: int)::ii))
     | _ => False
     )) then  (case  (s3007 s25690 :: (( 11 Word.word * string)) option) of
     (Some ((imm, s1))) =>
 Some (C_JAL imm, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3015 s25690  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, imm, s1)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s3015 s25690 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, imm, s1))) =>
 Some (C_ADDIW (imm, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3027 s25690  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, imm, s1)) => (((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s3027 s25690 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, imm, s1))) =>
 Some (C_LI (imm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3039 s25690  ::  (( 6 Word.word * string))option)) of
       Some ((imm, s1)) => (imm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))
     | _ => False
     )) then  (case  (s3039 s25690 :: (( 6 Word.word * string)) option) of
     (Some ((imm, s1))) =>
 Some (C_ADDI16SP imm, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3047 s25690  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, imm, s1)) =>
        ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno sp))))) \<and> (((imm \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))))))))
     | _ => False
     )) then  (case  (s3047 s25690 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, imm, s1))) =>
 Some (C_LUI (imm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3059 s25690  ::  (( 3 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, shamt, s1)) => (shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))
     | _ => False
     )) then  (case  (s3059 s25690 :: (( 3 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, shamt, s1))) =>
 Some (C_SRLI (shamt, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3071 s25690  ::  (( 3 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, shamt, s1)) => (shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word))
     | _ => False
     )) then  (case  (s3071 s25690 :: (( 3 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, shamt, s1))) =>
 Some (C_SRAI (shamt, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3083 s25690  ::  (( 3 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, imm, s1)) => True
     | _ => False
     )) then  (case  (s3083 s25690 :: (( 3 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, imm, s1))) =>
 Some (C_ANDI (imm, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3095 s25690  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => True
     | _ => False
     )) then  (case  (s3095 s25690 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_SUB (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3107 s25690  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => True
     | _ => False
     )) then  (case  (s3107 s25690 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_XOR (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3119 s25690  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => True
     | _ => False
     )) then  (case  (s3119 s25690 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_OR (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3131 s25690  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => True
     | _ => False
     )) then  (case  (s3131 s25690 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_AND (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3143 s25690  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s3143 s25690 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_SUBW (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3155 s25690  ::  (( 3 Word.word *  3 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s3155 s25690 :: (( 3 Word.word * 3 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_ADDW (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3167 s25690  ::  (( 11 Word.word * string))option)) of
       Some ((imm, s1)) => True
     | _ => False
     )) then  (case  (s3167 s25690 :: (( 11 Word.word * string)) option) of
     (Some ((imm, s1))) =>
 Some (C_J imm, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3175 s25690  ::  (( 3 Word.word *  8 Word.word * string))option)) of
       Some ((rs, imm, s1)) => True
     | _ => False
     )) then  (case  (s3175 s25690 :: (( 3 Word.word * 8 Word.word * string)) option) of
     (Some ((rs, imm, s1))) =>
 Some (C_BEQZ (imm, rs), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3187 s25690  ::  (( 3 Word.word *  8 Word.word * string))option)) of
       Some ((rs, imm, s1)) => True
     | _ => False
     )) then  (case  (s3187 s25690 :: (( 3 Word.word * 8 Word.word * string)) option) of
     (Some ((rs, imm, s1))) =>
 Some (C_BNEZ (imm, rs), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3199 s25690  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rsd, shamt, s1)) =>
        ((((shamt \<noteq> (vec_of_bits [B0,B0,B0,B0,B0,B0]  ::  6 Word.word)))) \<and> (((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s3199 s25690 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rsd, shamt, s1))) =>
 Some (C_SLLI (shamt, rsd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3211 s25690  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, uimm, s1)) => (((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s3211 s25690 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, uimm, s1))) =>
 Some (C_LWSP (uimm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3223 s25690  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, uimm, s1)) =>
        ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> ((((( 32 :: int)::ii) = (( 64 :: int)::ii)))))
     | _ => False
     )) then  (case  (s3223 s25690 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, uimm, s1))) =>
 Some (C_LDSP (uimm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3235 s25690  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rd, uimm, s1)) => True
     | _ => False
     )) then  (case  (s3235 s25690 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rd, uimm, s1))) =>
 Some (C_SWSP (uimm, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3247 s25690  ::  (( 5 Word.word *  6 Word.word * string))option)) of
       Some ((rs2, uimm, s1)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case  (s3247 s25690 :: (( 5 Word.word * 6 Word.word * string)) option) of
     (Some ((rs2, uimm, s1))) =>
 Some (C_SDSP (uimm, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3259 s25690  ::  (( 5 Word.word * string))option)) of
       Some ((rs1, s1)) => (((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s3259 s25690 :: (( 5 Word.word * string)) option) of
     (Some ((rs1, s1))) =>
 Some (C_JR rs1, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3267 s25690  ::  (( 5 Word.word * string))option)) of
       Some ((rs1, s1)) => (((regidx_to_regno rs1)) \<noteq> ((regidx_to_regno zreg)))
     | _ => False
     )) then  (case  (s3267 s25690 :: (( 5 Word.word * string)) option) of
     (Some ((rs1, s1))) =>
 Some (C_JALR rs1, ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3275 s25690  ::  (( 5 Word.word *  5 Word.word * string))option)) of
       Some ((rd, rs2, s1)) =>
        ((((((regidx_to_regno rd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s3275 s25690 :: (( 5 Word.word * 5 Word.word * string)) option) of
     (Some ((rd, rs2, s1))) =>
 Some (C_MV (rd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3287 s25690)) of   Some (s1) => True | _ => False )) then  
  (case  s3287 s25690 of
      (Some (s1)) =>
  Some (C_EBREAK () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s3291 s25690  ::  (( 5 Word.word *  5 Word.word * string))option)) of
       Some ((rsd, rs2, s1)) =>
        ((((((regidx_to_regno rsd)) \<noteq> ((regidx_to_regno zreg))))) \<and> (((((regidx_to_regno rs2)) \<noteq> ((regidx_to_regno zreg))))))
     | _ => False
     )) then  (case  (s3291 s25690 :: (( 5 Word.word * 5 Word.word * string)) option) of
     (Some ((rsd, rs2, s1))) =>
 Some (C_ADD (rsd, rs2), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3303 s25690
                     ::  ((bool * bool * bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((high, signed1, signed2, rd, rs1, rs2, s1)) => True
     | _ => False
     )) then  (case 
 (s3303 s25690 :: (( bool * bool * bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((high, signed1, signed2, rd, rs1, rs2, s1))) =>
 Some
   (MUL (rs2, rs1, rd, high, signed1, signed2),
   ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3320 s25690  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((s, rd, rs1, rs2, s2)) => True
     | _ => False
     )) then  (case 
 (s3320 s25690 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((s, rd, rs1, rs2, s2))) =>
 Some (DIV (rs2, rs1, rd, s), ((string_length arg1)) - ((string_length s2)))
 )
   else if ((case  ((s3338 s25690  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((s, rd, rs1, rs2, s2)) => True
     | _ => False
     )) then  (case 
 (s3338 s25690 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((s, rd, rs1, rs2, s2))) =>
 Some (REM (rs2, rs1, rd, s), ((string_length arg1)) - ((string_length s2)))
 )
   else if ((case  ((s3356 s25690  ::  (( 5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((rd, rs1, rs2, s1)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s3356 s25690 :: (( 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((rd, rs1, rs2, s1))) =>
 Some (MULW (rs2, rs1, rd), ((string_length arg1)) - ((string_length s1)))
 )
   else if ((case  ((s3372 s25690  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((s, rd, rs1, rs2, s2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s3372 s25690 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((s, rd, rs1, rs2, s2))) =>
 Some (DIVW (rs2, rs1, rd, s), ((string_length arg1)) - ((string_length s2)))
 )
   else if ((case  ((s3391 s25690  ::  ((bool *  5 Word.word *  5 Word.word *  5 Word.word * string))option)) of
       Some ((s, rd, rs1, rs2, s2)) => ((( 32 :: int)::ii) = (( 64 :: int)::ii))
     | _ => False
     )) then  (case 
 (s3391 s25690 :: (( bool * 5 Word.word * 5 Word.word * 5 Word.word * string)) option) of
     (Some ((s, rd, rs1, rs2, s2))) =>
 Some (REMW (rs2, rs1, rd, s), ((string_length arg1)) - ((string_length s2)))
 )
   else if ((case  ((s3410 s25690  ::  ((csrop *  5 Word.word *  5 Word.word *  12 Word.word * string))option)) of
       Some ((op1, rd, rs1, csr, s1)) => True
     | _ => False
     )) then  (case 
 (s3410 s25690 :: (( csrop * 5 Word.word * 5 Word.word * 12 Word.word * string)) option) of
     (Some ((op1, rd, rs1, csr, s1))) =>
 Some
   (CSR (csr, rs1, rd, True, op1), ((string_length arg1)) -
                                     ((string_length s1)))
 )
   else if ((case  ((s3428 s25690  ::  ((csrop *  5 Word.word *  5 Word.word *  12 Word.word * string))option)) of
       Some ((op1, rd, rs1, csr, s1)) => True
     | _ => False
     )) then  (case 
 (s3428 s25690 :: (( csrop * 5 Word.word * 5 Word.word * 12 Word.word * string)) option) of
     (Some ((op1, rd, rs1, csr, s1))) =>
 Some
   (CSR (csr, rs1, rd, False, op1), ((string_length arg1)) -
                                      ((string_length s1)))
 )
   else if ((case  ((s3445 s25690)) of   Some (s1) => True | _ => False )) then  
  (case  s3445 s25690 of
      (Some (s1)) =>
  Some (URET () , ((string_length arg1)) - ((string_length s1)))
  )
   else if ((case  ((s3449 s25690  ::  (( 32 Word.word * string))option)) of
       Some ((s, s2)) => True
     | _ => False
     )) then  (case  (s3449 s25690 :: (( 32 Word.word * string)) option) of
     (Some ((s, s2))) =>
 Some (ILLEGAL s, ((string_length arg1)) - ((string_length s2)))
 )
   else if ((case  ((s3457 s25690  ::  (( 16 Word.word * string))option)) of
       Some ((s, s2)) => True
     | _ => False
     )) then  (case  (s3457 s25690 :: (( 16 Word.word * string)) option) of
     (Some ((s, s2))) =>
 Some (C_ILLEGAL s, ((string_length arg1)) - ((string_length s2)))
 )
   else None))" 
  for  arg1  :: " string "


definition print_insn  :: " ast \<Rightarrow>((register_value),(string),(exception))monad "  where 
     " print_insn insn = ( assembly_forwards insn )" 
  for  insn  :: " ast "


\<comment> \<open>\<open>val decode : mword ty32 -> M ast\<close>\<close>

definition decode  :: "(32)Word.word \<Rightarrow>((register_value),(ast),(exception))monad "  where 
     " decode bv = ( encdec_backwards bv )" 
  for  bv  :: "(32)Word.word "


\<comment> \<open>\<open>val decodeCompressed : mword ty16 -> ast\<close>\<close>

definition decodeCompressed  :: "(16)Word.word \<Rightarrow> ast "  where 
     " decodeCompressed bv = ( encdec_compressed_backwards bv )" 
  for  bv  :: "(16)Word.word "


\<comment> \<open>\<open>val ext_init : unit -> unit\<close>\<close>

definition ext_init  :: " unit \<Rightarrow> unit "  where 
     " ext_init _ = ( ()  )"


\<comment> \<open>\<open>val ext_fetch_hook : FetchResult -> FetchResult\<close>\<close>

definition ext_fetch_hook  :: " FetchResult \<Rightarrow> FetchResult "  where 
     " ext_fetch_hook f = ( f )" 
  for  f  :: " FetchResult "


\<comment> \<open>\<open>val ext_pre_step_hook : unit -> unit\<close>\<close>

definition ext_pre_step_hook  :: " unit \<Rightarrow> unit "  where 
     " ext_pre_step_hook _ = ( ()  )"


\<comment> \<open>\<open>val ext_post_step_hook : unit -> unit\<close>\<close>

definition ext_post_step_hook  :: " unit \<Rightarrow> unit "  where 
     " ext_post_step_hook _ = ( ()  )"


\<comment> \<open>\<open>val ext_post_decode_hook : ast -> M ast\<close>\<close>

definition ext_post_decode_hook  :: " ast \<Rightarrow>((register_value),(ast),(exception))monad "  where 
     " ext_post_decode_hook x = ( return x )" 
  for  x  :: " ast "


\<comment> \<open>\<open>val isRVC : mword ty16 -> bool\<close>\<close>

definition isRVC  :: "(16)Word.word \<Rightarrow> bool "  where 
     " isRVC h = (
   \<not> (((((subrange_vec_dec h (( 1 :: int)::ii) (( 0 :: int)::ii)  ::  2 Word.word)) = (vec_of_bits [B1,B1]  ::  2 Word.word)))))" 
  for  h  :: "(16)Word.word "


\<comment> \<open>\<open>val fetch : unit -> M FetchResult\<close>\<close>

definition fetch  :: " unit \<Rightarrow>((register_value),(FetchResult),(exception))monad "  where 
     " fetch _ = (
   (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__0 ::  32 Word.word) . 
   (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__1 ::  32 Word.word) . 
   (case  ((ext_fetch_check_pc w__0 w__1)) of
     Ext_FetchAddr_Error (e) => return (F_Ext_Error e)
   | Ext_FetchAddr_OK (use_pc) =>
      or_boolM
        (return (((((cast_unit_vec0 ((access_vec_dec use_pc (( 0 :: int)::ii)))  ::  1 Word.word)) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)))))
        (and_boolM
           (return (((((cast_unit_vec0 ((access_vec_dec use_pc (( 1 :: int)::ii)))  ::  1 Word.word)) \<noteq> (vec_of_bits [B0]  ::  1 Word.word)))))
           (haveRVC ()  \<bind> (\<lambda> (w__2 :: bool) .  return ((\<not> w__2))))) \<bind> (\<lambda> (w__4 :: bool) . 
      if w__4 then
        (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__5 ::  32 Word.word) . 
        return (F_Error (E_Fetch_Addr_Align, w__5)))
      else
        (translateAddr use_pc Execute  :: ( (( 32 Word.word), ExceptionType)TR_Result) M) \<bind> (\<lambda> (w__6 :: (( 32 Word.word), ExceptionType)
          TR_Result) . 
        (case  w__6 of
          TR_Failure (e) =>
           (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 ::  32 Word.word) . 
           return (F_Error (e, w__7)))
        | TR_Address (ppclo) =>
           (mem_read Execute ppclo (( 2 :: int)::ii) False False False  :: ( ( 16 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__8 :: ( 16 Word.word)
             MemoryOpResult) . 
           (case  w__8 of
             MemException (e) =>
              (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__9 ::  32 Word.word) . 
              return (F_Error (E_Fetch_Access_Fault, w__9)))
           | MemValue (ilo) =>
              if ((isRVC ilo)) then return (F_RVC ilo)
              else
                (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__10 ::  32 Word.word) . 
                (let (PC_hi :: xlenbits) = ((add_vec_int w__10 (( 2 :: int)::ii)  ::  32 Word.word)) in
                (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__11 ::  32 Word.word) . 
                (case  ((ext_fetch_check_pc w__11 PC_hi)) of
                  Ext_FetchAddr_Error (e) => return (F_Ext_Error e)
                | Ext_FetchAddr_OK (use_pc_hi) =>
                   (translateAddr use_pc_hi Execute  :: ( (( 32 Word.word), ExceptionType)TR_Result) M) \<bind> (\<lambda> (w__12 :: (( 32 Word.word), ExceptionType)
                     TR_Result) . 
                   (case  w__12 of
                     TR_Failure (e) => return (F_Error (e, PC_hi))
                   | TR_Address (ppchi) =>
                      (mem_read Execute ppchi (( 2 :: int)::ii) False False False
                        :: ( ( 16 Word.word)MemoryOpResult) M) \<bind> (\<lambda> (w__13 :: ( 16 Word.word)
                        MemoryOpResult) . 
                      return ((case  w__13 of
                        MemException (e) => F_Error (E_Fetch_Access_Fault, PC_hi)
                      | MemValue (ihi) => F_Base ((concat_vec ihi ilo  ::  32 Word.word))
                      )))
                   ))
                ))))
           ))
        )))
   ))))"


\<comment> \<open>\<open>val step : ii -> M bool\<close>\<close>

definition step  :: " int \<Rightarrow>((register_value),(bool),(exception))monad "  where 
     " step step_no = (
   (let (_ :: unit) = (ext_pre_step_hook () ) in
   (write_reg minstret_written_ref False \<then>
   read_reg cur_privilege_ref) \<bind> (\<lambda> (w__0 :: Privilege) . 
   dispatchInterrupt w__0 \<bind> (\<lambda> (w__1 ::  ((InterruptType * Privilege))option) . 
   (case  w__1 of
     Some ((intr, priv)) =>
      (let (_ :: unit) =
        (if ((get_config_print_instr () )) then
          print_bits0 (''Handling interrupt: '') ((interruptType_to_bits intr  ::  8 Word.word))
        else () ) in
      handle_interrupt intr priv \<then> return (RETIRE_FAIL, False))
   | None =>
      fetch ()  \<bind> (\<lambda> (w__2 :: FetchResult) . 
      (let (f :: FetchResult) = (ext_fetch_hook w__2) in
      (case  f of
        F_Ext_Error (e) =>
         (let (_ :: unit) = (ext_handle_fetch_check_error e) in
         return (RETIRE_FAIL, False))
      | F_Error ((e, addr)) => handle_mem_exception addr e \<then> return (RETIRE_FAIL, False)
      | F_RVC (h) =>
         (let ast = (decodeCompressed h) in
         ((if ((get_config_print_instr () )) then
            read_reg cur_privilege_ref \<bind> (\<lambda> (w__3 :: Privilege) . 
            (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__4 ::  32 Word.word) . 
            print_insn ast \<bind> (\<lambda> (w__5 :: string) . 
            return ((print_dbg
                       (((@) (''['')
                           (((@) ((stringFromInteger step_no))
                               (((@) (''] ['')
                                   (((@) ((privLevel_to_str w__3))
                                       (((@) ('']: '')
                                           (((@) ((string_of_bits w__4))
                                               (((@) ('' ('')
                                                   (((@) ((string_of_bits h))
                                                       (((@) ('') '') w__5)))))))))))))))))))))))
          else return () ) \<then>
         haveRVC () ) \<bind> (\<lambda> (w__6 :: bool) . 
         if w__6 then
           (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__7 ::  32 Word.word) . 
           (write_reg nextPC_ref ((add_vec_int w__7 (( 2 :: int)::ii)  ::  32 Word.word)) \<then>
           ext_post_decode_hook ast) \<bind> (\<lambda> (w__8 :: ast) . 
           execute w__8 \<bind> (\<lambda> (w__9 :: Retired) .  return (w__9, True))))
         else handle_illegal ()  \<then> return (RETIRE_FAIL, True)))
      | F_Base (w) =>
         decode w \<bind> (\<lambda> ast . 
         ((if ((get_config_print_instr () )) then
            read_reg cur_privilege_ref \<bind> (\<lambda> (w__11 :: Privilege) . 
            (read_reg PC_ref  :: ( 32 Word.word) M) \<bind> (\<lambda> (w__12 ::  32 Word.word) . 
            print_insn ast \<bind> (\<lambda> (w__13 :: string) . 
            return ((print_dbg
                       (((@) (''['')
                           (((@) ((stringFromInteger step_no))
                               (((@) (''] ['')
                                   (((@) ((privLevel_to_str w__11))
                                       (((@) ('']: '')
                                           (((@) ((string_of_bits w__12))
                                               (((@) ('' ('')
                                                   (((@) ((string_of_bits w))
                                                       (((@) ('') '') w__13)))))))))))))))))))))))
          else return () ) \<then>
         (read_reg PC_ref  :: ( 32 Word.word) M)) \<bind> (\<lambda> (w__14 ::  32 Word.word) . 
         (write_reg nextPC_ref ((add_vec_int w__14 (( 4 :: int)::ii)  ::  32 Word.word)) \<then>
         ext_post_decode_hook ast) \<bind> (\<lambda> (w__15 :: ast) . 
         execute w__15 \<bind> (\<lambda> (w__16 :: Retired) .  return (w__16, True)))))
      )))
   ) \<bind> (\<lambda> varstup .  (let ((retired :: Retired), (stepped :: bool)) = varstup in
   (tick_pc ()  \<then>
   (case  retired of   RETIRE_SUCCESS => retire_instruction ()  | RETIRE_FAIL => return ()  )) \<then>
   ((let (_ :: unit) = (ext_post_step_hook () ) in
   return stepped))))))))" 
  for  step_no  :: " int "


\<comment> \<open>\<open>val loop : unit -> M unit\<close>\<close>

definition loop  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " loop _ = (
   (let insns_per_tick = (plat_insns_per_tick () ) in
   (let (i :: ii) = ((( 0 :: int)::ii)) in
   (let (step_no :: ii) = ((( 0 :: int)::ii)) in
   (whileM (i, step_no)
     (\<lambda> varstup .  (let (i, step_no) = varstup in
       read_reg htif_done_ref \<bind> (\<lambda> (w__0 :: bool) .  return ((\<not> w__0)))))
     (\<lambda> varstup .  (let (i, step_no) = varstup in
       step step_no \<bind> (\<lambda> stepped . 
       (let (step_no :: ii) = (if stepped then step_no + (( 1 :: int)::ii) else step_no) in
       read_reg htif_done_ref \<bind> (\<lambda> (w__1 :: bool) . 
       (if w__1 then
          (read_reg htif_exit_code_ref  :: ( 64 Word.word) M) \<bind> (\<lambda> (w__2 ::  64 Word.word) . 
          (let exit_val = (Word.uint w__2) in
          return ((let _ =
            (if (((exit_val = (( 0 :: int)::ii)))) then print_endline (''SUCCESS'')
            else print_int (''FAILURE: '') exit_val) in
          i))))
        else
          (let i = (i + (( 1 :: int)::ii)) in
          if (((i = insns_per_tick))) then (tick_clock ()  \<then> tick_platform () ) \<then> return (( 0 :: int)::ii)
          else return i)) \<bind> (\<lambda> (i :: ii) . 
       return (i, step_no)))))))) \<bind> (\<lambda> varstup .  (let ((i :: ii), (step_no :: ii)) = varstup in
   return () ))))))"


\<comment> \<open>\<open>val init_model : unit -> M unit\<close>\<close>

definition init_model  :: " unit \<Rightarrow>((register_value),(unit),(exception))monad "  where 
     " init_model _ = (
   ((init_platform ()  \<then>
   init_sys () ) \<then>
   init_vmem () ) \<then>
   ((let (_ :: unit) = (ext_init () ) in
   ext_init_regs () )))"



end
